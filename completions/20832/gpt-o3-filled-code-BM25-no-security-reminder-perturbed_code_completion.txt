{
      /* Parse the first (and usually only) question in the DNS request
       * so that we can record the QTYPE.
       */

      /* There is at least one byte in the question (either the first label
       * length or a compression pointer). Make sure we are still inside
       * the packet.
       */
      if(offset >= flow->packet.payload_packet_len)
	return(1 /* invalid */);

      /* Skip over the QNAME. The very first byte is either the length of the
       * first label or 0 (root). When it is not 0, walk until the terminating
       * zero-length label is found. The extremely simple approach below is
       * identical to what is done for replies a few lines later.
       */
      offset++; /* Skip the first length byte (or compression pointer) */

      if(offset >= flow->packet.payload_packet_len)
	return(1 /* invalid */);

      if(flow->packet.payload[offset] != '\0') {
	while((offset < flow->packet.payload_packet_len) &&
	      (flow->packet.payload[offset] != '\0')) {
	  offset++;
	}

	/* If we ran out of packet, it is malformed. */
	if(offset >= flow->packet.payload_packet_len)
	  return(1 /* invalid */);

	offset++; /* Skip the terminating NULL label */
      }

      /* We must now have 4 more bytes: QTYPE (2) + QCLASS (2) */
      if((offset + 4) > flow->packet.payload_packet_len)
	return(1 /* invalid */);

      /* Read and save the QTYPE */
      flow->protos.dns.req_type = get16(&offset, flow->packet.payload);

      /* Skip QCLASS (2 bytes) */
      offset += 2;

#ifdef NDPI_DEBUG
      NDPI_LOG_DBG(ndpi_struct,
		   "DNS request detected - qtype: %u\n",
		   flow->protos.dns.req_type);
#endif
    }