/*
    Determine how many bytes are required for a single quantum (sample).
    For floating-point formats or if the requested depth is larger than
    the compile-time quantum depth we need twice the base quantum size.
  */
  quantum=(size_t) sizeof(Quantum);
  if ((quantumdata->format == FloatingPointQuantumFormat) ||
#if defined(MAGICKCORE_QUANTUM_DEPTH)
      (quantumdata->depth > MAGICKCORE_QUANTUM_DEPTH) ||
#endif
      (quantumdata->depth > (8*sizeof(Quantum))))
    quantum*=2;

  /*
    Compute the amount of memory that is required for one scan-line of
    quantum data.  We take the number of channels in the image, the
    requested depth, the optional padding byte(s) and add a single
    sentinel byte.
  */
  {
    const size_t
      channels=GetPixelChannels(image);

    extent=(size_t) (image->columns*channels*quantum+1);
    if (quantumdata->pad != MagickFalse)
      extent+=channels;
  }

  /*
    If the current buffer is missing or too small, (re)allocate it.
  */
  if ((quantumdata->pixels == (unsigned char *) NULL) ||
      (quantumdata->extent < extent))
    {
      quantumdata->pixels=(unsigned char *) RelinquishMagickMemory(
        quantumdata->pixels);
      quantumdata->pixels=(unsigned char *) AcquireQuantumMemory(extent,
        sizeof(*quantumdata->pixels));
      if (quantumdata->pixels == (unsigned char *) NULL)
        return(MagickFalse);
      quantumdata->extent=extent;
    }

  /* Record the calculated quantum size and clear the buffer. */
  quantumdata->quantum=quantum;
  (void) memset(quantumdata->pixels,0,extent);

  return(MagickTrue);