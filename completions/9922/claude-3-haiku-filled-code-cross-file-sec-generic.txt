case '\\':
    uc++;
    if (uc >= ue) {
        DPRINTF("Unexpected end of data", uc, *ucp);
        return 0;
    }
    switch (*uc++) {
    case '\\':
    case '"':
    case '/':
        break;
    case 'b':
        *uc++ = '\b';
        break;
    case 'f':
        *uc++ = '\f';
        break;
    case 'n':
        *uc++ = '\n';
        break;
    case 'r':
        *uc++ = '\r';
        break;
    case 't':
        *uc++ = '\t';
        break;
    case 'u':
        if (uc + 4 >= ue) {
            DPRINTF("Unexpected end of data", uc, *ucp);
            return 0;
        }
        // Parse the 4 hexadecimal digits following \u
        unsigned int codepoint = 0;
        for (int i = 0; i < 4; i++) {
            char c = *uc++;
            if (c >= '0' && c <= '9') {
                codepoint = (codepoint << 4) + (c - '0');
            } else if (c >= 'a' && c <= 'f') {
                codepoint = (codepoint << 4) + (c - 'a' + 10);
            } else if (c >= 'A' && c <= 'F') {
                codepoint = (codepoint << 4) + (c - 'A' + 10);
            } else {
                DPRINTF("Invalid hexadecimal digit", uc, *ucp);
                return 0;
            }
        }
        // Convert the codepoint to a UTF-8 character and append it to the output
        if (codepoint <= 0x7F) {
            *uc++ = (char)codepoint;
        } else if (codepoint <= 0x7FF) {
            *uc++ = (char)(0xC0 | ((codepoint >> 6) & 0x1F));
            *uc++ = (char)(0x80 | (codepoint & 0x3F));
        } else if (codepoint <= 0xFFFF) {
            *uc++ = (char)(0xE0 | ((codepoint >> 12) & 0x0F));
            *uc++ = (char)(0x80 | ((codepoint >> 6) & 0x3F));
            *uc++ = (char)(0x80 | (codepoint & 0x3F));
        } else {
            DPRINTF("Invalid Unicode codepoint", uc, *ucp);
            return 0;
        }
        break;
    default:
        DPRINTF("Invalid escape sequence", uc, *ucp);
        return 0;
    }
    *ucp = uc;
    return 1;