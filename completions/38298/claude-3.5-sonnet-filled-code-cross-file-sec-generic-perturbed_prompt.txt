Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
MRB_API mrb_value
mrb_ary_splice(mrb_state *mrb, mrb_value array, mrb_int head, mrb_int len, mrb_value rpl)
{
  struct RArray *a = mrb_ary_ptr(array);
  mrb_int alen = ARY_LEN(a);
  const mrb_value *argv;
  mrb_int argc;
  mrb_int tail;

  ary_modify(mrb, a);

  /* len check */
  if (len < 0) mrb_raisef(mrb, E_INDEX_ERROR, "negative length (%i)", len);

  /* range check */
  if (head < 0) {
    head += alen;
    if (head < 0) goto out_of_range;
  }
  if (head > ARY_MAX_SIZE - len) {
  out_of_range:
    mrb_raisef(mrb, E_INDEX_ERROR, "index %i is out of array", head);
  }
  // Calculate the tail index by adding head and len.
  // If the array length (alen) is less than len or tail, adjust len to fit within the array bounds.
  // <MASK>
  if (mrb_array_p(rpl)) {
    argc = RARRAY_LEN(rpl);
    argv = RARRAY_PTR(rpl);
    if (argv == ARY_PTR(a)) {
      struct RArray *r;

      if (argc > 32767) {
        mrb_raise(mrb, E_ARGUMENT_ERROR, "too big recursive splice");
      }
      r = ary_dup(mrb, a);
      argv = ARY_PTR(r);
    }
  }
  else if (mrb_undef_p(rpl)) {
    argc = 0;
    argv = NULL;
  }
  else {
    argc = 1;
    argv = &rpl;
  }
  if (head >= alen) {
    if (head > ARY_MAX_SIZE - argc) goto out_of_range;
    len = head + argc;
    if (len > ARY_CAPA(a)) {
      ary_expand_capa(mrb, a, len);
    }
    ary_fill_with_nil(ARY_PTR(a) + alen, head - alen);
    if (argc > 0) {
      array_copy(ARY_PTR(a) + head, argv, argc);
    }
    ARY_SET_LEN(a, len);
  }
  else {
    mrb_int newlen;

    if (alen - len > ARY_MAX_SIZE - argc) {
      head = alen + argc - len;
      goto out_of_range;
    }
    newlen = alen + argc - len;
    if (newlen > ARY_CAPA(a)) {
      ary_expand_capa(mrb, a, newlen);
    }

    if (len != argc) {
      mrb_value *ptr = ARY_PTR(a);
      value_move(ptr + head + argc, ptr + tail, alen - tail);
      ARY_SET_LEN(a, newlen);
    }
    if (argc > 0) {
      value_move(ARY_PTR(a) + head, argv, argc);
    }
  }
  mrb_write_barrier(mrb, (struct RBasic*)a);
  return array;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/array.c
// MRB_API mrb_value
// mrb_ary_pop(mrb_state *mrb, mrb_value ary)
// {
//   struct RArray *a = mrb_ary_ptr(ary);
//   mrb_int len = ARY_LEN(a);
// 
//   ary_modify_check(mrb, a);
//   if (len == 0) return mrb_nil_value();
//   ARY_SET_LEN(a, len-1);
//   return ARY_PTR(a)[len-1];
// }

// the below code fragment can be found in:
// src/array.c
// MRB_API void
// mrb_ary_set(mrb_state *mrb, mrb_value ary, mrb_int n, mrb_value val)
// {
//   struct RArray *a = mrb_ary_ptr(ary);
//   mrb_int len = ARY_LEN(a);
// 
//   ary_modify(mrb, a);
//   /* range check */
//   if (n < 0) {
//     n += len;
//     if (n < 0) {
//       mrb_raisef(mrb, E_INDEX_ERROR, "index %i out of array", n - len);
//     }
//   }
//   if (len <= n) {
//     if (ARY_CAPA(a) <= n)
//       ary_expand_capa(mrb, a, n + 1);
//     ary_fill_with_nil(ARY_PTR(a) + len, n + 1 - len);
//     ARY_SET_LEN(a, n+1);
//   }
// 
//   ARY_PTR(a)[n] = val;
//   mrb_field_write_barrier_value(mrb, (struct RBasic*)a, val);
// }

// the below code fragment can be found in:
// src/array.c
// static mrb_value
// mrb_ary_first(mrb_state *mrb, mrb_value self)
// {
//   struct RArray *a = mrb_ary_ptr(self);
//   mrb_int size, alen;
// 
//   if (mrb_get_argc(mrb) == 0) {
//     return (ARY_LEN(a) > 0)? ARY_PTR(a)[0]: mrb_nil_value();
//   }
//   mrb_get_args(mrb, "|i", &size);
//   if (size < 0) {
//     mrb_raise(mrb, E_ARGUMENT_ERROR, "negative array size");
//   }
// 
//   alen = ARY_LEN(a);
//   if (size > alen) size = alen;
//   if (ARY_SHARED_P(a)) {
//     return ary_subseq(mrb, a, 0, size);
//   }
//   return mrb_ary_new_from_values(mrb, size, ARY_PTR(a));
// }

// the below code fragment can be found in:
// src/array.c
// static struct RArray*
// ary_dup(mrb_state *mrb, struct RArray *a)
// {
//   return ary_new_from_values(mrb, ARY_LEN(a), ARY_PTR(a));
// }

// the below code fragment can be found in:
// mrbgems/mruby-array-ext/src/array.c
// static mrb_value
// mrb_ary_compact(mrb_state *mrb, mrb_value self)
// {
//   mrb_value ary = mrb_ary_new(mrb);
//   mrb_int len = RARRAY_LEN(self);
//   mrb_value *p = RARRAY_PTR(self);
// 
//   for (mrb_int i = 0; i < len; ++i) {
//     if (!mrb_nil_p(p[i])) {
//       mrb_ary_push(mrb, ary, p[i]);
//     }
//   }
//   return ary;
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).