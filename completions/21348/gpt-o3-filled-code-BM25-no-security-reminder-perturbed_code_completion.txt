{
        /*
         * TZSP (TaZman Sniffer Protocol) dissection.
         * We are interested only in version 1 packets that encapsulate
         * Ethernet frames (encap == 1).  We walk through the optional
         * TZSP tag list until we reach the END tag (type 1) and then
         * jump back to the datalink parsing routine with the new
         * ethernet offset.
         */
        u_int tzsp_off = offset;

        /* Need at least: version(1) + type(1) + encap(2) */
        if((tzsp_off + 4) >= header->caplen)
          break;

        u_int8_t tzsp_version = packet[tzsp_off];
        u_int8_t tzsp_type    = packet[tzsp_off + 1];
        u_int16_t tzsp_encap  = (packet[tzsp_off + 2] << 8) | packet[tzsp_off + 3];

        /* We only handle version 1, ethernet encapsulation (encap == 1) */
        if((tzsp_version != 1) || (tzsp_encap != 1))
          break;

        /* Skip the fixed header */
        tzsp_off += 4;

        /* Walk through the tag list */
        while(tzsp_off < header->caplen) {
          u_int8_t tag_type = packet[tzsp_off++];

          /* END tag */
          if(tag_type == 1)
            break;

          /* PADDING tag (0) has no length field */
          if(tag_type == 0)
            continue;

          /* For any other tag we need the length byte */
          if(tzsp_off >= header->caplen)
            break;

          u_int8_t tag_len = packet[tzsp_off++];
          tzsp_off += tag_len;

          if(tzsp_off > header->caplen)
            break;
        }

        /* Ensure we still have at least an Ethernet header */
        if((tzsp_off + sizeof(struct ndpi_ethhdr)) >= header->caplen)
          break;

        /* Process the encapsulated Ethernet frame */
        eth_offset   = tzsp_off;
        datalink_type = DLT_EN10MB;
        goto datalink_check;
      }