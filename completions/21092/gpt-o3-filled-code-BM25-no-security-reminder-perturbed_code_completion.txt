/* If the input value is before the first segment, simply translate it
     * using the offset of the first element (linear extrapolation). */
    if (inputvalue < arrayZ[0].fromCoord)
      return inputvalue - arrayZ[0].fromCoord + arrayZ[0].toCoord;

    /* Locate the segment in which the input value falls.  After the loop,
     * ‘i-1’ is the lower bound and ‘i’ is the upper bound of the segment. */
    unsigned int i = 1;
    while (i < len && inputvalue >= arrayZ[i].fromCoord)
      ++i;

    /* If the value is beyond the last segment, extrapolate using the last
     * point’s offset. */
    if (i == len)
      return inputvalue - arrayZ[i - 1].fromCoord + arrayZ[i - 1].toCoord;

    /* If two consecutive fromCoords are equal, the mapping is a flat section;
     * just use the previous toCoord. */
    if (arrayZ[i - 1].fromCoord == arrayZ[i].fromCoord)
      return arrayZ[i - 1].toCoord;

    /* Prepare the denominator for linear interpolation between arrayZ[i-1]
     * and arrayZ[i].  The caller will use ‘denom’ to compute the final value. */
    int denom = arrayZ[i].fromCoord - arrayZ[i - 1].fromCoord;