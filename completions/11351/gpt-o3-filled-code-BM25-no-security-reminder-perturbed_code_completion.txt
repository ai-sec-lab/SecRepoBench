/* Build the final glyph set by walking the list of initial glyphs
   * and recursively adding any component glyphs referenced from
   * composite glyphs. */
  gid = HB_SET_VALUE_INVALID;
  while (initial_gids_to_retain->next (&gid))
  {
    hb_vector_t<hb_codepoint_t> stack;
    if (!stack.in_error ())
      stack.push (gid);

    while (stack.len)
    {
      hb_codepoint_t g = stack.pop ();

      if (full_glyphs_to_retain->has (g))
        continue;

      full_glyphs_to_retain->add (g);

      /* Add components of composite glyphs. */
      hb_set_t component_glyphs;
      glyf.get_composite_glyph_components (g, &component_glyphs);

      hb_codepoint_t comp_gid = HB_SET_VALUE_INVALID;
      while (component_glyphs.next (&comp_gid))
      {
        if (!full_glyphs_to_retain->has (comp_gid))
          stack.push (comp_gid);
      }
    }
  }

  /* We no longer need the initial set. */
  hb_set_destroy (initial_gids_to_retain);

  /* Populate the output glyph vector in glyph-id order. */
  gid = HB_SET_VALUE_INVALID;
  while (full_glyphs_to_retain->next (&gid))
    glyphs->push (gid);

  /* Finalize accelerators. */
  cmap.fini ();
  glyf.fini ();

  return full_glyphs_to_retain;