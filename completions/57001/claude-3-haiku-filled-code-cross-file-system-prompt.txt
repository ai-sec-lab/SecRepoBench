// Parse face data from the input buffer for the OFF format. For each face, read
// the number of vertex indices, followed by the indices themselves. Ensure that
// the number of indices does not exceed a specified maximum, and that all indices
// are within the valid range of existing vertices. Log an error if indices are out
// of range or if faces with zero indices are encountered.
for (unsigned int i = 0; i < numFaces; ) {
    NextToken(&car, end);
    const unsigned int numIndices = strtoul10(car, &car);
    if (numIndices > 4) {
        ASSIMP_LOG_ERROR("OFF: Number of indices per face exceeds 4");
        break;
    }
    if (numIndices == 0) {
        ASSIMP_LOG_ERROR("OFF: Face with zero indices encountered");
        break;
    }

    aiFace& face = faces[i++];
    face.mNumIndices = numIndices;
    face.mIndices = new unsigned int[numIndices];
    for (unsigned int j = 0; j < numIndices; ++j) {
        NextToken(&car, end);
        const unsigned int index = strtoul10(car, &car);
        if (index >= numVertices) {
            ASSIMP_LOG_ERROR("OFF: Vertex index out of range");
            face.mIndices[j] = 0;
        } else {
            face.mIndices[j] = index;
        }
    }
}