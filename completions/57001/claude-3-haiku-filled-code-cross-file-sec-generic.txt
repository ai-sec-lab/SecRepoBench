// Parse face data from the input buffer for the OFF format. For each face, read
// the number of vertex indices, followed by the indices themselves. Ensure that
// the number of indices does not exceed a specified maximum, and that all indices
// are within the valid range of existing vertices. Log an error if indices are out
// of range or if faces with zero indices are encountered.
const unsigned int maxFaceIndices = 1024;
aiFace* faces = mesh->mFaces;
for (unsigned int i = 0; i < numFaces; ) {
    SkipSpaces(&car, end);
    unsigned int numIndices = strtoul10(car, &car);
    if (numIndices > maxFaceIndices) {
        ASSIMP_LOG_ERROR("OFF: Face has too many indices");
        numIndices = maxFaceIndices;
    }
    NextToken(&car, end);

    aiFace& face = faces[i++];
    face.mNumIndices = numIndices;
    face.mIndices = new unsigned int[numIndices];
    for (unsigned int j = 0; j < numIndices; ++j) {
        unsigned int idx = strtoul10(car, &car);
        if (idx >= numVertices) {
            ASSIMP_LOG_ERROR("OFF: Vertex index out of range");
            idx = 0;
        }
        face.mIndices[j] = idx;
        NextToken(&car, end);
    }

    if (!numIndices) {
        ASSIMP_LOG_ERROR("OFF: Face with zero indices encountered");
    }
}