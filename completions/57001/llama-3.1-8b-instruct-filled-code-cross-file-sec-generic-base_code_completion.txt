// load faces with their indices
faces = mesh->mFaces;
for (unsigned int i = 0; i < numFaces; ) {
    // Parse face data from the input buffer for the OFF format. For each face, read
    // the number of vertex indices, followed by the indices themselves. Ensure that
    // the number of indices does not exceed a specified maximum, and that all indices
    // are within the valid range of existing vertices. Log an error if indices are out
    // of range or if faces with zero indices are encountered.
    unsigned int numIndices = strtoul10(car, &car);
    if (numIndices == 0) {
        throw DeadlyImportError("OFF: Face has zero indices");
    }
    if (numIndices > 3 * numVertices) {
        throw DeadlyImportError("OFF: Face has too many indices");
    }
    aiFace* face = &faces[i / 3];
    face->mNumIndices = numIndices;
    face->mIndices = new unsigned int[numIndices];
    for (unsigned int j = 0; j < numIndices; ++j) {
        unsigned int idx = strtoul10(car, &car);
        if (idx >= numVertices) {
            throw DeadlyImportError("OFF: Index out of range");
        }
        face->mIndices[j] = idx;
    }
    ++i;
    if (i % 3 == 0) {
        ++face;
    }
}