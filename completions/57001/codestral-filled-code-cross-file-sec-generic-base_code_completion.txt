// Parse face data from the input buffer for the OFF format. For each face, read
// the number of vertex indices, followed by the indices themselves. Ensure that
// the number of indices does not exceed a specified maximum, and that all indices
// are within the valid range of existing vertices. Log an error if indices are out
// of range or if faces with zero indices are encountered.
for (unsigned int i = 0; i < numFaces; ++i) {
    unsigned int numIndices;
    if (!GetNextLine(buffer, line)) {
        ASSIMP_LOG_ERROR("OFF: The number of faces in the header is incorrect");
        break;
    }
    const char *sz = line;
    SkipSpaces(&sz);
    numIndices = strtoul10(sz, &sz);
    if (numIndices > 3) {
        ASSIMP_LOG_ERROR("OFF: Number of face indices higher than 3 unsupported");
        continue;
    }
    if (numIndices == 0) {
        ASSIMP_LOG_ERROR("OFF: Face with zero indices encountered");
        continue;
    }
    aiFace &face = mesh->mFaces[i];
    face.mNumIndices = numIndices;
    face.mIndices = new unsigned int[numIndices];
    for (unsigned int j = 0; j < numIndices; ++j) {
        SkipSpaces(&sz);
        unsigned int index = strtoul10(sz, &sz);
        if (index >= numVertices) {
            ASSIMP_LOG_ERROR("OFF: Index out of range");
            index = 0;
        }
        face.mIndices[j] = index;
    }
}