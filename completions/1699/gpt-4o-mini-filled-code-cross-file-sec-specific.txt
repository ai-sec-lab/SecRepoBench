if (s->num_primitive_matrices > max_primitive_matrices) {
        av_log(m->avctx, AV_LOG_ERROR, "Number of primitive matrices exceeds maximum allowed.\n");
        return AVERROR_INVALIDDATA;
    }

    for (mat = 0; mat < s->num_primitive_matrices; mat++) {
        ch = get_bits(gbp, 4); // Read the matrix output channel
        if (ch >= MAX_CHANNELS) { // Validate channel index
            av_log(m->avctx, AV_LOG_ERROR, "Invalid matrix output channel: %u.\n", ch);
            return AVERROR_INVALIDDATA;
        }

        int fractional_bits = get_bits(gbp, 4); // Read the number of fractional bits
        if (fractional_bits > MAX_FRACTIONAL_BITS) { // Validate fractional bits
            av_log(m->avctx, AV_LOG_ERROR, "Invalid number of fractional bits: %d.\n", fractional_bits);
            return AVERROR_INVALIDDATA;
        }

        int lsb_bypass = get_bits1(gbp); // Read LSB bypass flag

        // Read and store matrix coefficient values
        for (unsigned int channel = 0; channel < MAX_MATRIX_CHANNEL; channel++) {
            s->matrix_coefficients[mat][channel] = get_sbits(gbp, fractional_bits);
        }

        // Check for noise presence and read noise shift value if applicable
        if (get_bits1(gbp)) {
            s->matrix_noise_shift[mat] = get_bits(gbp, 4); // Read noise shift value
        } else {
            s->matrix_noise_shift[mat] = 0; // Set to zero if no noise
        }
    }