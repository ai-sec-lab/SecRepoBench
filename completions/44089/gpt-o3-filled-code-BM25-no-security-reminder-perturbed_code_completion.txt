/* create a zero terminated copy of the token so that we can use the
           standard libc string to number conversion helpers */
        char *numstr = (char*)malloc(str_len + 1);
        if (!numstr) {
            PLIST_JSON_ERR("%s: Out of memory while parsing number\n", __func__);
            return NULL;
        }
        memcpy(numstr, str_val, str_len);
        numstr[str_len] = '\0';

        /* decide whether the value is an integer or a real */
        if (strchr(numstr, '.') || strchr(numstr, 'e') || strchr(numstr, 'E')) {
            /* floating point value */
            double dval = strtod(numstr, &endp);
            if (endp && *endp == '\0') {
                parsed_value = plist_new_real(dval);
            } else {
                PLIST_JSON_ERR("%s: invalid numeric value '%s' encountered\n", __func__, numstr);
            }
        } else {
            /* integer (no decimal point / exponent) */
            if (numstr[0] == '-') {
                /* Signed integer.  libplist only supports unsigned integers,
                   so store negative numbers as REALs to preserve the sign. */
                long long sval = strtoll(numstr, &endp, 10);
                if (endp && *endp == '\0') {
                    parsed_value = plist_new_real((double)sval);
                } else {
                    PLIST_JSON_ERR("%s: invalid numeric value '%s' encountered\n", __func__, numstr);
                }
            } else {
                uint64_t uval = strtoull(numstr, &endp, 10);
                if (endp && *endp == '\0') {
                    parsed_value = plist_new_uint(uval);
                } else {
                    PLIST_JSON_ERR("%s: invalid numeric value '%s' encountered\n", __func__, numstr);
                }
            }
        }
        free(numstr);