/*
     * Handle time strings that lack the year information (e.g: "Jan 12 06:25:15").
     * If the parser configuration generated a 'time_fmt_year' (the original
     * format prefixed with %Y) we prepend the current year so the string can be
     * parsed properly.  After parsing we adjust the returned pointer so it
     * points back to the original buffer (time_str); this is required because
     * the rest of the logic (sub-seconds parsing, etc) relies on that.
     */
    if (timeparser->time_fmt_year) {
        /* get current time to retrieve the year */
        if (now == 0) {
            time_now = time(NULL);
        }
        else {
            time_now = now;
        }

        gmtime_r(&time_now, &tmy);

        /* Compose a temporary string that includes the year */
        snprintf(tmp, sizeof(tmp), "%04d %.*s",
                 tmy.tm_year + 1900, (int) tsize, time_str);

        fmt = timeparser->time_fmt_year;
        p   = flb_strptime(tmp, fmt, tm);
        if (p) {
            /* adjust the returned pointer so it references the original string */
            size_t prefix_len = strlen(tmp) - tsize;  /* bytes we prefixed */
            size_t consumed   = (p - tmp);

            if (consumed >= prefix_len) {
                p = (char *) time_ptr + (consumed - prefix_len);
            }
            else {
                p = NULL;    /* something went really wrong */
            }
        }
    }
    else {
        /*
         * Time string already contains the year.  Copy it to a temporary
         * buffer to ensure it is NUL-terminated before using flb_strptime().
         */
        memcpy(tmp, time_str, tsize);
        tmp[tsize] = '\0';

        fmt = timeparser->time_fmt;
        p   = flb_strptime(tmp, fmt, tm);
        if (p) {
            size_t consumed = (p - tmp);
            p = (char *) time_ptr + consumed;
        }
    }