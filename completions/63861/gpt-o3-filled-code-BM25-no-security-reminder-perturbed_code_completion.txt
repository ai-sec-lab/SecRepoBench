// Is there enough data left for the whole Unicode string?
    if (SizeOfTag < unicodeLength * (cmsUInt32Number) sizeof(cmsUInt16Number))
        goto Done;

    // Allocate room for the Unicode (wchar_t) string (+ terminating 0)
    UnicodeString = (wchar_t*) _cmsMalloc(self ->ContextID,
                                          (unicodeLength + 1) * sizeof(wchar_t));
    if (UnicodeString == NULL)
        goto Done;

    // Read every 16-bit element, converting from big-endian to host order
    for (i = 0; i < unicodeLength; i++) {

        if (!_cmsReadUInt16Number(io, &Dummy))
            goto Done;

        UnicodeString[i] = (wchar_t) Dummy;
    }

    // Add terminator
    UnicodeString[unicodeLength] = 0;

    // Store the Unicode version into the MLU container
    (void) cmsMLUsetWide(mlu, cmsNoLanguage, cmsNoCountry, UnicodeString);

    // Free temporary buffer
    _cmsFree(self ->ContextID, (void*) UnicodeString);
    UnicodeString = NULL;

    // Update remaining size
    SizeOfTag -= unicodeLength * (cmsUInt32Number) sizeof(cmsUInt16Number);

    // -------------------------------------------------------------
    // Optional ScriptCode part – just skip it if present
    // -------------------------------------------------------------
    if (SizeOfTag >= sizeof(cmsUInt16Number)) {

        if (!_cmsReadUInt16Number(io, &ScriptCodeCode))
            goto Done;

        SizeOfTag -= sizeof(cmsUInt16Number);

        if (SizeOfTag >= sizeof(cmsUInt8Number)) {

            if (io ->Read(io, &ScriptCodeCount, sizeof(cmsUInt8Number), 1) != 1)
                goto Done;

            SizeOfTag -= sizeof(cmsUInt8Number);

            // One byte padding (reserved) – make sure it is there
            if (SizeOfTag >= sizeof(cmsUInt8Number)) {
                cmsUInt8Number reserved;
                if (io ->Read(io, &reserved, sizeof(cmsUInt8Number), 1) != 1)
                    goto Done;
                SizeOfTag -= sizeof(cmsUInt8Number);
            }

            // Skip ScriptCode string itself
            if (SizeOfTag >= ScriptCodeCount) {

                char* Skip = (char*) _cmsMalloc(self ->ContextID, ScriptCodeCount);
                if (Skip == NULL)
                    goto Done;

                if (io ->Read(io, Skip, sizeof(char), ScriptCodeCount) != ScriptCodeCount) {
                    _cmsFree(self ->ContextID, Skip);
                    goto Done;
                }

                _cmsFree(self ->ContextID, Skip);
                SizeOfTag -= ScriptCodeCount;
            }
        }
    }

Done:

    if (UnicodeString) _cmsFree(self ->ContextID, (void*) UnicodeString);

    return (void*) mlu;