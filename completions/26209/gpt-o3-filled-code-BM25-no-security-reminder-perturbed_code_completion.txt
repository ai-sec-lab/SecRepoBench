static const struct {
        uint8_t       class_id;   /* 0 = DC, 1 = AC */
        uint8_t       index;      /* 0 = luma , 1 = chroma */
        const uint8_t *bits;      /* number of codes for each length 1..16 */
        const uint8_t *vals;      /* symbols, in JPEG spec order            */
    } ht[] = {
        { 0, 0, avpriv_mjpeg_bits_dc_luminance,   avpriv_mjpeg_val_dc             },
        { 0, 1, avpriv_mjpeg_bits_dc_chrominance, avpriv_mjpeg_val_dc             },
        { 1, 0, avpriv_mjpeg_bits_ac_luminance,   avpriv_mjpeg_val_ac_luminance   },
        { 1, 1, avpriv_mjpeg_bits_ac_chrominance, avpriv_mjpeg_val_ac_chrominance },
    };

    int i, ret;

    for (i = 0; i < FF_ARRAY_ELEMS(ht); i++) {
        const uint8_t  *bits   = ht[i].bits;
        const uint8_t  *values = ht[i].vals;
        int             class  = ht[i].class_id;
        int             idx    = ht[i].index;
        VLC            *vlc    = &mjpegdecodecontext->vlcs[class][idx];

        /* Build VLC for this Huffman table */
        /* For DC tables we have 12 symbols, for AC tables we have up to 162,
         * but the generic build_vlc() for JPEG expects the number of symbols
         * to be the sum of bits[0..15]. */
        int nb_codes = 0;
        for (int k = 0; k < 16; k++)
            nb_codes += bits[k];

        if ((ret = build_vlc(vlc, 9, nb_codes, bits, 1, values, 4)) < 0)
            return ret;

        /* Store raw bits/values so that the decoder can emit a correct DHT
         * segment when it encounters files that omit it (i.e. rely on the
         * default tables defined by the standard). */
        memcpy(mjpegdecodecontext->raw_huffman_length[class][idx], bits, 16);
        memcpy(mjpegdecodecontext->raw_huffman_value [class][idx], values, nb_codes);
    }