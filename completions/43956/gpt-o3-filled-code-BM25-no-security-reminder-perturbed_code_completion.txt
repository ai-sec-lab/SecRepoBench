case 1:            /* -------- after FIRST argument -------- */
        switch (fe)
        {
          case fWhile:            /* while( cond , body )            */
          case fIf:               /* if( cond , then , else )        */
            /* Add conditional jump (destination to be patched later). */
            if (!AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS))
              return MagickFalse;
            firstArgIndex = pfx->usedElements-1;   /* remember element */
            break;

          case fFor:              /* for( init , cond , step , body )*/
            /* We don't need the value resulting from the init part. */
            if (!AddAddressingElement (pfx, rZerStk, NULL_ADDRESS))
              return MagickFalse;
            break;

          /* do( body , cond )  -> nothing special after first arg   */
          default:
            break;
        }
        break;

      case 2:            /* -------- after SECOND argument -------- */
        switch (fe)
        {
          case fWhile:            /* after loop body                 */
            /* Jump back to start (ndx0) – patch exit later.         */
            if (!AddAddressingElement (pfx, rGoto, ndx0))
              return MagickFalse;
            ndx2 = pfx->usedElements-1;
            break;

          case fDo:               /* second arg is the condition     */
            /* Add conditional jump to exit loop (destination patch later). */
            if (!AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS))
              return MagickFalse;
            firstArgIndex = pfx->usedElements-1;

            /* Add jump back to body start (just after initial rGoto).     */
            if (!AddAddressingElement (pfx, rGoto, ndx0+1))
              return MagickFalse;
            ndx2 = pfx->usedElements-1;
            break;

          case fIf:               /* after 'then' part               */
            /* Jump over optional 'else' part – destination patch later.   */
            if (!AddAddressingElement (pfx, rGoto, NULL_ADDRESS))
              return MagickFalse;
            ndx2 = pfx->usedElements-1;
            break;

          case fFor:              /* after condition part            */
            /* Exit loop if condition is false (patch later).        */
            if (!AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS))
              return MagickFalse;
            ndx2 = pfx->usedElements-1;
            break;

          default:
            break;
        }
        break;

      case 3:            /* -------- after THIRD argument -------- */
        switch (fe)
        {
          case fFor:              /* after step expression           */
            /* Discard step result, then jump back to condition.     */
            if (!AddAddressingElement (pfx, rZerStk, NULL_ADDRESS))
              return MagickFalse;
            ndx3 = pfx->usedElements;          /* first element of body */
            if (!AddAddressingElement (pfx, rGoto, ndx0))
              return MagickFalse;
            break;

          case fIf:               /* start of 'else' part            */
            ndx3 = pfx->usedElements;          /* record for patching */
            break;

          default:
            break;
        }
        break;