fun;
        }
      }
    }
    dummy_exception = DestroyExceptionInfo (dummy_exception);
    return 0;
  }

  *v0 = colour.red   / QuantumRange;
  *v1 = colour.green / QuantumRange;
  *v2 = colour.blue  / QuantumRange;
  dummy_exception = DestroyExceptionInfo (dummy_exception);
  return (ssize_t) pfx->lenToken;
}

static MagickBooleanType GetConstant (FxInfo * pfx, fxFltType *val)
{
  ssize_t len;
  len = GetConstantColour (pfx, val, val+1, val+2);
  if (len < 0) return MagickFalse;
  if (len == 0) {
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected constant at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    if (LocaleCompare ("quantumrange", pfx->token)==0) {
      *val = QuantumRange;
      return MagickTrue;
    }
    if (LocaleCompare ("quantumscale", pfx->token)==0) {
      *val = QuantumScale;
      return MagickTrue;
    }
    if (LocaleCompare ("epsilon", pfx->token)==0) {
      *val = MagickEpsilon;
      return MagickTrue;
    }
    if (LocaleCompare ("pi", pfx->token)==0) {
      *val = MagickPI;
      return MagickTrue;
    }
    if (LocaleCompare ("phi", pfx->token)==0) {
      *val = MagickPHI;
      return MagickTrue;
    }
    if (LocaleCompare ("transparent", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("opaque", pfx->token)==0) {
      *val = 1.0;
      return MagickTrue;
    }
    if (LocaleCompare ("MaxRGB", pfx->token)==0) {
      *val = QuantumRange;
      return MagickTrue;
    }
    if (LocaleCompare ("cnull", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("onull", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("rnull", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("snull", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("fnull", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    if (LocaleCompare ("anull", pfx->token)==0) {
      *val = 0.0;
      return MagickTrue;
    }
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Unknown constant", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return MagickFalse;
  }
  pfx->pex += len;
  return MagickTrue;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  int
    nArgs;

  size_t
    len;

  if (fe == fNull) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected function at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }

  nArgs = Functions[fe-FirstFunc].nArgs;

  if (nArgs == 0) {
    if (!AddElement (pfx, (fxFltType) 0, fe)) return MagickFalse;
    return MagickTrue;
  }

  if (nArgs == 1) {
    if (!AddElement (pfx, (fxFltType) 0, fe)) return MagickFalse;
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected argument for function", "'%s' at '%s'",
        Functions[fe-FirstFunc].str, SetShortExp(pfx));
      return MagickFalse;
    }
    pfx->pex += len;
    return MagickTrue;
  }

  if (nArgs == 2) {
    if (!AddElement (pfx, (fxFltType) 0, fe)) return MagickFalse;
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected first argument for function", "'%s' at '%s'",
        Functions[fe-FirstFunc].str, SetShortExp(pfx));
      return MagickFalse;
    }
    pfx->pex += len;
    len = GetToken (pfx);
    if (len == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected second argument for function", "'%s' at '%s'",
        Functions[fe-FirstFunc].str, SetShortExp(pfx));
      return MagickFalse;
    }
    pfx->pex += len;
    return MagickTrue;
  }

  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Internal error: unknown number of arguments for function", "'%s'",
    Functions[fe-FirstFunc].str);
  return MagickFalse;
}

static MagickBooleanType GetSymbol (FxInfo * pfx)
{
  int i;
  for (i=0; i < pfx->usedUserSymbols; i++) {
    if (LocaleCompare (pfx->token, pfx->UserSymbols[i].pex) == 0) {
      if (!AddElement (pfx, (fxFltType) 0, oNull)) return MagickFalse;
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      pel->EleNdx = i;
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown symbol", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetOperator (FxInfo * pfx)
{
  int i;
  for (i=0; i <= oNull; i++) {
    if (LocaleCompare (pfx->token, Operators[i].str) == 0) {
      if (!AddElement (pfx, (fxFltType) 0, i)) return MagickFalse;
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      pel->ChannelQual = GetChannelQualifier (pfx, i);
      pel->ImgAttrQual = GetImgAttrQualifier (pfx, i);
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown operator", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetImgAttr (FxInfo * pfx)
{
  ImgAttrE ia;
  for (ia = FirstImgAttr; ia < aNull; ia=(ImgAttrE) (ia+1)) {
    if (LocaleCompare (pfx->token, ImgAttrs[ia-FirstImgAttr].str) == 0) {
      if (!AddElement (pfx, (fxFltType) 0, ia)) return MagickFalse;
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      pel->ChannelQual = GetChannelQualifier (pfx, ia);
      pel->ImgAttrQual = ia;
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown image attribute", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetSymbolOrImgAttr (FxInfo * pfx)
{
  if (!GetSymbol (pfx)) {
    if (!GetImgAttr (pfx)) {
      return MagickFalse;
    }
  }
  return MagickTrue;
}

static MagickBooleanType GetControl (FxInfo * pfx)
{
  int i;
  for (i=0; i <= rNull; i++) {
    if (LocaleCompare (pfx->token, Controls[i-FirstCont].str) == 0) {
      if (!AddElement (pfx, (fxFltType) 0, i)) return MagickFalse;
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      pel->ChannelQual = GetChannelQualifier (pfx, i);
      pel->ImgAttrQual = GetImgAttrQualifier (pfx, i);
      return MagickTrue;
    }
  }
  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Unknown control", "'%s' at '%s'",
    pfx->token, SetShortExp(pfx));
  return MagickFalse;
}

static MagickBooleanType GetElement (FxInfo * pfx)
{
  if (PeekStr (pfx, "goto")) {
    if (!GetFunction (pfx, fP)) return MagickFalse;
    if (!AddElement (pfx, (fxFltType) 0, rGoto)) return MagickFalse;
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->EleNdx = GetInteger (pfx->token, pfx->pex, pfx->lenToken);
    return MagickTrue;
  }
  if (PeekStr (pfx, "ifzerogoto")) {
    if (!GetFunction (pfx, fP)) return MagickFalse;
    if (!AddElement (pfx, (fxFltType) 0, rIfZeroGoto)) return MagickFalse;
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->EleNdx = GetInteger (pfx->token, pfx->pex, pfx->lenToken);
    return MagickTrue;
  }
  if (PeekStr (pfx, "ifnotzerogoto")) {
    if (!GetFunction (pfx, fP)) return MagickFalse;
    if (!AddElement (pfx, (fxFltType) 0, rIfNotZeroGoto)) return MagickFalse;
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->EleNdx = GetInteger (pfx->token, pfx->pex, pfx->lenToken);
    return MagickTrue;
  }
  if (PeekStr (pfx, "copyfrom")) {
    if (!AddElement (pfx, (fxFltType) 0, rCopyFrom)) return MagickFalse;
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->EleNdx = GetInteger (pfx->token, pfx->pex, pfx->lenToken);
    return MagickTrue;
  }
  if (PeekStr (pfx, "copyto")) {
    if (!AddElement (pfx, (fxFltType) 0, rCopyTo)) return MagickFalse;
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->EleNdx = GetInteger (pfx->token, pfx->pex, pfx->lenToken);
    return MagickTrue;
  }
  if (PeekStr (pfx, "zerstk")) {
    if (!AddElement (pfx, (fxFltType) 0, rZerStk)) return MagickFalse;
    return MagickTrue;
  }
  if (PeekStr (pfx, "do"))