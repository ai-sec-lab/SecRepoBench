// Calculate source positions based on motion vectors
    src_x = s->mb_x * block_s + (motion_x >> lowres);
    src_y = s->mb_y * block_s + (motion_y >> lowres);

    // Ensure source positions are within valid bounds
    if (src_x < 0 || src_x >= s->width || src_y < 0 || src_y >= s->height) {
        // Handle out-of-bounds access by clamping to valid range
        src_x = av_clip(src_x, 0, s->width - 1);
        src_y = av_clip(src_y, 0, s->height - 1);
    }

    // Calculate offsets for luma and chroma planes
    ptr_y = ref_picture[0] + src_y * linesize + src_x;
    ptr_cb = ref_picture[1] + (src_y >> s->chroma_y_shift) * s->uvlinesize + (src_x >> s->chroma_x_shift);
    ptr_cr = ref_picture[2] + (src_y >> s->chroma_y_shift) * s->uvlinesize + (src_x >> s->chroma_x_shift);

    // Apply edge emulation if necessary
    if (src_x < h_edge_pos || src_y < v_edge_pos) {
        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr_y, linesize, linesize, 9, 9, src_x, src_y, h_edge_pos, v_edge_pos);
        ptr_y = s->sc.edge_emu_buffer;
    }

    // Perform motion compensation for luma
    pix_op[op_index](dest_y, ptr_y, linesize, block_s, motion_x, motion_y);

    // Perform motion compensation for chroma
    pix_op[op_index](dest_cb, ptr_cb, s->uvlinesize, block_s, motion_x >> s->chroma_x_shift, motion_y >> s->chroma_y_shift);
    pix_op[op_index](dest_cr, ptr_cr, s->uvlinesize, block_s, motion_x >> s->chroma_x_shift, motion_y >> s->chroma_y_shift);