/* Return empty table if there's nothing to serialize. */
    if (!iterator)
    {
      startGlyph  = 0;
      glyphCount  = 0;
      return_trace (true);
    }

    /* Find min / max glyph id. */
    hb_codepoint_t min_gid = HB_CODEPOINT_MAX;
    hb_codepoint_t max_gid = 0;
    for (Iterator it = iterator; it; ++it)
    {
      auto p = *it;                 /* pair<glyph, class> */
      hb_codepoint_t g = p.first;
      if (g < min_gid) min_gid = g;
      if (g > max_gid) max_gid = g;
    }

    unsigned count = (unsigned) (max_gid - min_gid + 1);
    startGlyph = (uint16_t) min_gid;
    glyphCount = (uint16_t) count;

    /* Allocate space for classValueArray. */
    if (unlikely (!c->extend (*this, count * HBUINT16::static_size))) return_trace (false);

    /* Initialize all to class 0. */
    for (unsigned i = 0; i < count; i++)
      classValueArray[i] = 0;

    /* Fill in class values. */
    for (Iterator it = iterator; it; ++it)
    {
      auto p = *it;
      hb_codepoint_t g   = p.first;
      hb_codepoint_t cls = p.second;
      classValueArray[g - min_gid] = (uint16_t) cls;
    }

    return_trace (true);