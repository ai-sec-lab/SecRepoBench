if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)
  {
    if (units == RESUNIT_INCH)
      image->units=PixelsPerInchResolution;
    if (units == RESUNIT_CENTIMETER)
      image->units=PixelsPerCentimeterResolution;
  }
if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&
    (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))
  {
    image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);
    image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);
  }
if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)
  image->orientation=(OrientationType) orientation;
if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)
  {
    if (chromaticity!= (float *) NULL)
      {
        image->chromaticity.white_point.x=chromaticity[0];
        image->chromaticity.white_point.y=chromaticity[1];
      }
  }
if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)
  {
    if (chromaticity!= (float *) NULL)
      {
        image->chromaticity.red_primary.x=chromaticity[0];
        image->chromaticity.red_primary.y=chromaticity[1];
        image->chromaticity.green_primary.x=chromaticity[2];
        image->chromaticity.green_primary.y=chromaticity[3];
        image->chromaticity.blue_primary.x=chromaticity[4];
        image->chromaticity.blue_primary.y=chromaticity[5];
      }
  }
#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
if ((compress_tag!= COMPRESSION_NONE) &&
    (TIFFIsCODECConfigured(compress_tag) == 0))
  {
    TIFFClose(tiff);
    ThrowReaderException(CoderError,"CompressNotSupported");
  }
#endif
switch (compress_tag)
{
  case COMPRESSION_NONE: image->compression=NoCompression; break;
  case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;
  case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;
  case COMPRESSION_JPEG:
  {
    image->compression=JPEGCompression;
#if defined(JPEG_SUPPORT)
    {
      char
        sampling_factor[MagickPathExtent];

      uint16
        horizontal,
        vertical;

      tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,
        &vertical);
      if (tiff_status == 1)
        {
          (void) FormatLocaleString(sampling_factor,MagickPathExtent,
            "%dx%d",horizontal,vertical);
          (void) SetImageProperty(image,"jpeg:sampling-factor",
            sampling_factor,exception);
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            "Sampling Factors: %s",sampling_factor);
        }
    }
#endif
    break;
  }
  case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;
#if defined(COMPRESSION_LZMA)
  case COMPRESSION_LZMA: image->compression=LZMACompression; break;
#endif
  case COMPRESSION_LZW: image->compression=LZWCompression; break;
  case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;
  case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;
#if defined(COMPRESSION_WEBP)
  case COMPRESSION_WEBP: image->compression=WebPCompression; break;
#endif
#if defined(COMPRESSION_ZSTD)
  case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;
#endif
  default: image->compression=RLECompression; break;
}
quantum_info=(QuantumInfo *) NULL;
if ((photometric == PHOTOMETRIC_PALETTE) &&
    (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))
  {
    size_t
      colors;

    colors=(size_t) GetQuantumRange(bits_per_sample)+1;
    if (AcquireImageColormap(image,colors,exception) == MagickFalse)
      {
        TIFFClose(tiff);
        ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
      }
  }
value=(unsigned short) image->scene;
if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)
  image->scene=value;
if (image->storage_class == PseudoClass)
  {
    size_t
      range;

    uint16
      *blue_colormap,
      *green_colormap,
      *red_colormap;

    /*
      Initialize colormap.
    */
    tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,
      &green_colormap,&blue_colormap);
    if (tiff_status == 1)
      {
        if ((red_colormap!= (uint16 *) NULL) &&
            (green_colormap!= (uint16 *) NULL) &&
            (blue_colormap!= (uint16 *) NULL))
          {
            range=255;  /* might be old style 8-bit colormap */
            for (i=0; i < (ssize_t) image->colors; i++)
              if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||
                  (blue_colormap[i] >= 256))
                {
                  range=65535;
                  break;
                }
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=ClampToQuantum(((double)
                QuantumRange*red_colormap[i])/range);
              image->colormap[i].green=ClampToQuantum(((double)
                QuantumRange*green_colormap[i])/range);
              image->colormap[i].blue=ClampToQuantum(((double)
                QuantumRange*blue_colormap[i])/range);
            }
          }
      }
  }
if (image_info->ping!= MagickFalse)
  {
    if (image_info->number_scenes!= 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    goto next_tiff_frame;
  }
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
  {
    TIFFClose(tiff);
    return(DestroyImageList(image));
  }
status=ResetImagePixels(image,exception);
if (status == MagickFalse)
  {
    TIFFClose(tiff);
    return(DestroyImageList(image));
  }
/*
  Allocate memory for the image and pixel buffer.
*/
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
  ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
if (sample_format == SAMPLEFORMAT_UINT)
  status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
if (sample_format == SAMPLEFORMAT_INT)
  status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
if (sample_format == SAMPLEFORMAT_IEEEFP)
  status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
if (status == MagickFalse)
  ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
status=MagickTrue;
switch (photometric)
{
  case PHOTOMETRIC_MINISBLACK:
  {
    quantum_info->min_is_white=MagickFalse;
    break;
  }
  case PHOTOMETRIC_MINISWHITE:
  {
    quantum_info->min_is_white=MagickTrue;
    break;
  }
  default:
    break;
}
tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
  &sample_info);
if (tiff_status == 1)
  {
    (void) SetImageProperty(image,"tiff:alpha","unspecified",exception);
    if (extra_samples == 0)
      {
        if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
          image->alpha_trait=BlendPixelTrait;
      }
    else
      for (i=0; i < extra_samples; i++)
      {
        image->alpha_trait=BlendPixelTrait;
        if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
          {
            SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);
            (void) SetImageProperty(image,"tiff:alpha","associated",exception);
          }
        else
          if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
            {
              SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
              (void) SetImageProperty(image,"tiff:alpha","unassociated",exception);
            }
      }
  }
if (image->alpha_trait!= UndefinedPixelTrait)
  (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
method=ReadGenericMethod;
rows_per_strip=(uint32) image->rows;
if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
  {
    char
      buffer[MagickPathExtent];

    method=ReadStripMethod;
    (void) FormatLocaleString(buffer,MagickPathExtent,"%u",
      (unsigned int) rows_per_strip);
    (void) SetImageProperty(image,"tiff:rows-per-strip",buffer,exception);
  }
if (rows_per_strip > (uint32) image->rows)
  rows_per_strip=(uint32) image->rows;
if ((samples_per_pixel >= 3) && (interlace == PLANARCONFIG_CONTIG))
  if ((image->alpha_trait == UndefinedPixelTrait) ||
      (samples_per_pixel >= 4))
    method=ReadRGBAMethod;
if ((samples_per_pixel >= 4) && (interlace == PLANARCONFIG_SEPARATE))
  if ((image->alpha_trait == UndefinedPixelTrait) ||
      (samples_per_pixel >= 5))
    method=ReadCMYKAMethod;
if ((photometric!= PHOTOMETRIC_RGB) &&
    (photometric!= PHOTOMETRIC_CIELAB) &&
    (photometric!= PHOTOMETRIC_SEPARATED))
  method=ReadGenericMethod;
if (image->storage_class == PseudoClass)
  method=ReadSingleSampleMethod;
if ((photometric == PHOTOMETRIC_MINISBLACK) ||
    (photometric == PHOTOMETRIC_MINISWHITE))
  method=ReadSingleSampleMethod;
if ((photometric!= PHOTOMETRIC_SEPARATED) &&
    (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))
  method=ReadGenericMethod;
if (image->compression == JPEGCompression)
  method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,
    samples_per_pixel);
if (compress_tag == COMPRESSION_JBIG)
  method=ReadStripMethod;
if (TIFFIsTiled(tiff)!= MagickFalse)
  {
    method=ReadRGBATileMethod;
    if (samples_per_pixel == 1)
      method=ReadTileMethod;
  }
quantum_info->endian=LSBEndian;
quantum_type=RGBQuantum;
if (TIFFScanlineSize(tiff) <= 0)
  ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
if (((MagickSizeType) TIFFScanlineSize(tiff)) > (2*GetBlobSize(image)))
  ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)
  image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
  log(2.0))),image->columns*rows_per_strip));
pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
if (pixel_info == (MemoryInfo *) NULL)
  ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
(void) memset(pixels,0,number_pixels*sizeof(uint32));
switch (method)
{
  case ReadSingleSampleMethod:
  {
    /*
      Convert TIFF image to PseudoClass MIFF image.
    */
    quantum_type=IndexQuantum;
    pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
    if (image->alpha_trait!= UndefinedPixelTrait)
      {
        if (image->storage_class!= PseudoClass)
          {
            quantum_type=samples_per_pixel == 1? AlphaQuantum :
              GrayAlphaQuantum;
            pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
          }
        else
          {
            quantum_type=IndexAlphaQuantum;
            pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
          }
      }
    else
      if (image->storage_class!= PseudoClass)
        {
          quantum_type=GrayQuantum;
          pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
        }
    status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(
      bits_per_sample)/log(2))));
    if (status == MagickFalse)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      register Quantum
        *magick_restrict q;

      tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
      if (tiff_status == -1)
        break;
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        quantu