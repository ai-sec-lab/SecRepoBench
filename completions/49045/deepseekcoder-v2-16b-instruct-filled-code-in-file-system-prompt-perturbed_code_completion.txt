+ mrb_as_float(mrb, y));
#endif
  }
}

/* 15.2.8.3.1  */
/*
 * call-seq:
 *   int + numeric  ->  numeric_result
 *
 * Performs addition: the class of the resulting object depends on
 * the class of <code>numeric</code> and on the magnitude of the
 * result.
 */

static mrb_value
int_add(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_add(mrb, x, y);
  }
#endif
  return mrb_int_add(mrb, x, y);
}

mrb_value
mrb_int_sub(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_int a;

  a = mrb_integer(x);
  if (mrb_integer_p(y)) {
    mrb_int b, c;

    if (a == 0) return mrb_int_value(mrb, -mrb_integer(y));
    b = mrb_integer(y);
    if (b == 0) return x;
    if (mrb_int_sub_overflow(a, b, &c)) {
#ifdef MRB_USE_BIGINT
      x = mrb_bint_new_int(mrb, a);
      return mrb_bint_sub(mrb, x, y);
#else
      mrb_int_overflow(mrb, "subtraction");
#endif
    }
    return mrb_int_value(mrb, c);
  }
  switch (mrb_type(y)) {
#ifdef MRB_USE_BIGINT
  case MRB_TT_BIGINT:
    return mrb_bint_sub(mrb, x, y);
#endif
#ifdef MRB_USE_RATIONAL
  case MRB_TT_RATIONAL:
    return mrb_rational_sub(mrb, x, y);
#endif
#ifdef MRB_USE_COMPLEX
  case MRB_TT_COMPLEX:
    return mrb_complex_sub(mrb, x, y);
#endif
  default:
#ifdef MRB_NO_FLOAT
    mrb_raise(mrb, E_TYPE_ERROR, "non integer subtraction");
#else
    return mrb_float_value(mrb, (mrb_float)a - mrb_as_float(mrb, y));
#endif
  }
}

/* 15.2.8.3.2  */
/*
 * call-seq:
 *   int - numeric  ->  numeric_result
 *
 * Performs subtraction: the class of the resulting object depends on
 * the class of <code>numeric</code> and on the magnitude of the
 * result.
 */

static mrb_value
int_sub(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_sub(mrb, x, y);
  }
#endif
  return mrb_int_sub(mrb, x, y);
}

mrb_value
mrb_int_cmp(mrb_state *mrb, mrb_value x, mrb_value y)
{
  mrb_int a, b;

  a = mrb_integer(x);
  if (mrb_integer_p(y)) {
    b = mrb_integer(y);
    if (a < b) return mrb_fixnum_value(-1);
    if (a > b) return mrb_fixnum_value(1);
    return mrb_fixnum_value(0);
  }
#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(y)) {
    return mrb_bint_cmp(mrb, y, x);
  }
#endif
#ifdef MRB_USE_RATIONAL
  if (mrb_rational_p(y)) {
    return mrb_rational_cmp(mrb, y, x);
  }
#endif
#ifdef MRB_USE_COMPLEX
  if (mrb_complex_p(y)) {
    return mrb_complex_cmp(mrb, y, x);
  }
#endif
#ifdef MRB_NO_FLOAT
  mrb_raise(mrb, E_TYPE_ERROR, "non integer comparison");
#else
  return mrb_float_value(mrb, (mrb_float)a - mrb_as_float(mrb, y));
#endif
}

/* 15.2.8.3.3  */
/*
 * call-seq:
 *   int <=> numeric  ->  -1, 0, +1
 *
 * Comparison---Returns -1, 0, or +1 depending on whether <i>int</i> is
 * less than, equal to, or greater than <i>numeric</i>. This is the
 * basis for the tests in <code>Comparable</code>.
 */

static mrb_value
int_cmp(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_cmp(mrb, x, y);
  }
#endif
  return mrb_int_cmp(mrb, x, y);
}

/* 15.2.8.3.4  */
/*
 * call-seq:
 *   int < numeric  ->  true or false
 *   int <= numeric  ->  true or false
 *   int > numeric  ->  true or false
 *   int >= numeric  ->  true or false
 *
 * These relational operators return <code>true</code> if <i>int</i> is
 * less than, less than or equal to, greater than, or greater than or
 * equal to <i>numeric</i>, respectively.
 */

static mrb_value
int_lt(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_lt(mrb, x, y);
  }
#endif
  return mrb_bool_value(mrb_integer(x) < mrb_integer(y));
}

static mrb_value
int_le(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_le(mrb, x, y);
  }
#endif
  return mrb_bool_value(mrb_integer(x) <= mrb_integer(y));
}

static mrb_value
int_gt(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_gt(mrb, x, y);
  }
#endif
  return mrb_bool_value(mrb_integer(x) > mrb_integer(y));
}

static mrb_value
int_ge(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bint_ge(mrb, x, y);
  }
#endif
  return mrb_bool_value(mrb_integer(x) >= mrb_integer(y));
}

/* 15.2.8.3.14 */
/*
 * call-seq:
 *   int.abs  ->  integer
 *
 * Returns the absolute value of <i>int</i>.
 */

static mrb_value
int_abs(mrb_state *mrb, mrb_value num)
{
  mrb_int val = mrb_integer(num);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(num)) {
    return mrb_bint_abs(mrb, num);
  }
#endif
  if (val < 0) {
    return mrb_int_value(mrb, -val);
  }
  return num;
}

/* 15.2.8.3.15 */
/*
 * call-seq:
 *   int.size  ->  integer
 *
 * Returns the number of bytes in the machine representation of
 * <i>int</i>.
 */

static mrb_value
int_size(mrb_state *mrb, mrb_value num)
{
  mrb_int val = mrb_integer(num);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(num)) {
    return mrb_bint_size(mrb, num);
  }
#endif
  return mrb_int_value(mrb, sizeof(mrb_int));
}

/* 15.2.8.3.16 */
/*
 * call-seq:
 *   int.eql?(numeric)  ->  true or false
 *
 * Returns <code>true</code> if <i>int</i> and <i>numeric</i> are the
 * same type and have equal values.
 */

static mrb_value
int_eql(mrb_state *mrb, mrb_value x)
{
  mrb_value y = mrb_get_arg1(mrb);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(x)) {
    return mrb_bool_value(mrb_bint_cmp(mrb, x, y) == 0);
  }
#endif
  if (!mrb_integer_p(y)) return mrb_false_value();
  return mrb_bool_value(mrb_integer(x) == mrb_integer(y));
}

/* 15.2.8.3.17 */
/*
 * call-seq:
 *   int.hash  ->  integer
 *
 * Returns a hash code for this integer.
 */

static mrb_value
int_hash(mrb_state *mrb, mrb_value num)
{
  mrb_int val = mrb_integer(num);

#ifdef MRB_USE_BIGINT
  if (mrb_bigint_p(num)) {
    return mrb_bint_hash(mrb, num);
  }
#endif
  return mrb_int_value(mrb, val);
}

/* 15.2.8.3.18 */
/*
 * call-seq:
 *   int.to_s(base=10)  ->  string
 *
 * Converts <i>int</i> to a string representing the number in <i>base</i>
 * (default is 10).
 *
 * If <i>base</i> is less than 2 or greater than 36, raises <code>ArgumentError</code>.
 */

static mrb_value
int_to_s(mrb_state *mrb, mrb_value num)
{
  mrb_int base = 10;
  mrb_value str;

  mrb_get_args(mrb, "|i", &base);
  if (base < 2 || base > 36) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "invalid radix %d", base);
  }
  str = mrb_str_new_capa(mrb, 0);
  mrb_str_resize(mrb, str, 0);
  mrb