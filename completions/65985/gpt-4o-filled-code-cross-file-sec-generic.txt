if (ctx->bytes_in_header) {
    // Copy the remaining bytes from the packet to the header store
    u32 bytes_to_copy = (remain < (5 - ctx->bytes_in_header)) ? remain : (5 - ctx->bytes_in_header);
    memcpy(ctx->hdr_store + ctx->bytes_in_header, start, bytes_to_copy);
    ctx->bytes_in_header += bytes_to_copy;

    // Check if we have enough bytes to form a start code
    if (ctx->bytes_in_header >= 5) {
        // Check for a valid start code
        if (ctx->hdr_store[0] == 0x00 && ctx->hdr_store[1] == 0x00 && ctx->hdr_store[2] == 0x01) {
            sc_type = ctx->hdr_store[3];
            current = 0;
            sc_type_forced = GF_TRUE;
            forced_sc_type = sc_type;
            hdr_offset = 4;
            bytes_from_store = ctx->bytes_in_header;
        } else {
            // No valid start code, treat as continuation of previous data
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
            if (!dst_pck) return GF_OUT_OF_MEM;

            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
            }

            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        }
        ctx->bytes_in_header = 0;
    }

    // Adjust the start and remain if we copied some bytes
    if (bytes_to_copy < remain) {
        start += bytes_to_copy;
        remain -= bytes_to_copy;
    } else {
        break;
    }
}