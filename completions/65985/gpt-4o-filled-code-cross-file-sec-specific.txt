if (ctx->bytes_in_header) {
			u32 bytes_to_copy = 4 - ctx->bytes_in_header;
			if (remain < (s32)bytes_to_copy) {
				memcpy(ctx->hdr_store + ctx->bytes_in_header, start, remain);
				ctx->bytes_in_header += remain;
				break;
			}
			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, bytes_to_copy);
			start += bytes_to_copy;
			remain -= bytes_to_copy;
			ctx->bytes_in_header = 0;

			if (ctx->hdr_store[0] == 0 && ctx->hdr_store[1] == 0 && ctx->hdr_store[2] == 1) {
				sc_type = ctx->hdr_store[3];
				sc_type_forced = GF_TRUE;
				forced_sc_type = sc_type;
				current = 0;
			} else {
				dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
				if (!dst_pck) return GF_OUT_OF_MEM;

				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
				memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
				gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
				gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
				gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
				}

				mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
				ctx->bytes_in_header = 0;
			}
		}