if (ctx->bytes_in_header) {
	u32 to_copy = 4 - ctx->bytes_in_header;
	if (to_copy>remain) to_copy = remain;

	memcpy(ctx->hdr_store + ctx->bytes_in_header, start, to_copy);
	ctx->bytes_in_header += to_copy;
	//OK, we have 4 bytes, check start code
	if (ctx->bytes_in_header==4) {
		if (!ctx->hdr_store[0] && !ctx->hdr_store[1] && (ctx->hdr_store[2]==1)) {
			current = 0;
			sc_type_forced = GF_TRUE;
			forced_sc_type = ctx->hdr_store[3];
			hdr_offset = 4;
			bytes_from_store = 4;
		}
		//this is not a start code, dispatch and trash until next start code
		else {
			dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
			if (!dst_pck) return GF_OUT_OF_MEM;

			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
			memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
			gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
			gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
			gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
			}

			mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
			ctx->bytes_in_header = 0;
		}
	}
	//not enough bytes to check start code, wait for next packet
	else {
		gf_assert(remain==to_copy);
		break;
	}
	gf_assert(remain>=to_copy);
	start += to_copy;
	remain -= to_copy;
}