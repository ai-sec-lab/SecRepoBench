// Check if we have enough bytes to parse the start code
        if (remain < 5) {
            // Store the remaining bytes in the header store for future processing
            memcpy(ctx->hdr_store, start, remain);
            ctx->bytes_in_header = remain;
            break;
        }

        // Locate the next start code
        current = mpgviddmx_next_start_code(start, remain);
        if (current < 0) {
            // No start code found, dispatch the current block
            if (!ctx->frame_started) {
                GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVid] no start code in block and no frame started, discarding data\n"));
                break;
            }
            size = remain;
            // Check for potential start code at the end of the packet
            if (remain >= 3) {
                u8 b3 = start[remain - 3];
                u8 b2 = start[remain - 2];
                u8 b1 = start[remain - 1];
                if (!b1 || !b2 || !b3) {
                    copy_last_bytes = GF_TRUE;
                    gf_assert(size >= 3);
                    size -= 3;
                    ctx->bytes_in_header = 3;
                }
            }

            // Create a new packet for the data
            dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32)size, &pck_data);
            if (!dst_pck) return GF_OUT_OF_MEM;

            // Merge properties from the source packet if available
            if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
            memcpy(pck_data, start, (size_t)size);
            gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
            gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
            gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

            if (byte_offset != GF_FILTER_NO_BO) {
                gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
            }

            // Enqueue or dispatch the packet
            mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
            if (copy_last_bytes) {
                memcpy(ctx->hdr_store, start + remain - 3, 3);
            }
            break;
        }