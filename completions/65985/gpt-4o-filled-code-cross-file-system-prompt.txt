if (ctx->bytes_in_header) {
    u8 *hdr_data = ctx->hdr_store;
    u32 hdr_size = ctx->bytes_in_header;
    u32 total_size = hdr_size + remain;
    u8 *combined_data = (u8 *)gf_malloc(total_size);
    if (!combined_data) return GF_OUT_OF_MEM;

    memcpy(combined_data, hdr_data, hdr_size);
    memcpy(combined_data + hdr_size, start, remain);

    current = mpgviddmx_next_start_code(combined_data, total_size);
    if (current >= 0) {
        sc_type = combined_data[current + 3];
        sc_type_forced = GF_TRUE;
        forced_sc_type = sc_type;
        hdr_offset = current;
        bytes_from_store = hdr_size;
    } else {
        // No start code found, treat as continuation of previous data
        dst_pck = gf_filter_pck_new_alloc(ctx->opid, hdr_size, &pck_data);
        if (!dst_pck) {
            gf_free(combined_data);
            return GF_OUT_OF_MEM;
        }

        if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
        memcpy(pck_data, hdr_data, hdr_size);
        gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
        gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
        gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

        if (byte_offset != GF_FILTER_NO_BO) {
            gf_filter_pck_set_byte_offset(dst_pck, byte_offset - hdr_size);
        }

        mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
        ctx->bytes_in_header = 0;
    }
    gf_free(combined_data);
}