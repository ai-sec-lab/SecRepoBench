hb_bool_t result = true;
    hb_glyph_info_t *glyph_infos = nullptr;
    hb_glyph_position_t *glyph_positions = nullptr;
    unsigned int num_glyphs = 0;

    // Extract glyphs and positions from the font
    if (!hb_font_collect_glyphs(font, &glyph_infos, &glyph_positions, &num_glyphs)) {
        result = false;
        goto cleanup;
    }

    // Create a subset of glyphs based on the plan
    hb_glyph_set_t *glyph_set = hb_glyph_set_create();
    if (unlikely(!glyph_set)) {
        result = false;
        goto cleanup;
    }

    for (unsigned int i = 0; i < num_glyphs; i++) {
        if (context->plan->glyph_include_func(context->plan, &glyph_infos[i], &glyph_positions[i])) {
            hb_glyph_set_add(glyph_set, &glyph_infos[i], &glyph_positions[i]);
        }
    }

    // Serialize the subset glyphs into the glyf object
    hb_glyf_t *glyf = hb_glyf_create();
    if (unlikely(!glyf)) {
        result = false;
        goto cleanup;
    }

    if (!hb_glyf_serialize(glyf, glyph_set)) {
        result = false;
        goto cleanup;
    }

    // Handle any necessary cleanup
cleanup:
    if (font) {
        hb_font_destroy(font);
    }
    if (glyph_infos) {
        free(glyph_infos);
    }
    if (glyph_positions) {
        free(glyph_positions);
    }
    if (glyph_set) {
        hb_glyph_set_destroy(glyph_set);
    }
    if (glyf) {
        hb_glyf_destroy(glyf);
    }

    return result;