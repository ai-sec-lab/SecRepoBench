hb_subset_glyphs_t *subset_glyphs = hb_subset_glyphs_create ();
if (unlikely (!subset_glyphs))
  return_trace (false);

bool result = true;
unsigned int num_glyphs = 0;
if (font) {
  num_glyphs = hb_subset_plan_get_num_glyphs (context->plan);
  if (unlikely (!hb_subset_plan_create_subset_glyphs (context->plan, font, subset_glyphs)))
    result = false;
  hb_font_destroy (font);
} else {
  num_glyphs = hb_subset_plan_get_num_glyphs (context->plan);
  if (unlikely (!hb_subset_plan_create_subset_glyphs (context->plan, nullptr, subset_glyphs)))
    result = false;
}

if (result) {
  unsigned int *padded_offsets = (unsigned int *) calloc (num_glyphs, sizeof (unsigned int));
  if (unlikely (!padded_offsets)) {
    result = false;
    goto cleanup;
  }

  bool use_short_loca = true;
  for (unsigned int i = 0; i < num_glyphs; i++) {
    unsigned int padded_offset = hb_subset_glyphs_get_padded_offset (subset_glyphs, i);
    padded_offsets[i] = padded_offset;
    if (padded_offset >= 0x10000)
      use_short_loca = false;
  }

  hb_glyphs_t *glyf = hb_glyphs_create ();
  if (unlikely (!glyf)) {
    result = false;
    goto cleanup;
  }

  if (unlikely (!hb_subset_glyphs_serialize (subset_glyphs, glyf, use_short_loca))) {
    result = false;
    goto cleanup;
  }

  hb_glyphs_destroy (glyf);
}

cleanup:
free (padded_offsets);
hb_subset_glyphs_destroy (subset_glyphs);