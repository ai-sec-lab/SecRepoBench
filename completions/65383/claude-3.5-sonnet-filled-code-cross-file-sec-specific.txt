case 'Z': case 'H':
    if (aux_end - aux < 4)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    while (aux < aux_end && *aux) {
        BLOCK_APPEND_CHAR(tm->blk, *aux);
        aux++;
    }
    if (aux >= aux_end)
        goto err;
    BLOCK_APPEND_CHAR(tm->blk, *aux);
    aux++;
    break;

case 'B':
    if (aux_end - aux < 8)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    {
        int type = aux[3], blen;
        int32_t count = le_to_i32((uint8_t *)aux+4);
        if (count < 0 || count > INT_MAX / 16)
            goto err;

        switch (type) {
        case 'c': case 'C':
            blen = count;
            break;
        case 's': case 'S':
            blen = 2*count;
            break;
        case 'i': case 'I': case 'f':
            blen = 4*count;
            break;
        default:
            goto err;
        }

        if (aux_end - aux < 8 + blen)
            goto err;

        // Store the type and count
        BLOCK_APPEND(tm->blk, aux+3, 5);
        // Store the actual array of elements
        BLOCK_APPEND(tm->blk, aux+8, blen);
    }
    aux += 8 + blen;
    break;