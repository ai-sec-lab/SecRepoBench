case 'H':
    // Handles 'H' type (hexadecimal string) by creating a new block if necessary,
    // and encoding the data from the auxiliary fields.
    if (aux_end - aux < 3+1)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    BLOCK_APPEND_CHAR(tm->blk, *aux);
    aux++;
    break;

case 'B':
    // For 'B' type (byte array), computes the length based on the sub-type and count,
    // allocates blocks as needed, and encodes the data.
    // Checks for sufficient data remaining in the auxiliary field buffer before processing.
    // Updates the auxiliary field pointer appropriately after encoding.
    int sub_type = aux[3];
    int count = bam_aux2i_end((uint8_t *)aux+4, (uint8_t *)aux_end);
    int elem_size = 0;
    switch (sub_type) {
    case 'c': case 'C': elem_size = 1; break;
    case 's': case 'S': elem_size = 2; break;
    case 'i': case 'I': case 'f': elem_size = 4; break;
    case 'd': elem_size = 8; break;
    default:
        hts_log_error("Unsupported 'B' sub-type '%c'", sub_type);
        goto err;
    }

    if (aux_end - aux < 3+1+elem_size*count)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=4;
    BLOCK_APPEND(tm->blk, aux, elem_size*count);
    aux += elem_size*count;
    break;

default:
    hts_log_error("Unknown aux type '%c'", aux_end - aux < 2 ? '?' : aux[2]);
    goto err;