case 'H':
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    while (aux < aux_end && *aux) {
        BLOCK_APPEND_CHAR(tm->blk, *aux);
        aux++;
    }
    if (aux >= aux_end)
        goto err;
    aux++;
    break;

case 'B': {
    int type = aux[3], blen;
    uint32_t count = 0;
    int sub_size;

    if (aux_end - aux < 8)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    switch (type) {
    case 'c': case 'C':
    case 's': case 'S':
    case 'i': case 'I':
    case 'f':
        sub_size = aux[3] == 'c' || aux[3] == 'C' ? 1 :
                   aux[3] == 's' || aux[3] == 'S' ? 2 :
                   4;
        break;
    default:
        hts_log_error("Unknown sub-type '%c' for aux type 'B'", type);
        goto err;
    }

    count = le_to_u32((uint8_t *)aux+4);
    if (count * sub_size + 8 > aux_end - aux)
        goto err;
    blen = count * sub_size + 5;

    BLOCK_APPEND(tm->blk, aux+3, blen);
    aux += 8 + count * sub_size;
    break;
}

case 'Z':
    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux += 3;
    while (aux < aux_end && *aux) {
        BLOCK_APPEND_CHAR(tm->blk, *aux);
        aux++;
    }
    if (aux >= aux_end)
        goto err;
    aux++;
    break;