case 'H':
            if (aux_end - aux < 4)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            aux+=3;
            if (*aux > BLOCK_SIZE(tm->blk))
                goto err;

            BLOCK_RESIZE(tm->blk, BLOCK_SIZE(tm->blk) * 2 + *aux);
            hts_expand(char, BLOCK_SIZE(tm->blk) + *aux, tm->blk->alloc,
                       BLOCK_DATA(tm->blk));

            if (sam_hex_to_data((char *)BLOCK_DATA(tm->blk) + BLOCK_SIZE(tm->blk),
                                aux+1, *aux) < 0)
                goto err;
            BLOCK_SIZE(tm->blk) += *aux;
            aux += 1+*aux;
            break;

        case 'B': {
            char type;
            int count;

            if (aux_end - aux < 5)
                goto err;

            if (!tm->blk) {
                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
                    goto err;
                codec->u.e_byte_array_len.val_codec->out = tm->blk;
            }

            type  = aux[3];
            count = bam_auxB_len(aux+4, aux_end);
            if (count < 0)
                goto err;

            aux+=5;
            if (aux_end - aux < count)
                goto err;

            int32_t len = count;
            switch (type) {
            case 'c': case 'C': len *= 1; break;
            case 's': case 'S': len *= 2; break;
            case 'i': case 'I': case 'f': len *= 4; break;
            default:
                hts_log_error("Unhandled type code for B aux type");
                goto err;
            }

            BLOCK_RESIZE(tm->blk, BLOCK_SIZE(tm->blk) + len);
            if (cram_encode_aux_b_data(fd, (char *)BLOCK_DATA(tm->blk) + BLOCK_SIZE(tm->blk),
                                      aux, type, count) < 0)
                goto err;

            BLOCK_SIZE(tm->blk) += len;
            aux += count;
            break;
        }