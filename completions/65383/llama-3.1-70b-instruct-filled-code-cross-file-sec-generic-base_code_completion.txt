case 'H': 
    if (aux_end - aux < 3+1)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    //codec->encode(s, codec, aux, 1);
    // Functionally equivalent, but less code.
    BLOCK_APPEND_CHAR(tm->blk, *aux);
    aux++;
    break;

case 'B': {
    // Byte array of variable size, but we generate our tag
    // byte stream at the wrong stage (during reading and not
    // after slice header construction). So we use
    // BYTE_ARRAY_LEN with the length codec being external
    // too.
    int len = 0;
    switch(aux[2]) {
    case 'c': len = 1; break;
    case 'C': len = 2; break;
    case's': len = 2; break;
    case 'S': len = 4; break;
    case 'i': len = 4; break;
    case 'I': len = 4; break;
    case 'f': len = 4; break;
    default:
        hts_log_error("Unsupported BAM aux type '%c'", aux[2]);
        goto err;
    }

    if (aux_end - aux < 3+len)
        goto err;

    if (!tm->blk) {
        if (!(tm->blk = cram_new_block(EXTERNAL, key)))
            goto err;
        codec->u.e_byte_array_len.val_codec->out = tm->blk;
    }

    aux+=3;
    //codec->encode(s, codec, aux, len);
    BLOCK_APPEND(tm->blk, aux, len);
    aux+=len;
    break;
}