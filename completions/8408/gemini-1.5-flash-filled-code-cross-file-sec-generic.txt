DrawInfo
    **graphic_context;

  Image
    *pattern_image;

  MagickBooleanType
    status;

  PrimitiveInfo
    *primitive_info;

  StopInfo
    *stops;

  ssize_t
    n;

  /*
    Allocate graphic context stack.
  */
  graphic_context=(DrawInfo **) AcquireQuantumMemory(MaxDrawDepth,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
  (void) memset(graphic_context,0,MaxDrawDepth*sizeof(*graphic_context));
  graphic_context[0]=CloneDrawInfo(draw_info);
  if (graphic_context[0] == (DrawInfo *) NULL)
    ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
  n=0;
  status=MagickTrue;
  primitive_info=(PrimitiveInfo *) NULL;
  stops=(StopInfo *) NULL;
  token=AcquireString(draw_info->primitive);
  pattern_image=(Image *) NULL;
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  /*
    Process the drawing commands.
  */
  for (q=token; *q != '\0'; )
  {
    primitive=GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      break;
    if (LocaleCompare("affine",keyword) == 0)
      {
        AffineMatrix
          affine;

        GetNextToken(q,&q,MagickPathExtent,geometry);
        (void) GetAffineMatrix(&affine);
        (void) ParseAffineGeometry(geometry,&affine);
        current=graphic_context[n]->affine;
        (void) AffineMatrixMultiply(&affine,&current,&graphic_context[n]->affine);
        continue;
      }
    if (LocaleCompare("push",keyword) == 0)
      {
        n++;
        if (n >= MaxDrawDepth)
          ThrowBinaryException(DrawError,"GraphicContextStackOverflow",
            keyword);
        graphic_context[n]=CloneDrawInfo(graphic_context[n-1]);
        if (graphic_context[n] == (DrawInfo *) NULL)
          ThrowFatalException(ResourceLimitError,"MemoryAllocationFailed");
        continue;
      }
    if (LocaleCompare("pop",keyword) == 0)
      {
        if (n <= 0)
          ThrowBinaryException(DrawError,"GraphicContextStackUnderflow",
            keyword);
        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
        n--;
        continue;
      }
    if (LocaleCompare("pattern",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,pattern);
        pattern_image=GetImageFromPattern(graphic_context[n],pattern,
          exception);
        if (pattern_image == (Image *) NULL)
          {
            status=MagickFalse;
            break;
          }
        continue;
      }
    if (LocaleCompare("gradient",keyword) == 0)
      {
        GetNextToken(q,&q,MagickPathExtent,pattern);
        stops=GetStopInfo(graphic_context[n],pattern,exception);
        if (stops == (StopInfo *) NULL)
          {
            status=MagickFalse;
            break;
          }
        continue;
      }
    primitive_info=ParsePrimitive(graphic_context[n],primitive,
      pattern_image,stops,exception);
    if (primitive_info == (PrimitiveInfo *) NULL)
      {
        status=MagickFalse;
        break;
      }
    status=DrawPrimitive(image,graphic_context[n],primitive_info,exception);
    if (status == MagickFalse)
      break;
    primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
    if (pattern_image != (Image *) NULL)
      pattern_image=DestroyImage(pattern_image);
    if (stops != (StopInfo *) NULL)
      stops=(StopInfo *) RelinquishMagickMemory(stops);
  }