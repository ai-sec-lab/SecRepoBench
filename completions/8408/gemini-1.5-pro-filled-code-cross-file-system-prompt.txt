DrawInfo
    **graphic_context;

  MagickBooleanType
    status;

  ssize_t
    n;

  PrimitiveInfo
    *primitive_info;

  register ssize_t
    i;

  size_t
    length;

  StopInfo
    *stops;

  /*
    Set the drawing defaults.
  */
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  primitive_info=(PrimitiveInfo *) NULL;
  stops=(StopInfo *) NULL;
  status=MagickTrue;
  graphic_context=(DrawInfo **) AcquireQuantumMemory(1,sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
      image->filename);
  n=0;
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (graphic_context[n] == (DrawInfo *) NULL)
    {
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  primitive=AcquireString(draw_info->primitive);
  if (primitive == (char *) NULL)
    {
      for ( ; n >= 0; n--)
        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  (void) SetImageArtifact(image,RenderImageTag,primitive);
  token=AcquireString(primitive);
  if (token == (char *) NULL)
    {
      for ( ; n >= 0; n--)
        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      primitive=DestroyString(primitive);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),primitive);
  GetAffineMatrix(&current);
  length=strlen(token);
  stops=ParseStops(token,&token);
  if (stops != (StopInfo *) NULL)
    {
      /*
        Push graphic-context onto stack.
      */
      n++;
      graphic_context=(DrawInfo **) ResizeQuantumMemory(graphic_context,(size_t)
        (n+1),sizeof(*graphic_context));
      if (graphic_context == (DrawInfo **) NULL)
        {
          primitive=DestroyString(primitive);
          token=DestroyString(token);
          stops=(StopInfo *) RelinquishMagickMemory(stops);
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            image->filename);
        }
      graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n-1]);
      if (graphic_context[n] == (DrawInfo *) NULL)
        {
          primitive=DestroyString(primitive);
          token=DestroyString(token);
          stops=(StopInfo *) RelinquishMagickMemory(stops);
          for ( ; n >= 0; n--)
            graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
          graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            image->filename);
        }
      graphic_context[n]->fill_pattern=AcquireImage(image_info,exception);
      if (graphic_context[n]->fill_pattern == (Image *) NULL)
        {
          primitive=DestroyString(primitive);
          token=DestroyString(token);
          stops=(StopInfo *) RelinquishMagickMemory(stops);
          for ( ; n >= 0; n--)
            graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
          graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
          ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
            image->filename);
        }
      (void) SetImageExtent(graphic_context[n]->fill_pattern,
        graphic_context[0]->gradient.radii.x,graphic_context[0]->gradient.radii.y,
        exception);
      status=SetImageBackgroundColor(graphic_context[n]->fill_pattern,
        exception);
    }
  for (q=token; *q != '\0'; )
  {
    /*
      Interpret drawing command.
    */
    GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      break;
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(DrawEvent,GetMagickModule(),"%s",keyword);
    if (LocaleNCompare(keyword,"push",4) == 0)
      {
        /*
          Push graphic-context onto stack.
        */
        n++;
        graphic_context=(DrawInfo **) ResizeQuantumMemory(graphic_context,
          (size_t) (n+1),sizeof(*graphic_context));
        if (graphic_context == (DrawInfo **) NULL)
          {
            primitive=DestroyString(primitive);
            token=DestroyString(token);
            if (stops != (StopInfo *) NULL)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
            if (primitive_info != (PrimitiveInfo *) NULL)
              primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(
                primitive_info);
            ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
              image->filename);
          }
        graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
          graphic_context[n-1]);
        if (graphic_context[n] == (DrawInfo *) NULL)
          {
            primitive=DestroyString(primitive);
            token=DestroyString(token);
            if (stops != (StopInfo *) NULL)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
            for ( ; n >= 0; n--)
              graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
            graphic_context=(DrawInfo **) RelinquishMagickMemory(
              graphic_context);
            ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
              image->filename);
          }
        GetNextToken(q,&q,MagickPathExtent,keyword);
        if (*keyword != '{')
          continue;
        for ( ; *q != '\0'; )
        {
          GetNextToken(q,&q,MagickPathExtent,keyword);
          if (*keyword == '}')
            break;
          status&=SetDrawInfoOption(graphic_context[n],keyword,q);
        }
        continue;
      }
    if (LocaleNCompare(keyword,"pop",3) == 0)
      {
        /*
          Pop graphic-context from stack.
        */
        if (n <= 0)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
              "UnbalancedGraphicContextPushPop","`%s'",image->filename);
            status=MagickFalse;
            break;
          }
        graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
        n--;
        continue;
      }
    primitive_info=ParsePrimitive(image_info,graphic_context[n],keyword,q,
      &status);
    if (primitive_info == (PrimitiveInfo *) NULL)
      break;
    for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
    {
      switch (primitive_info[i].primitive)
      {
        case PointPrimitive:
        {
          (void) DrawPointPrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case LinePrimitive:
        {
          status=DrawLinePrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case RectanglePrimitive:
        {
          status=DrawRectanglePrimitive(image,graphic_context[n],
            &primitive_info[i],exception);
          break;
        }
        case RoundRectanglePrimitive:
        {
          status=DrawRoundRectanglePrimitive(image,graphic_context[n],
            &primitive_info[i],exception);
          break;
        }
        case ArcPrimitive:
        {
          status=DrawArcPrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case EllipsePrimitive:
        {
          status=DrawEllipsePrimitive(image,graphic_context[n],
            &primitive_info[i],exception);
          break;
        }
        case CirclePrimitive:
        {
          status=DrawCirclePrimitive(image,graphic_context[n],
            &primitive_info[i],exception);
          break;
        }
        case PolylinePrimitive:
        {
          status=DrawPolylinePrimitive(image,graphic_context[n],
            &primitive_info[i],exception);
          break;
        }
        case PolygonPrimitive:
        {
          status=DrawPolygonPrimitive(image,graphic_context[n],
            &primitive_info[i],exception);
          break;
        }
        case BezierPrimitive:
        {
          status=DrawBezierPrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case PathPrimitive:
        {
          status=DrawPathPrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case AlphaPrimitive:
        {
          (void) SetImageAlphaChannel(image,primitive_info[i].alpha,exception);
          break;
        }
        case ColorPrimitive:
        {
          status=DrawColorPrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case MattePrimitive:
        {
          status=DrawMattePrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case TextPrimitive:
        {
          status=DrawTextPrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        case ImagePrimitive:
        {
          status=DrawImagePrimitive(image,graphic_context[n],&primitive_info[i],
            exception);
          break;
        }
        default:
          break;
      }
      if (status == MagickFalse)
        break;
      primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
      primitive_info=(PrimitiveInfo *) NULL;
    }
    if (status == MagickFalse)
      break;
  }