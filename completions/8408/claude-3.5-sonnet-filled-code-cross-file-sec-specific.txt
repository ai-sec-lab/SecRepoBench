// Main drawing loop
for (q=(const char *) value; *q != '\0'; )
{
  /*
    Interpret drawing primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,keyword);
  if (*keyword == '\0')
    break;
  primitive_type=UndefinedPrimitive;
  switch (*keyword)
  {
    // ... (existing switch cases)
  }
  if (primitive_type == UndefinedPrimitive)
    continue;
  /*
    Parse the primitive attributes.
  */
  i=0;
  j=0;
  for (x=0; *q != '\0'; x++)
  {
    /*
      Define points.
    */
    if (IsPoint(q) == MagickFalse)
      break;
    GetNextToken(q,&q,extent,token);
    point.x=StringToDouble(token,&next_token);
    GetNextToken(q,&q,extent,token);
    if (*token == ',')
      GetNextToken(q,&q,extent,token);
    point.y=StringToDouble(token,&next_token);
    GetNextToken(q,(const char **) NULL,extent,token);
    if (*token == ',')
      GetNextToken(q,&q,extent,token);
    primitive_info[i].primitive=primitive_type;
    primitive_info[i].point=point;
    primitive_info[i].coordinates=0;
    primitive_info[i].method=FloodfillMethod;
    i++;
    if (i < (ssize_t) (number_points-6*BezierQuantum-360))
      continue;
    number_points+=6*BezierQuantum+360;
    PrimitiveInfo *new_primitive_info = ResizeQuantumMemory(primitive_info,
      number_points,sizeof(*primitive_info));
    if (new_primitive_info == (PrimitiveInfo *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),
        ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
      break;
    }
    primitive_info = new_primitive_info;
  }
  primitive_info[j].primitive=primitive_type;
  primitive_info[j].coordinates=x;
  primitive_info[j].method=FloodfillMethod;
  primitive_info[j].text=(char *) NULL;
  if (active)
  {
    AffineToTransform(image,&affine);
    active=MagickFalse;
  }
  active=MagickFalse;
  switch (primitive_type)
  {
    // ... (existing switch cases)
  }
  if (primitive_info == (PrimitiveInfo *) NULL)
    break;
  primitive_info[i].primitive=UndefinedPrimitive;
  if (status == MagickFalse)
    break;
}