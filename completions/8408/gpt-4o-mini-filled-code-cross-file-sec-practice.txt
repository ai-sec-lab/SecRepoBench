// Initialize variables
  status = MagickTrue;
  n = 0;
  primitive_info = (PrimitiveInfo *) AcquireQuantumMemory(2047, sizeof(*primitive_info));
  if (primitive_info == (PrimitiveInfo *) NULL)
    ThrowWriterException(ResourceLimitError, "MemoryAllocationFailed");

  // Parse drawing commands
  for (q = draw_info->commands; *q != '\0'; )
  {
    // Get the next token
    GetNextToken(q, &q, MagickPathExtent, keyword);
    if (*keyword == '\0')
      break;

    // Handle different drawing commands
    if (LocaleCompare("draw", keyword) == 0)
    {
      // Handle draw command
      GetNextToken(q, &q, MagickPathExtent, token);
      // Validate token
      if (IsValidDrawCommand(token) == MagickFalse)
      {
        status = MagickFalse;
        break;
      }
      // Process the draw command
      ProcessDrawCommand(image, token, primitive_info, &n, exception);
    }
    else if (LocaleCompare("transform", keyword) == 0)
    {
      // Handle transformation commands
      GetNextToken(q, &q, MagickPathExtent, token);
      // Validate transformation token
      if (IsValidTransformCommand(token) == MagickFalse)
      {
        status = MagickFalse;
        break;
      }
      // Apply transformation
      ApplyTransformation(image, token, &affine);
    }
    else
    {
      // Handle other commands
      status = HandleOtherCommands(keyword, q, &n, primitive_info, exception);
      if (status == MagickFalse)
        break;
    }
  }

  // Finalize drawing
  if (status == MagickTrue)
  {
    // Write the final image state
    WriteFinalImageState(image, primitive_info, n, exception);
  }
  else
  {
    // Log error and clean up
    (void) LogMagickEvent(DrawEvent, GetMagickModule(), "Error processing drawing commands");
  }