DrawInfo
    **graphic_context;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  PrimitiveInfo
    *primitive_info;

  register ssize_t
    i;

  size_t
    length;

  StopInfo
    *stops;

  /*
    Set the image clip mask.
  */
  (void) SetImageClipMask(image,draw_info->clip_mask,exception);
  /*
    Allocate primitive info memory.
  */
  primitive_info=(PrimitiveInfo *) NULL;
  if (draw_info->primitive != (const char *) NULL)
    {
      length=strlen(draw_info->primitive)+MagickPathExtent;
      primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(length,
        sizeof(*primitive_info));
      if (primitive_info == (PrimitiveInfo *) NULL)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),
            ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
          return(MagickFalse);
        }
      (void) memset(primitive_info,0,length*sizeof(*primitive_info));
    }
  stops=(StopInfo *) NULL;
  /*
    Initialize graphic context.
  */
  graphic_context=(DrawInfo **) AcquireQuantumMemory(MaxDrawInfoDepth,
    sizeof(*graphic_context));
  if (graphic_context == (DrawInfo **) NULL)
    {
      if (primitive_info != (PrimitiveInfo *) NULL)
        primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  (void) memset(graphic_context,0,MaxDrawInfoDepth*sizeof(*graphic_context));
  n=0;
  graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (graphic_context[n] == (DrawInfo *) NULL)
    {
      if (primitive_info != (PrimitiveInfo *) NULL)
        primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
      graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
      ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
        image->filename);
    }
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
  token=AcquireString(draw_info->primitive);
  q=draw_info->primitive;
  status=MagickTrue;
  offset=0;
  while ((*q != '\0') && (status != MagickFalse))
  {
    /*
      Interpret graphic primitive.
    */
    GetNextToken(q,&q,MagickPathExtent,keyword);
    if (*keyword == '\0')
      break;
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(DrawEvent,GetMagickModule(),keyword);

    // Check for stack overflow
    if (n + 1 >= MaxDrawInfoDepth) {
      (void) ThrowMagickException(exception, GetMagickModule(), ResourceLimitError,
                         "MemoryAllocationFailed", "`%s'", image->filename);
      status = MagickFalse;
      break;
    }

    primitive=AcquireString(keyword);
    switch (*keyword)
    {
      case 'p':
      case 'P':
      {
        if (LocaleCompare("push",keyword) == 0)
          {
            GetNextToken(q,&q,MagickPathExtent,keyword);
            if (*keyword != '\0')
              {
                graphic_context[++n]=CloneDrawInfo((ImageInfo *) NULL,
                  graphic_context[n-1]);
                if (graphic_context[n] == (DrawInfo *) NULL)
                  status=MagickFalse;
              }
            (void) SubstituteString(&token,"\n"," ");
            (void) SubstituteString(&token,"  "," ");
            break;
          }
        if (LocaleCompare("pop",keyword) == 0)
          {
            if (n > 0)
              graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
            n--;
            break;
          }
          status=DrawPrimitive(image,graphic_context[n],primitive_info,
           exception);
        break;
      }
      default:
      {
        status=DrawPrimitive(image,graphic_context[n],primitive_info,
          exception);
        break;
      }
    }
    primitive=DestroyString(primitive);
    if (primitive_info != (PrimitiveInfo *) NULL)
      {
        for (i=0; i < (ssize_t) primitive_info[0].coordinates; i++)
          primitive_info[i].primitive=UndefinedPrimitive;
        primitive_info[0].coordinates=0;
      }
  }