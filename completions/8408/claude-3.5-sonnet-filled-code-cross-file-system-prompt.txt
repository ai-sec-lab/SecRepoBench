MagickBooleanType status;
DrawInfo
  *draw_info;
ExceptionInfo
  *exception;
Image
  *clone_image;
register ssize_t
  i;
size_t
  number_stops;
StopInfo
  *stops;

if (image->debug != MagickFalse)
  (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
assert(draw_info != (DrawInfo *) NULL);
assert(draw_info->signature == MagickCoreSignature);
if (draw_info->primitive == (char *) NULL)
  return(MagickFalse);
if (*draw_info->primitive == '\0')
  return(MagickTrue);
/*
  Allocate primitive info memory.
*/
number_points=2047;
primitive_info=(PrimitiveInfo *) AcquireQuantumMemory(number_points,
  sizeof(*primitive_info));
if (primitive_info == (PrimitiveInfo *) NULL)
  ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
    image->filename);
exception=AcquireExceptionInfo();
draw_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
draw_info->render=MagickFalse;
graphic_context=(DrawInfo **) AcquireQuantumMemory(number_points,
  sizeof(*graphic_context));
if (graphic_context == (DrawInfo **) NULL)
  ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
    image->filename);
number_stops=0;
stops=(StopInfo *) NULL;
status=MagickTrue;
n=0;
primitive_type=UndefinedPrimitive;
for (q=draw_info->primitive; *q != '\0'; )
{
  /*
    Interpret graphic primitive.
  */
  GetNextToken(q,&q,MagickPathExtent,keyword);
  if (*keyword == '\0')
    break;
  if (*keyword == '#')
    {
      /*
        Comment.
      */
      while ((*q != '\n') && (*q != '\0'))
        q++;
      continue;
    }
  switch (*keyword)
  {
    case ';':
      break;
    case 'a':
    case 'A':
    {
      if (LocaleCompare("affine",keyword) == 0)
        {
          GetAffineMatrix(&affine);
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'b':
    case 'B':
    {
      if (LocaleCompare("bezier",keyword) == 0)
        {
          primitive_type=BezierPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'c':
    case 'C':
    {
      if (LocaleCompare("clip-path",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          (void) CloneString(&draw_info->clip_mask,token);
          break;
        }
      if (LocaleCompare("clip-rule",keyword) == 0)
        {
          ssize_t
            fill_rule;

          GetNextToken(q,&q,MagickPathExtent,token);
          fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,token);
          if (fill_rule == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->fill_rule=(FillRule) fill_rule;
          break;
        }
      if (LocaleCompare("clip-units",keyword) == 0)
        {
          ssize_t
            units;

          GetNextToken(q,&q,MagickPathExtent,token);
          units=ParseCommandOption(MagickClipPathOptions,MagickFalse,token);
          if (units == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->clip_units=(ClipPathUnits) units;
          break;
        }
      if (LocaleCompare("circle",keyword) == 0)
        {
          primitive_type=CirclePrimitive;
          break;
        }
      if (LocaleCompare("color",keyword) == 0)
        {
          primitive_type=ColorPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'd':
    case 'D':
    {
      if (LocaleCompare("decorate",keyword) == 0)
        {
          ssize_t
            decorate;

          GetNextToken(q,&q,MagickPathExtent,token);
          decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,token);
          if (decorate == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->decorate=(DecorationType) decorate;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'e':
    case 'E':
    {
      if (LocaleCompare("ellipse",keyword) == 0)
        {
          primitive_type=EllipsePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'f':
    case 'F':
    {
      if (LocaleCompare("fill",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          (void) QueryColorCompliance(token,AllCompliance,
            &draw_info->fill,exception);
          break;
        }
      if (LocaleCompare("fill-opacity",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          draw_info->fill_opacity=StringToDouble(token,(char **) NULL);
          break;
        }
      if (LocaleCompare("fill-rule",keyword) == 0)
        {
          ssize_t
            fill_rule;

          GetNextToken(q,&q,MagickPathExtent,token);
          fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,token);
          if (fill_rule == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->fill_rule=(FillRule) fill_rule;
          break;
        }
      if (LocaleCompare("font",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          (void) CloneString(&draw_info->font,token);
          break;
        }
      if (LocaleCompare("font-family",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          (void) CloneString(&draw_info->family,token);
          break;
        }
      if (LocaleCompare("font-size",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          draw_info->pointsize=StringToDouble(token,(char **) NULL);
          break;
        }
      if (LocaleCompare("font-stretch",keyword) == 0)
        {
          ssize_t
            stretch;

          GetNextToken(q,&q,MagickPathExtent,token);
          stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);
          if (stretch == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->stretch=(StretchType) stretch;
          break;
        }
      if (LocaleCompare("font-style",keyword) == 0)
        {
          ssize_t
            style;

          GetNextToken(q,&q,MagickPathExtent,token);
          style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);
          if (style == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->style=(StyleType) style;
          break;
        }
      if (LocaleCompare("font-weight",keyword) == 0)
        {
          ssize_t
            weight;

          GetNextToken(q,&q,MagickPathExtent,token);
          weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);
          if (weight == -1)
            weight=(ssize_t) StringToUnsignedLong(token);
          draw_info->weight=(size_t) weight;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'g':
    case 'G':
    {
      if (LocaleCompare("gradient-units",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          break;
        }
      if (LocaleCompare("gravity",keyword) == 0)
        {
          ssize_t
            gravity;

          GetNextToken(q,&q,MagickPathExtent,token);
          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);
          if (gravity == -1)
            {
              status=MagickFalse;
              break;
            }
          draw_info->gravity=(GravityType) gravity;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'i':
    case 'I':
    {
      if (LocaleCompare("image",keyword) == 0)
        {
          primitive_type=ImagePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'l':
    case 'L':
    {
      if (LocaleCompare("line",keyword) == 0)
        {
          primitive_type=LinePrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'm':
    case 'M':
    {
      if (LocaleCompare("matte",keyword) == 0)
        {
          primitive_type=AlphaPrimitive;
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'o':
    case 'O':
    {
      if (LocaleCompare("offset",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          break;
        }
      if (LocaleCompare("opacity",keyword) == 0)
        {
          GetNextToken(q,&q,MagickPathExtent,token);
          draw_info->opacity=StringToLong(token);
          break;
        }
      status=MagickFalse;
      break;
    }
    case 'p':
    case 'P':
    {
      if (LocaleCompare("path",keyword) == 0)
        {
          primitive_type=PathPrimitive;
          break;
        }
      if (LocaleCompare("point",keyword) == 0)
        {
          primitive_type=PointPrimitive;
          break;
        }
      if (LocaleCompare("polyline",keyword) == 0)
        {
          primitive_type=PolylinePrimitive;
          break;
        }
      if (LocaleCompare("polygon",keyword) == 0)
        {
          primitive_type=Polygon