const uint8_t* sig = (const uint8_t*) codeview_header;
    size_t header_size = 0;

    // Recognize CodeView signatures.
    if (sig[0] == 'R' && sig[1] == 'S' && sig[2] == 'D' && sig[3] == 'S')
    {
      // PDB 7.0 (CV_INFO_PDB70)
      header_size = 4      /* "RSDS"  */
                  + 16     /* GUID    */
                  + 4;     /* Age     */
    }
    else if (sig[0] == 'N' && sig[1] == 'B' && sig[2] == '1' && sig[3] == '0')
    {
      // PDB 2.0 (CV_INFO_PDB20 / NB10)
      header_size = 4      /* "NB10"          */
                  + 4      /* Offset          */
                  + 4      /* TimeDateStamp   */
                  + 4;     /* Age             */
    }
    else
    {
      // Unknown/unsupported CodeView format.
      continue;
    }

    // Verify that the fixed part of the header fits inside the PE.
    if ((size_t) pcv_hdr_offset + header_size >= pe->data_size)
      continue;

    // Pointer to the zero-terminated PDB file path.
    char* raw_path = (char*) codeview_header + header_size;

    // Remaining space in the PE for the path.
    size_t remaining = pe->data_size - (size_t) (pcv_hdr_offset + header_size);

    // Detect the length of the PDB path ensuring it is NUL-terminated.
    pdb_path_len = strnlen(raw_path, remaining);

    if (pdb_path_len == 0 || pdb_path_len == remaining)
      continue;  // Invalid or not NUL-terminated.

    // Duplicate the path and store it in the moduleâ€™s object.
    pdb_path = yr_strndup(raw_path, pdb_path_len);

    if (pdb_path == NULL)
      continue;

    set_string(pdb_path, pe->object, "pdb_path");
    yr_free(pdb_path);

    // Successfully extracted a PDB path, no need to keep processing.
    return;