if (srclen == 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "source length cannot be zero");
  }

  // Read the first byte to determine if more bytes follow
  unsigned char byte = *src++;
  srclen--;
  
  // Check if the first byte is valid
  if (byte & 0x80) {
    n = byte & 0x7F; // Extract the 7 bits
  } else {
    n = byte; // If the 8th bit is clear, this is the final value
    return 1; // Return immediately as we have the value
  }

  // Continue reading bytes until the 8th bit is clear
  while (srclen > 0) {
    byte = *src++;
    srclen--;
    
    n = (n << 7) | (byte & 0x7F); // Shift left and add the next 7 bits

    // Check for overflow
    if (n < 0) {
      mrb_raise(mrb, E_RANGE_ERROR, "integer overflow");
    }

    if (!(byte & 0x80)) {
      break; // If the 8th bit is clear, we are done
    }
  }

  // If we exit the loop but still have bytes left, it means we have an incomplete integer
  if (srclen == 0 && (byte & 0x80)) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "incomplete integer encoding");
  }

  return 1; // Return the number of bytes read