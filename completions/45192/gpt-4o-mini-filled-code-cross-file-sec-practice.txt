if (srclen == 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "source length cannot be zero");
    return 0; // This return is just to satisfy the compiler, it won't be reached.
  }

  // Validate that the source length does not exceed the maximum allowed size
  if (srclen > MAX_BER_LENGTH) {
    mrb_raise(mrb, E_RANGE_ERROR, "source length exceeds maximum allowed size");
    return 0; // This return is just to satisfy the compiler, it won't be reached.
  }

  n = 0;
  for (i = 0; i < srclen; i++) {
    unsigned char byte = src[i];
    n = (n << 7) | (byte & 0x7F); // Shift left and add the 7 bits

    // Check if the 8th bit is clear, indicating the end of the integer
    if ((byte & 0x80) == 0) {
      break;
    }

    // Check for overflow
    if (n < 0) {
      mrb_raise(mrb, E_RANGE_ERROR, "integer overflow");
      return 0; // This return is just to satisfy the compiler, it won't be reached.
    }
  }

  // If we exit the loop without breaking, it means we didn't find a terminating byte
  if (i == srclen) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "incomplete BER integer");
    return 0; // This return is just to satisfy the compiler, it won't be reached.
  }

  return i; // Return the number of bytes processed