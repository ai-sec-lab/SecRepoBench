// <MASK>
if (phantom_only) {
  // If phantom_only is true, directly set the end points of each contour in the points array
  for (size_t i = 0; i < num_contours; ++i) {
    contour_points.push_back(contour_point_t(endPtsOfContours[i].x, endPtsOfContours[i].y));
  }
} else {
  // If phantom_only is false, read the actual points and set them in the points array
  const HBUINT8 *p = &StructAtOffset<HBUINT8> (&endPtsOfContours[num_contours + 1],
                                               endPtsOfContours[num_contours]);

  if (unlikely ((const char *) p < bytes.arrayZ)) return false; /* Unlikely overflow */
  const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);
  if (unlikely (p >= end)) return false;

  /* Read x & y coordinates */
  return read_flags (p, contour_points, end)
      && read_points (p, contour_points, end, &contour_point_t::x,
                      FLAG_X_SHORT, FLAG_X_SAME)
      && read_points (p, contour_points, end, &contour_point_t::y,
                      FLAG_Y_SHORT, FLAG_Y_SAME);
}