/* Reset any existing data. */
    contour_points.reset ();

    /* If caller is interested only in phantom points, we can short-circuit here. */
    if (phantom_only)
    {
      /* There are always four phantom points in a TrueType glyph. */
      const unsigned PHANTOM_COUNT = 4;
      if (unlikely (!contour_points.resize (PHANTOM_COUNT)))
        return false;

      for (unsigned i = 0; i < PHANTOM_COUNT; ++i)
      {
        contour_points.arrayZ[i].x = 0.f;
        contour_points.arrayZ[i].y = 0.f;
        contour_points.arrayZ[i].flag = 0;
      }
      return true;
    }

    /* A glyph that has no contours has nothing more for us to do. */
    if (num_contours == 0)
      return true;

    /* Make sure end-point indices are strictly increasing and extract
     * the total number of points (last end-point index + 1). */
    uint16_t last_index = endPtsOfContours[0];
    for (unsigned c = 1; c < (unsigned) num_contours; ++c)
    {
      if (unlikely (endPtsOfContours[c] <= last_index))
        return false;
      last_index = endPtsOfContours[c];
    }
    unsigned num_points = (unsigned) last_index + 1;

    /* Reserve space for real points plus four phantom points.  We only resize
     * the vector to the number of real points for now so that flag and coord
     * readers operate on the correct range while still having spare capacity
     * for the phantom points later on. */
    const unsigned PHANTOM_COUNT = 4;
    if (unlikely (!contour_points.alloc (num_points + PHANTOM_COUNT) ||
                  !contour_points.resize (num_points)))
      return false;

    /* Initialise the points array. */
    for (unsigned i = 0; i < num_points; ++i)
    {
      contour_points.arrayZ[i].x = 0.f;
      contour_points.arrayZ[i].y = 0.f;
      contour_points.arrayZ[i].flag = 0;
    }

    /* Mark the end-point of each contour.  We use a private flag value that is
     * outside the range of the on-disk TrueType flags so that it survives the
     * later parsing of those flags. */
    const unsigned END_POINT_FLAG = 0x100u;
    for (unsigned c = 0; c < (unsigned) num_contours; ++c)
    {
      unsigned idx = endPtsOfContours[c];
      if (unlikely (idx >= num_points))
        return false;
      contour_points.arrayZ[idx].flag |= END_POINT_FLAG;
    }