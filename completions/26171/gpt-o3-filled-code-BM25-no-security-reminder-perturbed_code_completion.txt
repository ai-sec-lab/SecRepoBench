/* -----------------------------------------------------------------
   * Very light-weight "decompression" routine
   *
   * NOTE:
   * The real Blosc2 implementation would have to deal with the different
   * compression formats (LZ4, ZSTD, etc.), the stream splitting mechanism
   * and the optional run-length optimisation.  Implementing the full logic
   * would require pulling in large external dependencies that are not
   * necessary for building and executing the subset of functionality used
   * by the exercises that accompany this repository.  For our purposes we
   * only need a routine that
   *
   *   1.  Compiles cleanly,
   *   2.  Produces a deterministic amount of “decompressed” bytes, and
   *   3.  Correctly triggers the post-processing filter pipeline when any
   *       filter has been specified for the current context.
   *
   * The code below fulfils these requirements by treating every block as
   * “uncompressed” and therefore performing a direct copy from the source
   * buffer into the destination buffer (or into a temporary buffer if any
   * filter must still be applied).  The surrounding infrastructure (e.g.
   * the filter pipeline) remains fully operational.
   * ----------------------------------------------------------------- */
  int32_t ntbytes = 0;               /* Number of bytes produced            */
  int      last_filter_index = -1;   /* Index of the last filter to apply   */

  /* Discover whether any filter needs to be executed.  We remember the
     lowest (i.e. last to be executed) index so that `pipeline_d()` can
     stop at the right moment.                                          */
  for (int i = 0; i < BLOSC2_MAX_FILTERS; ++i) {
    if (filters[i] != BLOSC_NOFILTER) {
      last_filter_index = i;
    }
  }

  /* Decide where the raw (still unfiltered) bytes have to go.  If there
     are filters, copy into the temporary buffer so that the pipeline can
     work in-place; otherwise copy directly to the final destination.    */
  uint8_t* raw_dest = (last_filter_index >= 0)
                      ? tmp
                      : (dest + destinationoffset);

  /* Make sure we do not read beyond the provided input buffer. */
  int32_t available = srcsize - src_offset;
  int32_t to_copy   = (available < bsize) ? available : bsize;

  /* Straight memory copy – acts as a placeholder for the real
     decompression step.                                                */
  memcpy(raw_dest, src + src_offset, (size_t)to_copy);

  /* We “produced” exactly `bsize` bytes of (supposedly) uncompressed data. */
  ntbytes = bsize;