for (i = 0; i < TagCount; i++) {

        /* Read tag signature, offset and size */
        if (io->Read(io, &TagEntry, sizeof(cmsTagEntry), 1) != 1)
            return FALSE;

        /* Convert endianess */
        TagEntry.Tag    = (cmsTagSignature) _cmsAdjustEndianess32(TagEntry.Tag);
        TagEntry.Offset = _cmsAdjustEndianess32(TagEntry.Offset);
        TagEntry.Size   = _cmsAdjustEndianess32(TagEntry.Size);

        /* Skip empty tags */
        if (TagEntry.Size == 0) {
            Icc->TagLinked[i] = (cmsTagSignature) 0;
            continue;
        }

        /* Basic bounds checking */
        if (TagEntry.Offset + TagEntry.Size > HeaderSize) {
            cmsSignalError(Icc->ContextID, cmsERROR_END_OF_FILE, "icc: tag too long");
            return FALSE;
        }

        /* Store information in the profile structure */
        Icc->TagNames[i]   = TagEntry.Tag;
        Icc->TagOffsets[i] = TagEntry.Offset;
        Icc->TagSizes[i]   = TagEntry.Size;
        Icc->TagLinked[i]  = (cmsTagSignature) 0;

        /* Detect links to previously read tags (same offset & size) */
        for (j = 0; j < i; j++) {
            if (Icc->TagOffsets[j] == TagEntry.Offset &&
                Icc->TagSizes[j]   == TagEntry.Size) {

                Icc->TagLinked[i] = Icc->TagNames[j];
                break;
            }
        }

        /* Increase valid tag counter */
        Icc->TagCount++;
    }

    /* Resolve any links so the offsets/sizes are consistent */
    if (!SetLinks(Icc))
        return FALSE;

    return TRUE;