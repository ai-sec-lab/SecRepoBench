/*
    Confirm the draw info structure is valid.
  */
  assert(draw_info != (const DrawInfo *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-dash");
  /*
    Determine the number of vertices in the supplied primitive.
  */
  for (number_vertices=0;
       primitive_info[number_vertices].primitive != UndefinedPrimitive;
       number_vertices++) ;
  /*
    Allocate enough room for the dashed representation (each original
    segment can contribute at most two vertices plus a terminator).
  */
  dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
    (2UL*number_vertices+1UL),sizeof(*dash_polygon));
  if (dash_polygon == (PrimitiveInfo *) NULL)
    return(MagickFalse);
  /*
    Work with a clone of the draw info so we are free to modify attributes
    for the individual dash segments.
  */
  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
  if (clone_info == (DrawInfo *) NULL)
    {
      dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
      return(MagickFalse);
    }
  clone_info->miterlimit=0.0;
  /*
    Seed the dash polygon with the first point from the original primitive.
  */
  dash_polygon[0]=primitive_info[0];
  /*
    Compute the scale factor that maps dash lengths through the current
    affine transformation and initialise the dash offset.
  */
  scale=ExpandAffine(&draw_info->affine);
  dash_offset=fabs(draw_info->dash_offset);