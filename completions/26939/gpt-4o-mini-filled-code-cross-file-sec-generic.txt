size_t length = GetStringInfoLength(profile);
  const unsigned char *data = GetStringInfoDatum(profile);
  
  // Handle XMP profiles
  if (strcmp(name, "XMP") == 0)
  {
    const char *end_marker = "<?xpacket end=\"w\"?>";
    size_t end_marker_length = strlen(end_marker);
    size_t i;

    // Search for the end marker
    for (i = 0; i < length; i++)
    {
      if (i + end_marker_length <= length && 
          memcmp(data + i, end_marker, end_marker_length) == 0)
      {
        // Truncate the profile at the end marker
        SetStringInfoLength(profile, i + end_marker_length);
        break;
      }
    }
  }
  // Handle EXIF profiles
  else if (strcmp(name, "EXIF") == 0)
  {
    // Check for the Exif prefix
    if (length < 4 || memcmp(data, "Exif", 4) != 0)
    {
      // Prepend the correct Exif header
      const char exif_header[] = "Exif\0\0\0\0"; // Example header
      size_t new_length = length + sizeof(exif_header) - 1;
      unsigned char *new_data = (unsigned char *) AcquireQuantumMemory(new_length, sizeof(unsigned char));
      
      if (new_data == (unsigned char *) NULL)
      {
        ThrowMagickException(exception, GetMagickModule(), ResourceLimitError, "MemoryAllocationFailed", "`%s'", name);
        return;
      }

      // Copy the new header and the existing data
      memcpy(new_data, exif_header, sizeof(exif_header) - 1);
      memcpy(new_data + sizeof(exif_header) - 1, data, length);
      
      // Update the profile with the new data
      SetStringInfoDatum(profile, new_data);
      SetStringInfoLength(profile, new_length);
      // Free the old data if necessary
      if (data != NULL)
        RelinquishMagickMemory((void *) data);
    }
  }