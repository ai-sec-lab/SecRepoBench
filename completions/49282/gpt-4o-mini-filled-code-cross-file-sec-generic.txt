if (mpz_is_zero(y)) {
    i = 0; // If y is zero, set i to 0
  } else {
    // Check the size of the multi-precision integer
    if (y->sz > 2 || (y->sz == 2 && (y->p[1] > 1))) {
      return FALSE; // Conversion not possible if more than 2 digits or second digit > 1
    }

    // Compute the integer value based on the sign and magnitude of y
    i = y->p[0]; // Assuming y->p[0] holds the least significant limb
    if (y->sn < 0) {
      i = -i; // Apply sign if negative
    }
    
    // Check if the computed integer is within the allowable range
    if (i < MRB_INT_MIN || i > MRB_INT_MAX) {
      return FALSE; // Out of range
    }
  }