if (mpz_is_zero(y)) {
    i = 0; // If y is zero, set i to 0
  } else {
    // Check the size of the multi-precision integer
    if (y->sz > 2 || (y->sz == 2 && y->p[1] > 1)) {
      return FALSE; // Conversion not possible if more than 2 digits or second digit > 1
    }

    // Compute the integer value based on the sign and magnitude of y
    i = 0;
    for (size_t j = 0; j < y->sz; j++) {
      i += y->p[j] << (j * DIGITBITS); // Accumulate the value
    }

    // Check if the computed value is within the allowable range
    if (i < MRB_INT_MIN || i > MRB_INT_MAX) {
      return FALSE; // Out of range
    }
  }