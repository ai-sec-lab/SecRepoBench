switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
    {
        double offset = 0.0;
        double repeat = 1.0;
        double oscillate = 1.0;

        // Calculate the offset, repeat, and oscillate values based on the envelope type
        switch ((*it).type) {
            case LWO::EnvelopeType_Position_X:
            case LWO::EnvelopeType_Position_Y:
            case LWO::EnvelopeType_Position_Z:
                offset = 0.0;
                repeat = 1.0;
                oscillate = 1.0;
                break;
            case LWO::EnvelopeType_Rotation_Heading:
            case LWO::EnvelopeType_Rotation_Pitch:
            case LWO::EnvelopeType_Rotation_Bank:
                offset = 0.0;
                repeat = 360.0;
                oscillate = 1.0;
                break;
            case LWO::EnvelopeType_Scaling_X:
            case LWO::EnvelopeType_Scaling_Y:
            case LWO::EnvelopeType_Scaling_Z:
                offset = 1.0;
                repeat = 1.0;
                oscillate = 1.0;
                break;
            default:
                // silence compiler warning
                break;
        }

        // Calculate the time delta between the first and last keys
        double timeDelta = my_last - my_first;

        // Calculate the number of repeats
        int numRepeats = (int)(timeDelta / repeat);

        // Calculate the remaining time after the last repeat
        double remainingTime = timeDelta - (numRepeats * repeat);

        // Insert additional keyframes for the pre-behavior
        for (int i = 0; i < numRepeats; i++) {
            double time = my_first + (i * repeat);
            float value = (*it).keys.front().value;

            // Calculate the value based on the pre-behavior type
            switch ((*it).pre) {
                case LWO::PrePostBehaviour_OffsetRepeat:
                    value += (offset * i);
                    break;
                case LWO::PrePostBehaviour_Repeat:
                    value = (*it).keys.front().value;
                    break;
                case LWO::PrePostBehaviour_Oscillate:
                    value = (*it).keys.front().value + (oscillate * sin(i * 3.14159));
                    break;
                default:
                    // silence compiler warning
                    break;
            }

            // Insert the new keyframe
            LWO::Key newKey;
            newKey.time = time;
            newKey.value = value;
            (*it).keys.insert((*it).keys.begin(), newKey);
        }

        // Insert an additional keyframe for the remaining time
        if (remainingTime > 0.0) {
            double time = my_last - remainingTime;
            float value = (*it).keys.front().value;

            // Calculate the value based on the pre-behavior type
            switch ((*it).pre) {
                case LWO::PrePostBehaviour_OffsetRepeat:
                    value += (offset * numRepeats);
                    break;
                case LWO::PrePostBehaviour_Repeat:
                    value = (*it).keys.front().value;
                    break;
                case LWO::PrePostBehaviour_Oscillate:
                    value = (*it).keys.front().value + (oscillate * sin(numRepeats * 3.14159));
                    break;
                default:
                    // silence compiler warning
                    break;
            }

            // Insert the new keyframe
            LWO::Key newKey;
            newKey.time = time;
            newKey.value = value;
            (*it).keys.insert((*it).keys.begin(), newKey);
        }
    }
    break;
    default:
        // silence compiler warning
        break;
}