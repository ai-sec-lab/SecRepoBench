// process pre behavior
        switch ((*it).pre) {

        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat:
        case LWO::PrePostBehaviour_Oscillate:
            {
                const size_t old_size = (*it).keys.size();
                (*it).old_first = 0;
                (*it).old_last = static_cast<size_t>(old_size - 1);


                const double val_delta = (*it).keys.back().value - (*it).keys.front().value;

                if (delta > 0.0) {
                    double cur_time = my_first;
                    size_t ofs = 0;

                    while (cur_time > first) {
                        LWO::Key key = (*it).keys[ofs % old_size];

                        key.time = cur_time -= delta;
                        switch ((*it).pre) {
                        case LWO::PrePostBehaviour_OffsetRepeat:
                            key.value -= val_delta * (ofs / old_size);
                            break;
                        case LWO::PrePostBehaviour_Repeat:
                            // nothing to do
                            break;
                        case LWO::PrePostBehaviour_Oscillate:
                            if ((ofs / old_size) % 2) {
                                key.value -= 2.f * val_delta;
                            }
                            break;
                        default:
                            break;
                        }

                        (*it).keys.insert((*it).keys.begin(), key);
                        ++ofs;
                    }
                    (*it).old_first = ofs;

                    cur_time = my_last;
                    ofs = 0;
                    while (cur_time < last) {
                        LWO::Key key = (*it).keys[(*it).old_last + (ofs % old_size) - (old_size - 1)];
                        key.time = cur_time += delta;

                        switch ((*it).pre) {
                        case LWO::PrePostBehaviour_OffsetRepeat:
                            key.value += val_delta * (ofs / old_size);
                            break;
                        case LWO::PrePostBehaviour_Repeat:
                            // nothing to do
                            break;
                        case LWO::PrePostBehaviour_Oscillate:
                            if ((ofs / old_size) % 2) {
                                key.value += 2.f * val_delta;
                            }
                            break;
                        default:
                            break;
                        }

                        (*it).keys.push_back(key);
                        ++ofs;
                    }
                    (*it).old_last += ofs;
                }
            }
            break;

        default:
            // silence compiler warning
            break;
        }