// process pre behavior
        switch ((*it).pre) {

        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat:
        case LWO::PrePostBehaviour_Oscillate:
            {
                const size_t old_size = (*it).keys.size();
                double time;
                float value;

                // calculate the time delta between keys
                if (old_size > 1) {
                    double time_delta = (*it).keys[1].time - (*it).keys[0].time;
                    if (time_delta < 0.0) time_delta = -time_delta;

                    if (time_delta > 0.0) {
                        // insert additional keyframes to simulate pre behavior
                        time = my_first;
                        size_t n = (size_t)(std::abs(first - my_first) / time_delta) + 1;

                        value = (*it).keys.front().value;
                        if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                            const float value_delta = (*it).keys[1].value - (*it).keys[0].value;
                            for (size_t m = 0; m < n; ++m) {
                                LWO::Key key = (*it).keys.front();
                                key.time = time - (n - m) * time_delta;
                                key.value = value - (n - m) * value_delta;
                                (*it).keys.insert((*it).keys.begin(), key);
                            }
                        } else if ((*it).pre == LWO::PrePostBehaviour_Repeat) {
                            for (size_t m = 0; m < n; ++m) {
                                LWO::Key key = (*it).keys.front();
                                key.time = time - (n - m) * time_delta;
                                (*it).keys.insert((*it).keys.begin(), key);
                            }
                        } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                            bool reverse = false;
                            for (size_t m = 0; m < n; ++m) {
                                LWO::Key key = (*it).keys.front();
                                key.time = time - (n - m) * time_delta;
                                if (reverse) key.value = (*it).keys[1].value;
                                (*it).keys.insert((*it).keys.begin(), key);
                                reverse = !reverse;
                            }
                        }
                    }
                }
                (*it).old_first = (*it).keys.size() - old_size;
            }
            break;

        default:
            (*it).old_first = 0;
            // silence compiler warning
            break;
        }