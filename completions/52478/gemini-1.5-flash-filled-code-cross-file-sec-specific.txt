switch ((*it).pre) {

        case LWO::PrePostBehaviour_OffsetRepeat:
        case LWO::PrePostBehaviour_Repeat:
        case LWO::PrePostBehaviour_Oscillate: {
            // insert keys
            const double first_key = (*it).keys.front().time;
            const double last_key = (*it).keys.back().time;
            const double delta_val = (*it).keys.back().value - (*it).keys.front().value;

            std::vector<LWO::Key> keys;
            keys.reserve((*it).keys.size() + 2);
            keys.push_back(LWO::Key());
            keys.insert(keys.end(), (*it).keys.begin(), (*it).keys.end());
            keys.push_back(LWO::Key());

            // pre-behavior
            double t = first_key;
            switch ((*it).pre) {
            case LWO::PrePostBehaviour_OffsetRepeat:
                t -= delta;
                keys[0].time = t;
                keys[0].value = (*it).keys.front().value - delta_val;
                break;
            case LWO::PrePostBehaviour_Repeat:
                t -= delta;
                keys[0].time = t;
                keys[0].value = (*it).keys.front().value;
                break;
            case LWO::PrePostBehaviour_Oscillate:
                t -= delta;
                keys[0].time = t;
                keys[0].value = (*it).keys.front().value - 2.0 * delta_val;
                break;
            default:
                break;
            }

            // post-behavior
            t = last_key;
            switch ((*it).post) {
            case LWO::PrePostBehaviour_OffsetRepeat:
                t += delta;
                keys.back().time = t;
                keys.back().value = (*it).keys.back().value + delta_val;
                break;
            case LWO::PrePostBehaviour_Repeat:
                t += delta;
                keys.back().time = t;
                keys.back().value = (*it).keys.back().value;
                break;
            case LWO::PrePostBehaviour_Oscillate:
                t += delta;
                keys.back().time = t;
                keys.back().value = (*it).keys.back().value + 2.0 * delta_val;
                break;
            default:
                break;
            }
            (*it).keys = keys;
        }
            break;

        default:
            // silence compiler warning
            break;
        }
        }