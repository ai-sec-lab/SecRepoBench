// process pre behavior
switch ((*it).pre) {
    case LWO::PrePostBehaviour_OffsetRepeat:
    case LWO::PrePostBehaviour_Repeat:
    case LWO::PrePostBehaviour_Oscillate:
        {
            double time_offset = my_first - first;
            if (time_offset > 0.0) {
                size_t num_repeats = static_cast<size_t>(time_offset / delta);
                std::vector<LWO::Key> new_keys;
                new_keys.reserve((*it).keys.size() * (num_repeats + 1));

                for (size_t i = 0; i <= num_repeats; ++i) {
                    for (const auto& key : (*it).keys) {
                        LWO::Key new_key = key;
                        new_key.time -= delta * i;

                        if ((*it).pre == LWO::PrePostBehaviour_OffsetRepeat) {
                            new_key.value += ((*it).keys.back().value - (*it).keys.front().value) * i;
                        } else if ((*it).pre == LWO::PrePostBehaviour_Oscillate && i % 2 == 1) {
                            new_key.time = 2 * my_first - new_key.time - delta;
                        }

                        if (new_key.time >= first) {
                            new_keys.push_back(new_key);
                        }
                    }

                    if ((*it).pre == LWO::PrePostBehaviour_Oscillate) {
                        std::reverse(new_keys.end() - (*it).keys.size(), new_keys.end());
                    }
                }

                (*it).keys = std::move(new_keys);
            }
        }
        break;

    default:
        // No action needed for other pre-behaviors
        break;
}