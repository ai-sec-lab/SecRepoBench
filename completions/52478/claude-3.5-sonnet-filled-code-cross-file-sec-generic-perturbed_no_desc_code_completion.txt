if (firsttime < first) {
    (*it).old_first = (*it).keys.size();
    (*it).keys.insert((*it).keys.begin(), LWO::Key());
    (*it).keys.front().time = first;
    (*it).keys.front().value = (*it).keys[1].value;
}

if (my_last > last) {
    (*it).old_last = (*it).keys.size() - 1;
    (*it).keys.push_back(LWO::Key());
    (*it).keys.back().time = last;
    (*it).keys.back().value = (*it).keys[(*it).old_last].value;
}

// process pre behavior
switch ((*it).pre) {
case LWO::PrePostBehaviour_OffsetRepeat:
case LWO::PrePostBehaviour_Repeat:
case LWO::PrePostBehaviour_Oscillate:
    if (firsttime > first) {
        (*it).old_first = 0;
        (*it).keys.insert((*it).keys.begin(), LWO::Key());
        (*it).keys.front().time = first;
        (*it).keys.front().value = (*it).keys[1].value;
    }
    break;

default:
    // silence compiler warning
    break;
}