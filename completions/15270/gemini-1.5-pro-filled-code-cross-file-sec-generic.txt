if (avctx->codec_type == AVMEDIA_TYPE_SUBTITLE) {
            if (avctx->subtitle_header) {
                int free_sub_header = 1;
                if (avctx->codec->decode) {
                    // do not free the header if it is reused
                    free_sub_header = 0;
                }
                if (free_sub_header) {
                    av_freep(&avctx->subtitle_header);
                    avctx->subtitle_header_size = 0;
                }
            }

            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {
                if (avctx->sub_charenc_mode != FF_SUB_CHARENC_MODE_DO_NOTHING) {
                    av_log(avctx, AV_LOG_WARNING,
                           "Codec '%s' is bitmap-based, ignoring character encoding setting.\n",
                           avctx->codec_descriptor->name);
                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;
                }
            } else if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC) {
                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;
            }

            if (avctx->sub_charenc && avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {
#if CONFIG_ICONV
                if (avctx->sub_charenc != NULL &&
                    !strcmp(avctx->sub_charenc, "UCS-2")) {
                    // only allow UCS-2 to be decoded as UCS-2LE or UCS-2BE
                    iconv_t cd = iconv_open("UTF-8", avctx->sub_charenc);
                    if (cd == (iconv_t)-1) {
                        av_log(avctx, AV_LOG_ERROR, "Unable to open iconv context, "
                               "subtitles will not be correctly decoded\n");
                    }
                    iconv_close(cd);
                }
#else
                av_log(avctx, AV_LOG_WARNING, "Character encoding subtitles requested but iconv is not available, "
                       "subtitles will not be correctly decoded\n");
#endif
            }
        }