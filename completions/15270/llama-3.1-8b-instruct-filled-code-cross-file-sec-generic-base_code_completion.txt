if (av_codec_is_decoder(avctx->codec)) {
    if (avctx->codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
        av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);
    }

    if (avctx->codec->type == AVMEDIA_TYPE_SUBTITLE) {
        if (avctx->codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
            if (avctx->codec->priv_data_size == sizeof(AVSubtitle)) {
                AVSubtitle *subtitle = (AVSubtitle *)avctx->priv_data;
                if (subtitle->start_display_time) {
                    av_log(avctx, AV_LOG_ERROR, "start_display_time must be 0.\n");
                    ret = AVERROR(EINVAL);
                    goto free_and_end;
                }
            }
        }
    }

    if (avctx->channel_layout) {
        int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
        if (!avctx->channels)
            avctx->channels = channels;
        else if (channels!= avctx->channels) {
            char buf[512];
            av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
            av_log(avctx, AV_LOG_WARNING,
                   "Channel layout '%s' with %d channels does not match specified number of channels %d: "
                   "ignoring specified channel layout\n",
                   buf, channels, avctx->channels);
            avctx->channel_layout = 0;
        }
    }
    if (avctx->channels && avctx->channels < 0 ||
        avctx->channels > FF_SANE_NB_CHANNELS) {
        ret = AVERROR(EINVAL);
        goto free_and_end;
    }
    // Check if subtitle character encoding is set and handle accordingly.
    // Ensure that character encoding is only used with subtitle codecs.
    // If the codec is bitmap-based, character encoding is ignored with a warning.
    // For text-based subtitle codecs, set the character encoding mode to pre-decoder
    // if it is in automatic mode and validate the input encoding using iconv if available.
    if (avctx->codec->type == AVMEDIA_TYPE_SUBTITLE) {
        if (avctx->codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
            if (avctx->codec->priv_data_size == sizeof(AVSubtitle)) {
                AVSubtitle *subtitle = (AVSubtitle *)avctx->priv_data;
                if (subtitle->charset == AV_CHARENCODING_AUTO) {
                    if (avctx->codec->priv_class->get_codec_default_charset) {
                        subtitle->charset = avctx->codec->priv_class->get_codec_default_charset(avctx->codec);
                    } else {
                        av_log(avctx, AV_LOG_WARNING, "Charset not set for subtitle codec.\n");
                    }
                }
                if (subtitle->charset!= AV_CHARENCODING_AUTO) {
                    if (avctx->codec->priv_class->validate_charset) {
                        if (avctx->codec->priv_class->validate_charset(avctx->codec, subtitle->charset) < 0) {
                            av_log(avctx, AV_LOG_ERROR, "Invalid charset for subtitle codec.\n");
                            ret = AVERROR(EINVAL);
                            goto free_and_end;
                        }
                    }
                }
            }
        }
    }
}