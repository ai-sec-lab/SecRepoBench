const char *p   = char_buffer;
  const char *pend = p + len;
  const char *s, *e;
  char *buf;
  char *n;
  char *end;
  double d;

  /* 1. skip leading white spaces */
  while (p < pend && ISSPACE(*p)) p++;
  s = p;

  /* 2. optional sign  */
  if (p < pend && (*p == '+' || *p == '-')) p++;

  /* hexadecimal prefix? */
  if ((p + 1) < pend && p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
    /* hexadecimal literals are treated as integers */
    if (badcheck) {
      goto bad;
    }
    return (double)mrb_str_len_to_inum(mrb, s, (size_t)(pend - s), 0, FALSE);
  }

  /* 3. trim trailing white spaces */
  for (e = pend; e > s && ISSPACE(*(e-1)); e--)
    ;

  /* 4. prepare buffer to copy characters (skip underscores) */
  buf = (char*)mrb_alloca(mrb, (size_t)(e - s) + 1);
  n   = buf;

  while (s < e) {
    if (*s == '_') {
      /* underscore must be between digits if badcheck is requested */
      if (badcheck) {
        const char *prev = s - 1;
        const char *next = s + 1;
        if (!(prev >= char_buffer && ISDIGIT(*prev)) ||
            !(next < e && ISDIGIT(*next))) {
          goto bad;
        }
      }
      s++;
      continue;
    }
    *n++ = *s++;
  }