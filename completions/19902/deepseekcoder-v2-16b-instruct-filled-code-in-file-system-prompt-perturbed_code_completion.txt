capitalize    #=> "Hello"
 *     "123ABC".capitalize   #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_replace(mrb, s, mrb_str_capitalize_bang(mrb, str));
  return mrb_obj_value(s);
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.downcase!   => str or nil
 *
 *  Converts <i>str</i> to lowercase, returning <code>nil</code> if no changes
 *  are made.
 *
 *     a = "HELLO"
 *     a.downcase!   #=> "hello"
 *     a             #=> "hello"
 *     a.downcase!   #=> nil
 */
static mrb_value
mrb_str_downcase_bang(mrb_state *mrb, mrb_value str)
{
  char *p, *pend;
  mrb_bool modify = FALSE;
  struct RString *s = mrb_str_ptr(str);

  mrb_str_modify_keep_ascii(mrb, s);
  if (RSTR_LEN(s) == 0 || !RSTR_PTR(s)) return mrb_nil_value();
  p = RSTR_PTR(s); pend = RSTR_PTR(s) + RSTR_LEN(s);
  while (p < pend) {
    if (ISUPPER(*p)) {
      *p = TOLOWER(*p);
      modify = TRUE;
    }
    p++;
  }
  if (modify) return str;
  return mrb_nil_value();
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.downcase   => new_str
 *
 *  Returns a copy of <i>str</i> with all uppercase letters replaced with their
 *  lowercase counterparts. The operation is locale insensitive.
 *
 *     "HELLO".downcase   #=> "hello"
 */
static mrb_value
mrb_str_downcase(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_replace(mrb, s, mrb_str_downcase_bang(mrb, str));
  return mrb_obj_value(s);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.upcase!   => str or nil
 *
 *  Converts <i>str</i> to uppercase, returning <code>nil</code> if no changes
 *  are made.
 *
 *     a = "hello"
 *     a.upcase!   #=> "HELLO"
 *     a           #=> "HELLO"
 *     a.upcase!   #=> nil
 */
static mrb_value
mrb_str_upcase_bang(mrb_state *mrb, mrb_value str)
{
  char *p, *pend;
  mrb_bool modify = FALSE;
  struct RString *s = mrb_str_ptr(str);

  mrb_str_modify_keep_ascii(mrb, s);
  if (RSTR_LEN(s) == 0 || !RSTR_PTR(s)) return mrb_nil_value();
  p = RSTR_PTR(s); pend = RSTR_PTR(s) + RSTR_LEN(s);
  while (p < pend) {
    if (ISLOWER(*p)) {
      *p = TOUPPER(*p);
      modify = TRUE;
    }
    p++;
  }
  if (modify) return str;
  return mrb_nil_value();
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.upcase   => new_str
 *
 *  Returns a copy of <i>str</i> with all lowercase letters replaced with their
 *  uppercase counterparts. The operation is locale insensitive.
 *
 *     "hello".upcase   #=> "HELLO"
 */
static mrb_value
mrb_str_upcase(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_replace(mrb, s, mrb_str_upcase_bang(mrb, str));
  return mrb_obj_value(s);
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.swapcase!   => str or nil
 *
 *  Converts uppercase to lowercase and lowercase to uppercase of <i>str</i>,
 *  returns <code>nil</code> if no changes are made.
 *
 *     a = "Hello"
 *     a.swapcase!   #=> "hELLO"
 *     a             #=> "hELLO"
 *     a.swapcase!   #=> nil
 */
static mrb_value
mrb_str_swapcase_bang(mrb_state *mrb, mrb_value str)
{
  char *p, *pend;
  mrb_bool modify = FALSE;
  struct RString *s = mrb_str_ptr(str);

  mrb_str_modify_keep_ascii(mrb, s);
  if (RSTR_LEN(s) == 0 || !RSTR_PTR(s)) return mrb_nil_value();
  p = RSTR_PTR(s); pend = RSTR_PTR(s) + RSTR_LEN(s);
  while (p < pend) {
    if (ISLOWER(*p)) {
      *p = TOUPPER(*p);
    }
    else if (ISUPPER(*p)) {
      *p = TOLOWER(*p);
    }
    p++;
  }
  if (modify) return str;
  return mrb_nil_value();
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.swapcase   => new_str
 *
 *  Returns a new string with all the lowercase ASCII letters converted to
 *  uppercase and all the uppercase ASCII letters converted to lowercase. This
 *  includes the letters from <code>a</code> to <code>z</code> and from
 *  <code>A</code> to <code>Z</code>.
 *
 *     "Hello".swapcase   #=> "hELLO"
 */
static mrb_value
mrb_str_swapcase(mrb_state *mrb, mrb_value str)
{
  struct RString *s = str_new(mrb, 0, 0);

  str_with_class(s, str);
  mrb_str_replace(mrb, s, mrb_str_swapcase_bang(mrb, str));
  return mrb_obj_value(s);
}

/* 15.2.10.5.15 */
/*
 *  call-seq:
 *     str.each_char { |c| block }   => str
 *
 *  Passes each character in <i>str</i> to the given block, returning <i>str</i>.
 *
 *     "hello".each_char { |c| print c, ' ' }
 *
 *  produces:
 *
 *     h e l l o
 */
static mrb_value
mrb_str_each_char(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  while (p < pend) {
    mrb_value c = mrb_str_new_cstr(mrb, p);
    mrb_ary_push(mrb, ary, c);
    p += utf8len(p, pend);
  }
  return mrb_each_with_index(mrb, ary, str, mrb_str_each_char_i);
}

static mrb_value
mrb_str_each_char_i(mrb_state *mrb, mrb_value ary, mrb_value str)
{
  mrb_value idx = mrb_ary_index(mrb, ary);
  mrb_value c = mrb_ary_entry(mrb, ary, idx);

  mrb_yield(mrb, str, c);
  return str;
}

/* 15.2.10.5.16 */
/*
 *  call-seq:
 *     str.each_byte { |byte| block }   => str
 *
 *  Passes each byte in the string to the given block.
 *
 *     "hello".each_byte { |c| print c, ' ' }
 *
 *  produces:
 *
 *     104 101 108 108 111
 */
static mrb_value
mrb_str_each_byte(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  while (p < pend) {
    mrb_value c = mrb_fixnum_value((unsigned char)*p);
    mrb_ary_push(mrb, ary, c);
    p++;
  }
  return mrb_each_with_index(mrb, ary, str, mrb_str_each_byte_i);
}

static mrb_value
mrb_str_each_byte_i(mrb_state *mrb, mrb_value ary, mrb_value str)
{
  mrb_value idx = mrb_ary_index(mrb, ary);
  mrb_value c = mrb_ary_entry(mrb, ary, idx);

  mrb_yield(mrb, str, c);
  return str;
}

/* 15.2.10.5.17 */
/*
 *  call-seq:
 *     str.each_line(separator=$/) { |substr| block }   => str
 *
 *  Splits <i>str</i> into substrings separated by <i>separator</i> and passes
 *  them to the block, returning <i>str</i>. If no block is given, an enumerator
 *  is returned instead.
 *
 *  The optional <i>separator</i> defaults to <code>$/</code>.
 *
 *     "hello\nworld".each_line { |s| p [s, s.length] }
 *
 *  produces:
 *
 *     ["hello\n", 6]
 *     ["world", 5]
 */
static mrb_value
mrb_str_each_line(mrb_state *mrb, mrb_value str)
{
  mrb_value ary = mrb_ary_new(mrb);
  const char *p, *pend;
  mrb_value sep = mrb_default_rs(mrb);

  p = RSTRING_PTR(str); pend = RSTRING_END(str);
  while (p < pend) {
    mrb_value substr;
    const char *start = p;
    const char *end = p;
    mrb_int sep_len = RSTRING_LEN(sep);

    if (sep_len == 0) {
      end = pend;
    }
    else {
      end = strstr(p, RSTRING_PTR(sep));
      if (!end) end = pend;
    }
    substr = mrb_str_new(mrb, start, end - start);
    mrb_ary_push(mrb, ary, substr);
    p = end;
    if (sep_len == 0) break;
    p += sep_len;
  }
  return mrb_each_