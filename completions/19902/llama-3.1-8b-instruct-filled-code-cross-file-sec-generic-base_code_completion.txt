// <MASK>
  // 1. Trim leading whitespace from the input string.
  while (p < end && ISSPACE(*p)) p++;
  if (p == end) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
    return d;
  }

  // 2. Check for and handle hexadecimal prefixes "0x" or "0X".
  if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
    p += 2;
    if (p == end) {
      if (badcheck) {
        mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
        /* not reached */
      }
      return d;
    }
  }

  // 3. Prepare a buffer to store cleaned input by removing underscores between digits.
  char *buf = p;
  char *pend = n;
  char *nbuf = buf;
  while (p < end) {
    if (*p == '_') {
      p++;
      if (p == end) break;
    } else {
      *nbuf++ = *p++;
    }
  }
  *nbuf = '\0';

  // 4. Iterate over the string, copying valid characters to the buffer.
  p = buf;
  pend = n;
  while (p < pend) {
    if (ISSPACE(*p)) {
      *pend++ = '\0';
      break;
    }
    *pend++ = *p++;
  }
  *pend = '\0';

  // 5. Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  if (pend == n) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
    return d;
  }
  if (badcheck) {
    while (pend > buf && ISSPACE(*pend)) pend--;
    if (pend < buf) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
  }

  // 6. Convert the cleaned string in the buffer to a double using a library function.
  d = mrb_float_read(buf, &pend);

  // 7. Return the parsed double value.
  return d;