// Step 1: Trim leading whitespace
  while (len > 0 && isspace((unsigned char)*s)) {
    s++;
    len--;
  }

  // Step 2: Check for hexadecimal prefixes
  if (len >= 2 && (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))) {
    s += 2; // Skip "0x" or "0X"
    len -= 2;
    // Handle hexadecimal conversion if needed
  }

  // Step 3: Prepare a buffer for cleaned input
  char buf[256]; // Ensure the buffer is large enough
  char *p = buf;
  const char *end = s + len;
  
  // Step 4: Iterate over the string and copy valid characters
  while (s < end && (isdigit((unsigned char)*s) || *s == '.' || *s == '-' || *s == '+')) {
    if (p < buf + sizeof(buf) - 1) { // Prevent buffer overflow
      *p++ = *s;
    }
    s++;
  }
  
  // Step 5: Null-terminate the buffer
  *p = '\0';

  // Step 6: Convert the cleaned string to a double
  char *endptr;
  double d = strtod(buf, &endptr);

  // Step 7: Error handling
  if (endptr == buf) {
    if (badcheck) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
    return 0.0; // Return 0.0 if conversion fails and badcheck is false
  }

  // Step 8: Additional bad check if required
  if (badcheck) {
    while (endptr < pend && ISSPACE(*endptr)) endptr++;
    if (endptr < pend) {
      mrb_raisef(mrb, E_ARGUMENT_ERROR, "invalid string for float(%!s)", s);
      /* not reached */
    }
  }

  return d; // Return the parsed double value