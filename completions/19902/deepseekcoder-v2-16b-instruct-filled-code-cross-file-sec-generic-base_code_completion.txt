char buf[1024];
  char *p, *pend, *n;
  size_t buflen = sizeof(buf);

  // Step 1: Trim leading whitespace from the input string.
  while (len > 0 && isspace((unsigned char)*s)) {
    s++;
    len--;
  }

  // Step 2: Check for and handle hexadecimal prefixes "0x" or "0X".
  if (len >= 2 && ((s[0] == '0' && (s[1] == 'x' || s[1] == 'X')))) {
    s += 2;
    len -= 2;
  }

  // Step 3: Prepare a buffer to store cleaned input by removing underscores between digits.
  p = buf;
  pend = buf + buflen - 1;
  n = pend;

  // Step 4: Iterate over the string, copying valid characters to the buffer.
  while (len > 0 && p < pend) {
    if (*s == '_') {
      s++;
      len--;
      continue;
    }
    *p++ = *s++;
    len--;
  }

  // Step 5: Handle null byte termination, and check for formatting errors when 'badcheck' is true.
  if (p == pend && *s != '\0') {
    goto nocopy;
  }
  *p = '\0';

  // Step 6: Convert the cleaned string in the buffer to a double using a library function.
  d = mrb_float_read(buf, &end);
  if (buf == end) {
    if (badcheck) {
      goto bad;
    }
    return d;
  }

  // Step 7: Return the parsed double value.
  if (badcheck) {
    if (!end || buf == end) goto bad;
    while (end < pend && ISSPACE(*end)) end++;
    if (end < pend) goto bad;
  }
  return d;