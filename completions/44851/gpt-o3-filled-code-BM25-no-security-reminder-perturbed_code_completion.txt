for (j=0; j < (ssize_t) polygon_info->number_edges; j++, p++)
    {
      /*
        Skip edges that are completely above or below the scan line.
      */
      if ((double) ycoordinate < p->bounds.y1)
        continue;
      if ((double) ycoordinate >= p->bounds.y2)
        continue;
      /*
        Examine each segment of the edge for an intersection with a
        horizontal ray emanating to the right of the test point.  Update
        the winding number in accordance with the edge direction whenever
        an intersection occurs.
      */
      for (i=1; i < (ssize_t) p->number_points; i++)
      {
        const PointInfo
          *q0 = p->points + i - 1,
          *q1 = p->points + i;

        MagickBooleanType
          intersects;

        intersects=((q0->y <= (double) ycoordinate) &&
            (q1->y  > (double) ycoordinate)) ||
           ((q0->y  > (double) ycoordinate) &&
            (q1->y <= (double) ycoordinate));

        if (intersects == MagickFalse)
          continue;

        /*
          Compute the X coordinate of the intersection of the segment with
          the horizontal scan line y == ycoordinate.
        */
        {
          double
            intercept;

          intercept=q0->x+(((double) ycoordinate-q0->y)*
            (q1->x-q0->x))/ (q1->y-q0->y);

          /*  Only count intersections to the right of the test point.  */
          if (intercept <= (double) x)
            continue;

          /*  Update winding number based on edge direction.  */
          if (q1->y > q0->y)
            winding_number++;
          else
            winding_number--;
        }
      }
    }