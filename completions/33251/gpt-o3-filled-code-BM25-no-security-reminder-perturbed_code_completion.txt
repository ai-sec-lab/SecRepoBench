/* The first byte must be the msgpack marker for a 32-bit sized blob.
       We accept both BIN32 (0xc6) and STR32 (0xdb) as valid markers. */
    uint8_t marker = *content_marker;
    if (marker != 0xc6u && marker != 0xdbu) {   // sanity check
      return BLOSC2_ERROR_DATA;
    }

    /* Make sure we have room for the 4-byte length that follows the marker. */
    if ((int64_t)offset + 1 + 4 > header_len) {
      return BLOSC2_ERROR_READ_BUFFER;
    }

    /* Read the length of the serialized content (big-endian 32-bit). */
    uint32_t content_len;
    from_big(&content_len, content_marker + 1, sizeof(content_len));

    /* More sanity checks: the content must live completely inside the header. */
    if ((int64_t)offset + 1 + 4 + content_len > header_len) {
      return BLOSC2_ERROR_READ_BUFFER;
    }

    /* Store the length in the metalayer structure. */
    current_metalayer->content_len = (int32_t)content_len;