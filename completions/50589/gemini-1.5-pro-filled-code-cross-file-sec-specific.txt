buffer.clear();

    if (m_cache.empty()) {
        if (!readNextBlock()) {
            return false;
        }
    }

    while (!m_cache.empty()) {
        size_t nextEOL = m_cache.find('\n');
        if (std::string::npos == nextEOL) {
            // Add the whole cache to the current line
            buffer.insert(buffer.end(), m_cache.begin(), m_cache.end());
            m_cache.clear();

            // Read the next block. If no more data is available, return the current line.
            if (!readNextBlock()) {
                return !buffer.empty();
            }
        } else {
            // Add the data up to (and including) the EOL character to the current line
            buffer.insert(buffer.end(), m_cache.begin(), m_cache.begin() + nextEOL + 1);
            m_cache.erase(m_cache.begin(), m_cache.begin() + nextEOL + 1);

            // Skip '\r' if it follows '\n'
            if (!m_cache.empty() && m_cache[0] == '\r') {
                m_cache.erase(m_cache.begin());
            }

            return true;
        }
    }

    // No more data available
    return !buffer.empty();