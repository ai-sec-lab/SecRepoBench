buffer.clear();

    if (m_cache.empty()) {
        if (!readNextBlock()) {
            return false;
        }
    }

    while (!m_cache.empty()) {
        auto it = std::find(m_cache.begin() + m_cachePos, m_cache.end(), '\n');
        if (it != m_cache.end()) {
            buffer.insert(buffer.end(), m_cache.begin() + m_cachePos, it);
            m_cachePos = std::distance(m_cache.begin(), it) + 1;

            // Remove characters from the cache
            if (m_cachePos >= m_cache.size()) {
                m_cache.clear();
                m_cachePos = 0;
            }

            // Skip '\r' after '\n'
            if (!buffer.empty() && buffer.back() == '\r') {
                buffer.pop_back();
            }
            return true;
        } else {
            buffer.insert(buffer.end(), m_cache.begin() + m_cachePos, m_cache.end());
            m_cache.clear();
            m_cachePos = 0;

            // Read the next block to continue searching for a newline
            if (!readNextBlock()) {
                // If no more data is available, return the current buffer
                if (!buffer.empty() && buffer.back() == '\r') {
                    buffer.pop_back();
                }
                return !buffer.empty();
            }
        }
    }

    return !buffer.empty();