line.clear();

    // make sure that we have data in the internal cache
    if (m_cachePos >= m_cache.size()) {
        if (!readNextBlock()) {
            return false;               // no data at all
        }
    }

    for (;;) {
        // remember the position at which the current fragment of the line starts
        size_t fragmentStart = m_cachePos;

        // iterate over the cache until we either reach its end or encounter a line break
        while (m_cachePos < m_cache.size()) {
            const T c = m_cache[m_cachePos];
            if (c == static_cast<T>('\n') || c == static_cast<T>('\r')) {
                break;                  // end-of-line marker found
            }
            ++m_cachePos;
        }

        // append the characters collected so far to the destination buffer
        if (m_cachePos > fragmentStart) {
            line.insert(line.end(),
                         m_cache.begin() + fragmentStart,
                         m_cache.begin() + m_cachePos);
        }

        // have we stopped because we hit the end-of-line?
        if (m_cachePos < m_cache.size()) {
            // consume the EOL character we stopped at
            T eol = m_cache[m_cachePos++];

            // if it was a CR, swallow the following LF if present (Windows style CR/LF)
            if (eol == static_cast<T>('\r')) {
                if (m_cachePos >= m_cache.size()) {
                    // need to read a new block to check what comes next
                    if (readNextBlock()) {
                        if (!m_cache.empty() && m_cache[0] == static_cast<T>('\n')) {
                            m_cachePos = 1;          // skip the LF
                        } else {
                            m_cachePos = 0;
                        }
                    }
                } else if (m_cache[m_cachePos] == static_cast<T>('\n')) {
                    ++m_cachePos;                    // skip the LF
                }
            }
            return true;                             // a complete line has been read
        }

        // we reached the end of the cache without encountering an EOL â€“ try to refill
        if (!readNextBlock()) {
            // end-of-file; return whatever we have accumulated, if anything
            return !line.empty();
        }
    }