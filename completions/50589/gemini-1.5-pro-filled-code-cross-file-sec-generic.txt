if (m_cachePos >= m_cache.size()) {
        if (!readNextBlock()) {
            return false;
        }
    }

    if (m_cache.empty()) {
        return false;
    }

    auto it = std::find_if(m_cache.begin() + m_cachePos, m_cache.end(), [](T c) {
        return c == '\n' || c == '\r' || c == '\0';
    });

    if (it != m_cache.end()) {
        buffer.assign(m_cache.begin() + m_cachePos, it);
        m_cachePos = std::distance(m_cache.begin(), it + 1);

        // Skip any subsequent end-of-line characters
        while (m_cachePos < m_cache.size() && (*it == '\n' || *it == '\r')) {
            ++it;
            ++m_cachePos;
        }


    } else {
        buffer.assign(m_cache.begin() + m_cachePos, m_cache.end());
        m_cachePos = m_cache.size();

        // If we reached the end of the cache without finding a newline,
        // read the next block and append to the current line.
        while (readNextBlock()) {
            if (m_cache.empty()) {
                break; // End of stream
            }

            auto it2 = std::find_if(m_cache.begin(), m_cache.end(), [](T c) {
                return c == '\n' || c == '\r' || c == '\0';
            });

            buffer.insert(buffer.end(), m_cache.begin(), it2);

            if (it2 != m_cache.end()) {
                m_cachePos = std::distance(m_cache.begin(), it2 + 1);

                // Skip any subsequent end-of-line characters
                while (m_cachePos < m_cache.size() && (*it2 == '\n' || *it2 == '\r')) {
                    ++it2;
                    ++m_cachePos;
                }
                break;
            } else {
                m_cachePos = m_cache.size();
            }
        }
    }

    return !buffer.empty();