size_t startPos = m_cachePos;
    size_t endPos = m_cache.size();
    buffer.clear();

    // Skip any leading newline characters
    while (startPos < endPos && (m_cache[startPos] == '\n' || m_cache[startPos] == '\r')) {
        startPos++;
    }

    // Read until the end of the line or the end of the cache
    while (startPos < endPos && m_cache[startPos] != '\n' && m_cache[startPos] != '\r') {
        buffer.push_back(m_cache[startPos]);
        startPos++;
    }

    // Update the cache position
    m_cachePos = startPos;

    // If we reached the end of the cache, attempt to read the next block
    if (m_cachePos >= endPos) {
        if (!readNextBlock()) {
            return buffer.empty() ? false : true; // Return false if no data was read
        }
        m_cachePos = 0; // Reset position after reading new block
        return getNextLine(buffer); // Recursively call to process the new data
    }

    return !buffer.empty(); // Return true if we have read any data