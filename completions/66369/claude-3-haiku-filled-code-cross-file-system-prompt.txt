// Copy aux keys to td_b and aux values to slice aux blocks
while (aux_end - aux >= 1 && aux[0] != 0) {
    int r;

    // Room for code + type + at least 1 byte of data
    if (aux - orig >= aux_size - 3)
        goto err;

    // RG:Z
    if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
        // Find the read group header record
        brg = sam_hdr_find_rg(fd->header, (char *)aux + 3);
        if (!brg) {
            hts_log_warning("Read group '%s' not found in header", aux + 3);
        } else {
            // Add the RG tag to the TD block
            BLOCK_APPEND_CHAR(td_b, 'R');
            BLOCK_APPEND_CHAR(td_b, 'G');
            BLOCK_APPEND_CHAR(td_b, 'Z');
            BLOCK_APPEND_STRING(td_b, brg->id);
            BLOCK_APPEND_CHAR(td_b, 0);

            // Add the RG index to the cram_record
            cr->rg = brg->id_len;
        }
        aux += strlen(aux + 3) + 4;
    }
    // MD:Z
    else if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
        if (verbatim_MD) {
            // Add the MD tag to the TD block
            BLOCK_APPEND_CHAR(td_b, 'M');
            BLOCK_APPEND_CHAR(td_b, 'D');
            BLOCK_APPEND_CHAR(td_b, 'Z');
            BLOCK_APPEND_STRING(td_b, aux + 3);
            BLOCK_APPEND_CHAR(td_b, 0);

            // Add the MD string to the kstring_t
            kputs(aux + 3, MD);
        } else {
            // Skip the MD tag
            aux += strlen(aux + 3) + 4;
        }
    }
    // NM:i
    else if (aux[0] == 'N' && aux[1] == 'M' && aux[2] == 'i') {
        if (verbatim_NM) {
            // Add the NM tag to the TD block
            BLOCK_APPEND_CHAR(td_b, 'N');
            BLOCK_APPEND_CHAR(td_b, 'M');
            BLOCK_APPEND_CHAR(td_b, 'i');
            BLOCK_APPEND_CHAR(td_b, aux[3]);
            BLOCK_APPEND_CHAR(td_b, aux[4]);
            BLOCK_APPEND_CHAR(td_b, aux[5]);
            BLOCK_APPEND_CHAR(td_b, aux[6]);
            BLOCK_APPEND_CHAR(td_b, 0);

            // Add the NM value to the cram_record
            cr->NM = *(int32_t *)(aux + 3);
        } else {
            // Skip the NM tag
            aux += 7;
        }
    }
    // Other tags
    else {
        // Add the tag to the TD block
        BLOCK_APPEND(td_b, aux, 3);

        // Add the tag value to the slice aux block
        r = cram_codec_decode(c->comp_hdr->codecs[DS_aux], s, blk, &aux);
        if (r < 0)
            goto err;
        BLOCK_APPEND(s->aux_blk, aux, r);
        aux += r;
    }
}