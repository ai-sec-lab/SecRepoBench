if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
    char *rg = (char *)aux + 3;
    k = kh_get(m_s2i, c->comp_hdr->RG_hash, rg);
    if (k != kh_end(c->comp_hdr->RG_hash)) {
        brg = sam_hrecs_find_rg(fd->header->hrecs, rg);
        cr->rg = kh_val(c->comp_hdr->RG_hash, k);
    } else {
        hts_log_warning("Unknown read group: \"%s\"", rg);
    }
    BLOCK_APPEND(s->aux_blk, aux, 3 + strlen(rg) + 1);
    aux += 3 + strlen(rg) + 1;
} else if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
    if (verbatim_MD) {
        BLOCK_APPEND(s->aux_blk, aux, 3);
        BLOCK_APPEND(s->aux_blk, MD->s, MD->l);
        BLOCK_APPEND_CHAR(s->aux_blk, '\0');
    }
    aux += 3 + strlen((char *)aux + 3) + 1;
} else if (aux[0] == 'N' && aux[1] == 'M') {
    if (verbatim_NM) {
        BLOCK_APPEND(s->aux_blk, aux, 3);
        BLOCK_APPEND_CHAR(s->aux_blk, 'i');
        BLOCK_APPEND_INT32(s->aux_blk, NM);
    }
    aux += 3 + 4;
} else {
    tm = map_find(c->comp_hdr->tag_encoding_map, aux, aux[2]);
    if (!tm) {
        hts_log_warning("Unknown tag %c%c:%c", aux[0], aux[1], aux[2]);
        return NULL;
    }

    if (!tm->codec) {
        hts_log_warning("Unimplemented codec for tag %c%c:%c", aux[0], aux[1], aux[2]);
        return NULL;
    }

    BLOCK_APPEND(s->aux_blk, aux, 3);

    if (tm->codec->encode(s, tm->codec, aux+3, aux_end - aux - 3) < 0)
        return NULL;

    aux = aux_end;
}