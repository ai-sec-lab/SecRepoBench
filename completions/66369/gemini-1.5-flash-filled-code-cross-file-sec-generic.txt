key = aux;
        k = kh_get(m_s2i, c->comp_hdr->TD_hash, key);
        if (k == kh_end(c->comp_hdr->TD_hash)) {
            k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
            if (new < 0)
                goto err;
            c->comp_hdr->nTL++;
        }
        tm = &c->comp_hdr->TL[kh_val(c->comp_hdr->TD_hash, k)];
        if (!tm->blk) {
            tm->blk = cram_new_block(BLOCK_SIZE(td_b));
            if (!tm->blk)
                goto block_err;
        }
        r = cram_encode_aux_data(fd, b, aux, aux_end - aux, tm, err);
        if (r < 0)
            goto err;
        aux += r;
        if (err && *err)
            goto err;

        // Update container level metrics
        c->comp_hdr->n_aux_tags++;
        if (cram_stats_add(c->stats[DS_AUX], r) < 0)
            goto block_err;
        if (cram_stats_add(c->stats[DS_AUX_BYTES], aux_end - aux) < 0)
            goto block_err;
        // Update slice level metrics
        s->n_aux_tags++;
        s->aux_bytes += aux_end - aux;
        if (s->aux_bytes > (1u<<31)) {
            hts_log_error("CRAM->BAM aux block size overflow");
            goto block_err;
        }
        // Update record level metrics
        cr->n_aux_tags++;
        cr->aux_size += aux_end - aux;
        if (cr->aux_size > (1u<<31)) {
            hts_log_error("CRAM->BAM aux block size overflow");
            goto block_err;
        }

        // Append to the tag map
        BLOCK_APPEND(td_b, key, aux - key);
        // Update the tag map size
        TD_blk_size += aux - key;
        // Update the tag map block size
        BLOCK_SIZE(td_b) = TD_blk_size;
        // Update the tag map block size