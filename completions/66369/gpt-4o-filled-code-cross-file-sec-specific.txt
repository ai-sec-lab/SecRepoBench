// Process each auxiliary tag
        while (aux + 2 < aux_end) {
            char tag[3];
            tag[0] = aux[0];
            tag[1] = aux[1];
            tag[2] = aux[2];
            aux += 3;

            // Determine the type of the tag
            switch (tag[2]) {
                case 'A': case 'c': case 'C':
                    aux += 1;
                    break;
                case 's': case 'S':
                    aux += 2;
                    break;
                case 'i': case 'I': case 'f':
                    aux += 4;
                    break;
                case 'Z': case 'H':
                    while (aux < aux_end && *aux != '\0') aux++;
                    aux++;
                    break;
                case 'B': {
                    int32_t count;
                    if (aux + 5 > aux_end) goto err;
                    count = le_to_i32(aux + 1);
                    switch (aux[0]) {
                        case 'c': case 'C':
                            aux += 5 + count;
                            break;
                        case 's': case 'S':
                            aux += 5 + count * 2;
                            break;
                        case 'i': case 'I': case 'f':
                            aux += 5 + count * 4;
                            break;
                        default:
                            goto err;
                    }
                    break;
                }
                default:
                    goto err;
            }

            // Ensure we do not exceed the allocated block size
            if (BLOCK_SIZE(td_b) + 3 > BLOCK_MAX_SIZE(td_b))
                goto err;

            // Append the tag to the block
            BLOCK_APPEND(td_b, tag, 3);
        }