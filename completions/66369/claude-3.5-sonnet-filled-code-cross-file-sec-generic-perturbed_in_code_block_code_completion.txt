if (aux[0] == 'R' && aux[1] == 'G') {
    brg = sam_hrecs_find_rg(filedescriptor->header->hrecs, aux + 3);
    if (!brg) {
        hts_log_warning("RG:Z:%s header line is missing", aux + 3);
    }
}

if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
    if (verbatim_MD) {
        if (CRAM_MAJOR_VERS(filedescriptor->version) >= 4)
            BLOCK_APPEND_CHAR(td_b, '*');
    } else {
        BLOCK_APPEND_CHAR(td_b, 'M');
        BLOCK_APPEND_CHAR(td_b, 'D');
        BLOCK_APPEND_CHAR(td_b, 'Z');
    }
} else if (aux[0] == 'N' && aux[1] == 'M') {
    if (verbatim_NM) {
        if (CRAM_MAJOR_VERS(filedescriptor->version) >= 4)
            BLOCK_APPEND_CHAR(td_b, '*');
    } else {
        BLOCK_APPEND_CHAR(td_b, 'N');
        BLOCK_APPEND_CHAR(td_b, 'M');
        BLOCK_APPEND_CHAR(td_b, aux[2]);
    }
} else {
    BLOCK_APPEND(td_b, aux, 3);
}

key = string_ndup(c->comp_hdr->TD_keys,
                  (char *)BLOCK_DATA(td_b) + TD_blk_size,
                  BLOCK_SIZE(td_b) - TD_blk_size);
if (!key)
    goto block_err;

k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
if (new < 0)
    goto err;
else if (new)
    kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL++;

cram_codec *codec = cram_encoder_init(aux[2], E_BYTE_ARRAY_STOP, NULL,
                                      filedescriptor->version);
if (!codec)
    goto block_err;

codec->store(codec, aux+3, aux_end - aux-3);

if (!(c->comp_hdr->codecs[DS_aux] = cram_encoder_init(E_EXTERNAL, NULL,
                                                      filedescriptor->version)))
    goto block_err;

r |= c->comp_hdr->codecs[DS_aux]->store(c->comp_hdr->codecs[DS_aux],
                                        (char *)codec, 0);

aux += 3 + codec->length(codec);