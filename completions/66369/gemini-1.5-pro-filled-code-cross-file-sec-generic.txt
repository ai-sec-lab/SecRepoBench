key = (char *)aux;
        if (aux_end - aux < 3)
            goto err;

        if (key[0] == 'R' && key[1] == 'G' && key[2] == 'Z') {
            if (!brg) {
                brg = sam_hrecs_find_rg(fd->header->hrecs, (char *)aux + 3);
                if (!brg) {
                    if (fd->verbose)
                        hts_log_warning("Read group \"%s\" not found in header, adding",
                                       (char *)aux+3);

                    brg = sam_hrecs_add_rg(fd->header->hrecs, (char *)aux + 3);
                    if (!brg)
                        goto err; // FIXME: add err msg
                }
                cr->rg = brg->id;
            }
        }

        if (key[0] == 'M' && key[1] == 'D' && key[2] == 'Z') {
            if (verbatim_MD) {
                if (MD) free(MD->s);
                MD->l = MD->m = 0;
                MD->s = NULL;
                kputs((char *)aux+3, MD);
                if (cram_stats_add(c->stats[DS_MD], MD->l) < 0)
                    goto block_err;
            }
            goto skip_aux_store; // stored verbatim
        }

        if (key[0] == 'N' && key[1] == 'M' && key[2] == 'i') {
            if (verbatim_NM) {
                NM = *(int32_t *)(aux+3);
            }
            goto skip_aux_store; // stored verbatim
        }

        k = kh_put(m_c2i, c->comp_hdr->tag_map, key, &new);
        if (new < 0)
            goto err;

        cram_tag_map *tm = &kh_val(c->comp_hdr->tag_map, k);
        if (new) {
            tm->blk = cram_new_aux_block(fd, key, aux[2]);
            if (!tm->blk)
                goto err;

            tm->m = tm->blk->m;
        }

        if (BLOCK_SIZE(tm->blk) == 0) {
            BLOCK_APPEND(tm->blk, aux, 3);
        }

        BLOCK_APPEND(tm->blk, aux+3, aux_end - (aux+3));

        if (cram_stats_add(c->stats[DS_aux], aux_end - (aux+3)) < 0)
            goto block_err;

        s->aux_blk_used += aux_end - (aux+3);

    skip_aux_store:
        aux = (char *)aux_end;
        while (aux < (char *)bam_aux(b) + aux_size && *aux) {
            aux++;
        }
        aux++; // skip null terminator too.

        if (new)
            c->comp_hdr->nTM++;

        if (tm->blk)
            tm->blk->n_content++;
        if (tm->blk && tm->blk->n_content > tm->blk->n_uncomp_content)
            tm->blk->n_uncomp_content = tm->blk->n_content;
        if (tm->blk && tm->blk->n_content == tm->m)
            cram_flush_aux_block(fd, c, tm, 0);
        if (tm->blk)