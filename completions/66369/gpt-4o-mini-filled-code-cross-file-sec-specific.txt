// Ensure we have enough space for the key and value
        if (aux_end - aux < 3) {
            goto err;
        }

        // Read the key
        char key[3] = { aux[0], aux[1], aux[2] };
        aux += 3;

        // Determine the size of the value
        int value_size = 0;
        if (aux_end - aux < 1) {
            goto err;
        }
        char type = aux[0];
        aux++;

        // Handle different types of values
        if (type == 'Z' || type == 'H') { // String or Hex
            while (aux < aux_end && *aux != '\0') {
                aux++;
                value_size++;
            }
            if (aux < aux_end) {
                aux++; // Skip the null terminator
            }
        } else if (type == 'i' || type == 'I') { // Integer
            value_size = sizeof(int32_t);
            aux += value_size;
        } else if (type == 'f') { // Float
            value_size = sizeof(float);
            aux += value_size;
        } else {
            goto err; // Unsupported type
        }

        // Ensure we do not exceed the allocated size
        if (aux - orig > aux_size) {
            goto err;
        }

        // Process the key-value pair (store or encode as needed)
        // Example: store the key and value in the appropriate structure
        // This is a placeholder for actual processing logic
        process_aux_key_value(key, type, aux - value_size, value_size);