// Copy aux keys to td_b and aux values to slice aux blocks
while (aux_end - aux >= 1 && aux[0] != 0) {
    int r;

    // Room for code + type + at least 1 byte of data
    if (aux - orig >= aux_size - 3)
        goto err;

    // RG:Z
    if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
        // Find the read group header record
        brg = sam_hdr_find_rg(fd->header, (char *)aux + 3);
        if (brg) {
            // Add the RG tag to the container-level tag map
            BLOCK_APPEND(td_b, "RG", 2);
            BLOCK_APPEND_CHAR(td_b, 'Z');
            BLOCK_APPEND(td_b, brg->id, strlen(brg->id) + 1);
            cr->rg = brg->id_len;
        } else {
            // RG tag not found in header, skip it
            while (aux[0] && aux < aux_end)
                aux++;
            continue;
        }
    } else if (aux[0] == 'M' && aux[1] == 'D' && verbatim_MD) {
        // Append the MD tag verbatim
        BLOCK_APPEND(td_b, "MD", 2);
        BLOCK_APPEND_CHAR(td_b, 'Z');
        BLOCK_APPEND(td_b, aux + 3, strlen(aux + 3) + 1);
        MD->s = aux + 3;
        MD->l = strlen(aux + 3);
    } else if (aux[0] == 'N' && aux[1] == 'M' && verbatim_NM) {
        // Append the NM tag verbatim
        BLOCK_APPEND(td_b, "NM", 2);
        BLOCK_APPEND_CHAR(td_b, 'i');
        BLOCK_APPEND(td_b, aux + 3, strlen(aux + 3) + 1);
        *NM = atoi(aux + 3);
    } else {
        // Encode other aux tags
        BLOCK_APPEND(td_b, aux, 3);
        r = cram_encode_aux_value(s, c->comp_hdr->tag_encoding_map, blk, aux + 3, td_b);
        if (r < 0)
            goto err;
    }

    while (aux[0]) aux++;
    aux++;
}