key = aux;
        k = kh_get(m_s2i, c->comp_hdr->TD_hash, key);
        if (k == kh_end(c->comp_hdr->TD_hash)) {
            int new;
            k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
            if (new < 0)
                goto err;
            else if (new == 0) {
                // Duplicate key
                goto next_aux;
            }
            kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
            c->comp_hdr->nTL++;
        }
        cr->TL = kh_val(c->comp_hdr->TD_hash, k);
        if (cram_stats_add(c->stats[DS_TL], cr->TL) < 0)
            goto block_err;

        if (aux[2] == '*') {
            // Placeholder for later
            goto next_aux;
        }

        // Append to the correct block
        cram_codec *codec = c->comp_hdr->codecs[DS_AUX];
        if (!codec)
            goto err;

        int ret = codec->encode(s, codec, aux, aux_end - aux, &s->aux_blk);
        if (ret < 0)
            goto err;

        c->s_aux_bytes += aux_end - aux;

    next_aux:
        aux += aux[2] + 3;
    }

    if (aux != orig && aux != (char *)bam_aux(b))
        free(orig);

    // Add to the tag map
    cram_tag_map *tm = &c->comp_hdr->tag_map;
    if (tm->m == tm->n) {
        tm->n = tm->n ? tm->n * 2 : 4;
        tm->blk = realloc(tm->blk, tm->n * sizeof(cram_tag_map_entry));
        if (!tm->blk)
            goto err;
    }
    tm->blk[tm->m].key = cr->TL;