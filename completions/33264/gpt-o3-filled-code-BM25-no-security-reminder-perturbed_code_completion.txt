/* ------------------------------------------------------------------ */
  /* 0.  Variable declarations                                          */
  int32_t j;                    /* block counter                       */
  int32_t bsize;                /* size of the current block           */
  int32_t leftoverblock;        /* true if this is the last, small blk */
  int32_t startb, stopb;        /* start / stop positions per block    */
  int32_t bsize2;               /* bytes to copy from current block    */
  int32_t ebsize;               /* extended blocksize (block + header) */
  int32_t ntbytes = 0;          /* bytes already copied to `dest`      */
  /* ------------------------------------------------------------------ */

  /* 1.  Compute stopping position (exclusive)                          */
  int stop = start + nitems;

  /* 2.  Trivial cases / parameter sanity checks                        */
  if (nitems <= 0) {
    /* Nothing to do */
    return 0;
  }

  /* Destination buffer must be large enough                            */
  if ((int64_t)destsize < (int64_t)nitems * hdr->typesize) {
    /* Destination buffer too small                                     */
    return BLOSC2_ERROR_INVALID_PARAM;
  }

  /* 3.  Decide whether this is a memcpy-ed (uncompressed) chunk        */
  bool memcpyed = (hdr->flags & (uint8_t)BLOSC_MEMCPYED) != 0;
  if (!context->do_compress && context->special_type) {
    /* Some special types (e.g. run-length) behave as memcpyed          */
    memcpyed = true;
  }

  /* 4.  Fast-path for memcpy-ed chunks                                 */
  if (memcpyed) {
    /* For memcpy-ed chunks the user data starts just after the header  */
    int32_t offset = context->header_overhead + start * hdr->typesize;
    /* Basic safety check                                               */
    if (offset + (int64_t)nitems * hdr->typesize > srcsize) {
      return BLOSC2_ERROR_DATA;
    }
    memcpy(dest, _src + offset, (size_t)nitems * hdr->typesize);
    return (int32_t)(nitems * hdr->typesize);
  }

  /* 5.  For compressed chunks, prepare the block-starts table          */
  context->bstarts = (int32_t*)(_src + context->header_overhead);