/* look for an 'esds' box signature */
		if ((data[index+4]=='e') && (data[index+5]=='s') && (data[index+6]=='d') && (data[index+7]=='s')) {
			GF_BitStream *bs_tmp = NULL;
			GF_Box      *esds_box = NULL;

			/* build a bitstream starting at the potential esds location */
			bs_tmp = gf_bs_new(NULL, 0, GF_BITSTREAM_READ);
			if (!bs_tmp) {
				e = GF_OUT_OF_MEM;
				break;
			}
			/* attach our buffer to this bitstream */
			gf_bs_attach_data(bs_tmp, (char*)data + index, size - index, GF_FALSE);
			/* do not log while parsing this fake bitstream */
			gf_bs_set_cookie(bs_tmp, GF_ISOM_BS_COOKIE_SUPPRESS_LOG);

			/* try to parse the box */
			if (gf_isom_box_parse(&esds_box, bs_tmp) == GF_OK && esds_box && (esds_box->type == GF_ISOM_BOX_TYPE_ESDS)) {
				/* remove any previously parsed ESDS box */
				if (ptr->esd) {
					gf_isom_box_array_remove(s, (GF_Box *)ptr->esd);
					gf_isom_box_del((GF_Box *)ptr->esd);
					ptr->esd = NULL;
				}
				/* keep a ref in the sample entry structure */
				ptr->esd = (GF_ESDBox *)esds_box;
				/* and add it to the list of child boxes so it is written back later on */
				gf_isom_box_array_add(s, esds_box);
				e = GF_OK;
			} else if (esds_box) {
				/* parsing succeeded but this is not an ESDS box â€“ discard */
				gf_isom_box_del(esds_box);
			}

			/* cleanup */
			gf_bs_del(bs_tmp);
			if (e == GF_OK) break;
		}