// Calculate character limits for compound checking
  if (!word || len == 0) {
    *mincharindex = 0;
    *cmax = 0;
    return;
  }

  if (utf8) {
    /* --- determine the first byte *after* the first `cpdmin`
     * UTF-8 characters ------------------------------------ */
    size_t idx = 0;
    int    chars = 0;
    while (idx < len && chars < cpdmin) {
      if ((static_cast<unsigned char>(word[idx]) & 0xC0) != 0x80) {
        ++chars;              // count only leading bytes
      }
      ++idx;                  // advance byte pointer
    }
    *mincharindex = idx;      // byte offset of the (cpdmin+1)-th character

    /* --- determine the first byte of the last UTF-8 character ------------- */
    size_t j = len - 1;
    while (j > 0 && ((static_cast<unsigned char>(word[j]) & 0xC0) == 0x80)) {
      --j;                    // skip trailing continuation bytes
    }
    *cmax = j;
  } else {
    // 8-bit (single-byte) encoding
    *mincharindex = (len > static_cast<size_t>(cpdmin)) ? cpdmin : len;
    *cmax = (len == 0) ? 0 : len - 1;
  }