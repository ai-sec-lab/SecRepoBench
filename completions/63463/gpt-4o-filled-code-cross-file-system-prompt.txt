{
  BITCODE_RL obj_size;
  BITCODE_RL crc16 = 0;
  BITCODE_RL crc16_read = 0;
  BITCODE_RL extra_data_size = 0;
  BITCODE_RL extra_data_start = 0;

  obj_size = bit_read_RL(dat);
  LOG_TRACE("obj_size: 0x%x\n", obj_size);

  if (obj_size != obj->size)
  {
    LOG_WARN("Object size mismatch: expected 0x%x, got 0x%x\n", obj->size, obj_size);
    obj->size = obj_size;
  }

  if (dat->byte + obj_size > oldpos + size)
  {
    LOG_ERROR("Object size exceeds available data: 0x%x > 0x%x\n", dat->byte + obj_size, oldpos + size);
    return DWG_ERR_INVALIDDWG;
  }

  if (dat->byte + obj_size < oldpos + size)
  {
    extra_data_start = dat->byte + obj_size;
    extra_data_size = oldpos + size - extra_data_start;
    LOG_TRACE("Extra data detected: start 0x%x, size 0x%x\n", extra_data_start, extra_data_size);
    dat->byte = extra_data_start;
    obj->unknown_bits = bit_read_bits(dat, extra_data_size * 8);
    if (!obj->unknown_bits)
    {
      LOG_ERROR("Failed to read extra data\n");
      return DWG_ERR_INVALIDDWG;
    }
  }

  crc16_read = bit_read_RL(dat);
  crc16 = calculate_crc16(dat, oldpos, obj_size);
  if (crc16 != crc16_read)
  {
    LOG_WARN("CRC16 mismatch: calculated 0x%x, read 0x%x\n", crc16, crc16_read);
    return DWG_ERR_CRC;
  }
}