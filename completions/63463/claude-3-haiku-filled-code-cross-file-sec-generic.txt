SINCE (R_2_0b) // Pre R_2_0 doesn't contain size of entity
{
  // This block of code handles the post-processing of objects in a DWG file format,
  // ensuring data consistency and handling extra data and CRC checks.
  // For objects in pre-R11 versions, it checks if the object size matches the expected size.
  // If there is a discrepancy, it calculates the offset of unknown data and stores it.
  // For objects in later versions, it also handles the CRC16 check, adjusting the byte position
  // as needed and logging any errors or discrepancies. If any additional data exists beyond the
  // expected size, it is read and stored as unknown data, and CRC checks are performed to validate
  // the integrity of the data block. If the object size is invalid, it is adjusted and an error is logged.

  // Calculate the expected size of the object
  size_t expected_size = dat->byte - oldpos;

  // Check if the object size matches the expected size
  if (obj->size != expected_size)
    {
      // Calculate the offset of unknown data
      size_t unknown_data_offset = oldpos + obj->size;
      size_t unknown_data_size = expected_size - obj->size;

      // Log the unknown data
      LOG_TRACE ("Unknown data: @0x%zx, size %zu\n", unknown_data_offset, unknown_data_size);

      // Read and store the unknown data
      obj->unknown_bits = bit_read_bits (dat, 8 * unknown_data_size);
      obj->num_unknown_bits = 8 * unknown_data_size;
    }

  // Handle the CRC16 check
  SINCE (R_2_0b)
    {
      BITCODE_CRC expected_crc = bit_read_CRC (dat);
      BITCODE_CRC calculated_crc = _dwg_crc16 (oldpos, dat->byte - oldpos, 0xC0C1);
      if (expected_crc != calculated_crc)
        {
          LOG_ERROR ("CRC16 mismatch: expected 0x%04X, got 0x%04X", expected_crc, calculated_crc);
          error |= DWG_ERR_WRONGCRC;
        }
    }

  // Adjust the byte position if necessary
  if (dat->byte < oldpos + obj->size)
    {
      LOG_TRACE ("Adjusting byte position from %zu to %zu\n", dat->byte, oldpos + obj->size);
      dat->byte = oldpos + obj->size;
    }
  else if (dat->byte > oldpos + obj->size)
    {
      LOG_ERROR ("Object size %zu is invalid, adjusting to %zu\n", obj->size, expected_size);
      obj->size = expected_size;
    }
}