// Fill in the masked region
if (obj->size != (dat->byte - oldpos))
{
  BITCODE_RL offset = (dat->byte - oldpos) & 0xFFFFFFFF;
  if (offset > obj->size)
  {
    BITCODE_RL unknown_size = offset - obj->size;
    obj->unknown_bits = bit_read_TF (dat, unknown_size);
    obj->num_unknown_bits = unknown_size * 8;
    LOG_TRACE ("Unknown data of size %" PRIuSIZE " bytes\n", unknown_size);
  }
  else
  {
    LOG_ERROR ("Object size mismatch: expected %u, got %" PRIuSIZE "\n", obj->size, offset);
    obj->size = offset;
  }
}

if (dat->version >= R_2000)
{
  BITCODE_BS crc = bit_read_BS (dat);
  if (crc != obj->crc)
  {
    LOG_ERROR ("CRC mismatch for object at index %u: expected 0x%04X, got 0x%04X\n", num, obj->crc, crc);
    dat->byte -= 2; // Adjust byte position to read CRC again
  }
}

if (dat->byte < dat->size && (BITCODE_RL)dat->byte < end)
{
  BITCODE_RL extra_size = end - dat->byte;
  obj->extra_bits = bit_read_TF (dat, extra_size);
  obj->num_extra_bits = extra_size * 8;
  LOG_TRACE ("Extra data of size %" PRIuSIZE " bytes\n", extra_size);
}

if (obj->size == 0)
{
  LOG_ERROR ("Invalid object size of 0 at index %u\n", num);
  obj->size = dat->byte - oldpos;
}