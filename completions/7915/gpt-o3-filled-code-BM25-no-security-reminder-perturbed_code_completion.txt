/*
    Insure this primitive list is something we can translate to a path.
    For the purposes of the drawing subsystem we only attempt the
    conversion for primitives that describe a sequence of points
    (lines, polylines, polygons, paths, etc.).  Everything else is
    considered unsupported and we simply return a NULL pointer.
  */
  if (primitive_info == (const PrimitiveInfo *) NULL)
    return((PathInfo *) NULL);
  if ((primitive_info->primitive != LinePrimitive) &&
      (primitive_info->primitive != PolylinePrimitive) &&
      (primitive_info->primitive != PolygonPrimitive) &&
      (primitive_info->primitive != PathPrimitive) &&
      (primitive_info->primitive != BezierPrimitive))
    return((PathInfo *) NULL);

  /*
    Determine how many primitives we need to accommodate.  The conversion
    process can emit up to four PathInfo elements per input primitive
    (moveto/lineto plus possible open/ghostline/close records) so allocate
    with that upper bound to avoid having to resize the array later.
  */
  for (i = 0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
  path_info=(PathInfo *) AcquireQuantumMemory((size_t) (4*i+1),
    sizeof(*path_info));
  if (path_info == (PathInfo *) NULL)
    return((PathInfo *) NULL);

  /*
    Initialise the working state.
  */
  n=0;                 /* current index into path_info array            */
  coordinates=0;       /* remaining coordinates for current primitive   */
  start=0;             /* index of start of current sub-path            */
  q.x=0.0;             /* previous point                                */
  q.y=0.0;