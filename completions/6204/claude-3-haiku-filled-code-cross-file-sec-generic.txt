// Declare a character array `colorspace` for storing the colorspace name, ensuring it is large enough to hold typical color representations.
char colorspace[MagickPathExtent];

// Introduce a `MagickBooleanType` variable `icc_color` to track if the color is in an ICC color space.
MagickBooleanType icc_color;

// This section of code prepares for parsing colors described in a string format, such as "rgb(100,255,0)".
(void) CopyMagickString(colorspace,name,MagickPathExtent);
for (i=0; colorspace[i] != '\0'; i++)
  if (colorspace[i] == '(')
    break;
colorspace[i--]='\0';
scale=(double) ScaleCharToQuantum(1);
icc_color=MagickFalse;
if (LocaleNCompare(colorspace,"device-",7) == 0)
  {
    (void) CopyMagickString(colorspace,colorspace+7,MagickPathExtent);
    scale=(double) QuantumRange;
    icc_color=MagickTrue;
  }
if (LocaleCompare(colorspace,"icc-color") == 0)
  {
    register ssize_t
      j;

    (void) CopyMagickString(colorspace,name+i+2,MagickPathExtent);
    for (j=0; colorspace[j] != '\0'; j++)
      if (colorspace[j] == ',')
        break;
    colorspace[j--]='\0';
    i+=j+3;
    scale=(double) QuantumRange;
    icc_color=MagickTrue;
  }
LocaleLower(colorspace);
color->alpha_trait=UndefinedPixelTrait;
if ((i > 0) && (colorspace[i] == 'a'))
  {
    colorspace[i]='\0';
    color->alpha_trait=BlendPixelTrait;
  }
type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
if (type < 0)
  {
    (void) ThrowMagickException(exception,GetMagickModule(),
      OptionWarning,"UnrecognizedColor","`%s'",name);
    return(MagickFalse);
  }
color->colorspace=(ColorspaceType) type;
if ((icc_color == MagickFalse) && (color->colorspace == RGBColorspace))
  {
    color->colorspace=sRGBColorspace;  /* as required by SVG standard */
    color->depth=8;
  }