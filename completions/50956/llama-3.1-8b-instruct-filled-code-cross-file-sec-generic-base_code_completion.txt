if (cmsPipelineCheckAndRetreiveStages(Src, 4,
         cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,
         &Curve1, &Matrix1, &Matrix2, &Curve2)) {

    // Retrieve matrix data from two matrix stages within the LUT pipeline.
    // Ensure input offset of the first matrix is zero before proceeding.
    // Multiply the two matrices to compute the resultant matrix.
    // Check if the resultant matrix, combined with the second matrix's offset, is an identity matrix.
    // If so, mark the matrix as an identity to optimize or remove redundant computations.
    _cmsStageMatrixData* Data1 = (_cmsStageMatrixData*)cmsStageData(Matrix1);
    _cmsStageMatrixData* Data2 = (_cmsStageMatrixData*)cmsStageData(Matrix2);

    // Input offset should be zero
    if (Data1->Offset!= NULL) return FALSE;

    // Multiply both matrices to get the result
    cmsMAT3 res;
    _cmsMAT3per(&res, (cmsMAT3*)Data2->Double, (cmsMAT3*)Data1->Double);

    // Now the result is in res + Data2 -> Offset. Maybe is a plain identity?
    cmsBool IdentityMat = FALSE;
    if (_cmsMAT3isIdentity(&res) && Data2->Offset == NULL) {
        // We can get rid of full matrix
        IdentityMat = TRUE;
    }

    // Allocate an empty LUT
    cmsPipeline* Dest = cmsPipelineAlloc(Src->ContextID, Src->InputChannels, Src->OutputChannels);
    if (!Dest) return FALSE;

    // Assamble the new LUT
    if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1)))
        goto Error;

    if (!IdentityMat) {
        if (Src->InputChannels == 1)
            cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Src->ContextID, 1, 1, (const cmsFloat64Number*)&res, Data2->Offset));
        else
            cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Src->ContextID, 3, 3, (const cmsFloat64Number*)&res, Data2->Offset));
    }

    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));

    // If identity on matrix, we can further optimize the curves, so call the join curves routine
    if (IdentityMat) {
        OptimizeByJoiningCurves(&Dest, Intent, InputFormat, OutputFormat, dwFlags);
    }
    else {
        _cmsStageToneCurvesData* mpeC1 = (_cmsStageToneCurvesData*)cmsStageData(Curve1);
        _cmsStageToneCurvesData* mpeC2 = (_cmsStageToneCurvesData*)cmsStageData(Curve2);

        // In this particular optimization, cache does not help as it takes more time to deal with
        // the cache that with the pixel handling
        *dwFlags |= cmsFLAGS_NOCACHE;

        // Setup the optimizarion routines
        SetMatShaper(Dest, mpeC1->TheCurves, &res, (cmsVEC3*)Data2->Offset, mpeC2->TheCurves, OutputFormat);
    }

    cmsPipelineFree(Src);
    *Lut = Dest;
    return TRUE;
Error:
    // Leave Src unchanged
    cmsPipelineFree(Dest);
    return FALSE;
}