/* --------------------------------------------------------------------
   * Initial sanity checks and basic calculations that are needed by the
   * remainder of the routine.
   * ------------------------------------------------------------------ */
  size_t start, end;                 /* Offset of the block and its end.     */
  size_t lastfilteraddress = 0;      /* Will be filled after first execution */
  size_t lastfilterlength  = 0;      /*  …                                   */
  ssize_t tend;                      /* Signed version of ‘end’ for checks.  */
  int ret;                           /* Result value used later on.          */

  /* If we do not have a filter stack or the current filter, fail early. */
  if (filters == NULL || filter == NULL)
    return 0;

  /*
   * The filter stores its absolute start position (blockstartpos).  The
   * beginning of the data currently cached in the LZSS window is held in
   * ‘filterstart’.  The real offset of the block inside the window is
   * therefore the difference between those two values.
   */
  if (filter->blockstartpos < filters->filterstart)
    return 0;               /* Inconsistent state. */

  start = (size_t)(filter->blockstartpos - filters->filterstart);

  /* Calculate the (theoretical) end position of the block. */
  tend = (ssize_t)start + (ssize_t)filter->blocklength;

  /*
   * Invalidate the stored ‘filterstart’ so that the next call has to
   * establish it again – this effectively resets the cached value.
   */
  filters->filterstart = INT64_MAX;

  /*
   * In the original implementation the following call would make sure
   * that the LZSS window is expanded so that at least ‘tend’ bytes are
   * available.  In this trimmed version we simply assume that the window
   * already contains the requested range, hence nothing has to be done
   * here.  If an actual expansion routine is available it can be plugged
   * in at this place.
   */