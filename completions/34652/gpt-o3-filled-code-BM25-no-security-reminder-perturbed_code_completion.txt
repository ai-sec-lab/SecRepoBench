/* Adapt precision so that the resulting representation fits into the
         remaining buffer.

         1)  If the user originally asked for the 'g' format, PREC denotes the
             number of significant digits.  After switching to the fixed ('f')
             format we have to convert that into the number of digits that will
             follow the decimal point.  For numbers smaller than 1 there will be
             (e-1) leading zeros after the decimal point, therefore add (e-1)
             to keep the amount of significant digits unchanged.

         2)  Make sure the string will not overflow the buffer.  In the worst
             case the output will look like
                   0.[(e-1) zeros][prec digits]\0
             which needs (e + prec + 2) bytes (one digit before '.', the '.'
             itself, the zeros/digits and the terminating NUL).  If that does
             not fit, trim PREC accordingly.  The extra adjustment when PREC
             becomes negative mimics the behaviour used for the ≥1 case above –
             it guarantees that at least the decimal point can be emitted when
             the alternative form is requested. */
      if (originalformat == 'g') {
        prec += (e - 1);
      }
      if ((e + prec + 2) > buf_remaining) {
        prec = buf_remaining - e - 2;
        if (prec < 0) {
          prec++;
        }
      }