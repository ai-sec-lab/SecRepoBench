/*------------------------------------------------------------
   * unsigned long division (Knuth algorithm D, see TAOCP 4.3.1)
   *  x : dividend  (already left–shifted by ns bits)
   *  y : divisor   (already left–shifted by ns bits, most-significant
   *                 bit of z = y.p[ydigits-1] is set)
   *  q : quotient  (result)
   *  x : will hold the (still left-shifted) remainder
   *-----------------------------------------------------------*/
  {
    size_t n  = ydigits;          /* length of divisor (in limbs) */
    size_t m  = xd - n;           /* (length dividend) - n        */
    const mp_dbl_limb BASE = ((mp_dbl_limb)1) << DIG_SIZE;
    const mp_limb_t   MASK = (mp_limb_t)(BASE - 1);

    /* zero–initialize the quotient limbs we are going to write */
    for (i = 0; i < q.sz; i++) q.p[i] = 0;

    /* main loop : j runs from m down to 0 */
    for (ssize_t j = (ssize_t)m; j >= 0; j--) {
      /* estimate q̂ */
      mp_dbl_limb u2 = ((mp_dbl_limb)x.p[j + n] << DIG_SIZE)
                     |  x.p[j + n - 1];
      mp_dbl_limb qhat  = u2 / z;
      mp_dbl_limb rhat  = u2 % z;

      /* first refinement of q̂                                                        */
      if (n > 1) {
        while (qhat == BASE ||
              (qhat * y.p[n - 2] >
               BASE * rhat + x.p[j + n - 2])) {
          qhat--;
          rhat += z;
          if (rhat >= BASE) break;
        }
      }

      /* multiply (y * q̂) and subtract from current dividend part                    */
      mp_dbl_limb borrow = 0;
      for (i = 0; i < n; i++) {
        mp_dbl_limb prod   = qhat * y.p[i] + borrow;
        mp_limb_t    plow  = (mp_limb_t)(prod & MASK);
        borrow              = prod >> DIG_SIZE;

        if (x.p[i + j] < plow) {
          x.p[i + j] = (mp_limb_t)(BASE + x.p[i + j] - plow);
          borrow += 1;
        }
        else {
          x.p[i + j] -= plow;
        }
      }

      /* handle the last borrow on limb (j+n)                                         */
      if (x.p[j + n] < (mp_limb_t)borrow) {
        /* q̂ was one too large – add divisor back and decrement q̂                   */
        mp_dbl_limb carry = 0;
        for (i = 0; i < n; i++) {
          mp_dbl_limb sum = (mp_dbl_limb)x.p[i + j] + y.p[i] + carry;
          if (sum >= BASE) {
            x.p[i + j] = (mp_limb_t)(sum - BASE);
            carry = 1;
          }
          else {
            x.p[i + j] = (mp_limb_t)sum;
            carry = 0;
          }
        }
        x.p[j + n] += (mp_limb_t)carry;
        qhat -= 1;                    /* corrected q̂                                  */
      }
      else {
        x.p[j + n] -= (mp_limb_t)borrow;
      }

      /* store the calculated quotient limb                                           */
      q.p[j] = (mp_limb_t)qhat;
    }
  }