/*
    Initialize return value.
  */
  p=(const MagicInfo *) NULL;

  /*
    Make sure the magic cache has been created.
  */
  if (IsMagicCacheInstantiated() == MagickFalse)
    return(p);

  /*
    If no magic pattern is supplied, simply return the first element so
    that the caller can iterate over the list.
  */
  if ((magic == (const unsigned char *) NULL) || (size == 0))
    {
      LockSemaphoreInfo(magic_cache_semaphore);
      p=(const MagicInfo *) GetValueFromLinkedList(magic_cache,0);
      UnlockSemaphoreInfo(magic_cache_semaphore);
      return(p);
    }

  /*
    Search the magic cache first.
  */
  LockSemaphoreInfo(magic_cache_semaphore);
  ResetLinkedListIterator(magic_cache);
  p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
  while (p != (const MagicInfo *) NULL)
  {
    if ((p->extent <= size) &&
        (memcmp(p->magic,magic,p->extent) == 0))
      break;
    p=(const MagicInfo *) GetNextValueInLinkedList(magic_cache);
  }
  UnlockSemaphoreInfo(magic_cache_semaphore);
  if (p != (const MagicInfo *) NULL)
    return(p);

  /*
    Ensure the main magic list is instantiated.
  */
  if (magic_list == (LinkedListInfo *) NULL)
    if (AcquireMagicList(exception) == MagickFalse)
      return((const MagicInfo *) NULL);

  /*
    Search the main magic list.
  */
  LockSemaphoreInfo(magic_list_semaphore);
  ResetLinkedListIterator(magic_list);
  p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
  while (p != (const MagicInfo *) NULL)
  {
    if ((p->extent <= size) &&
        (memcmp(p->magic,magic,p->extent) == 0))
      break;
    p=(const MagicInfo *) GetNextValueInLinkedList(magic_list);
  }