// Creates a new Constructor expression with the optimized list of flattened arguments and
// attempts to replace the current expression node with the optimized expression. Updates the
// optimization context to reflect changes made, including setting the rescan flag if the
// replacement failed. The fUsage count remains unchanged because no references are added or
// removed during this process.
std::unique_ptr<Expression> optimizedConstructor = std::make_unique<Constructor>(
    c.fOffset, &c.type(), std::move(flattened));
optimizationContext->fUsage->replace(expr, optimizedConstructor.get());
if (!try_replace_expression(&b, iter, &optimizedConstructor)) {
    optimizationContext->fNeedsRescan = true;
    return;
}
optimizationContext->fUpdated = true;