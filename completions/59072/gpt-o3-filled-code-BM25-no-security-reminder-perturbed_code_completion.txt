if (UNEXPECTED(op1_string == op2_string)) {
				/* Self-concatenation: create a new buffer to avoid overlap */
				result_str = zend_string_alloc(result_len, 0);
				memcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);
				if (shouldfreeopstring) {
					zend_string_release(op1_string);
					shouldfreeopstring = false;
				}
			} else if (shouldfreeopstring) {
				/* We own op1_string exclusively, extend it in-place */
				if (UNEXPECTED(ZSTR_IS_INTERNED(op1_string))) {
					/* Interned strings can't be modified, fall back to alloc+copy */
					result_str = zend_string_alloc(result_len, 0);
					memcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);
					zend_string_release(op1_string);
				} else {
					result_str = zend_string_extend(op1_string, result_len, 0);
				}
				shouldfreeopstring = false;
				if (free_op2_string && op2_string == op1_string) {
					free_op2_string = false;
					op2_string = result_str;
				}
			} else if (EXPECTED(!ZSTR_IS_INTERNED(op1_string)) && EXPECTED(GC_REFCOUNT(op1_string) == 1)) {
				/* Unique (refcount==1) non-interned string, extend in-place */
				result_str = zend_string_extend(op1_string, result_len, 0);
				if (free_op2_string && op2_string == op1_string) {
					free_op2_string = false;
					op2_string = result_str;
				}
			} else {
				/* Shared or interned string â€“ allocate new buffer */
				result_str = zend_string_alloc(result_len, 0);
				memcpy(ZSTR_VAL(result_str), ZSTR_VAL(op1_string), op1_len);
				if (op1_string != op2_string) {
					zend_string_release(op1_string);
				} else {
					/* op1_string == op2_string, make sure we don't double free */
					free_op2_string = false;
				}
			}