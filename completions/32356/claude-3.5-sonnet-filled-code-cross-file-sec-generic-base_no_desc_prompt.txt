Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
GF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, u32 parent_type)
{
	GF_Err e;
	GF_Box *a = NULL;
	Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;

	//we may have terminators in some QT files (4 bytes set to 0 ...)
	while (parent->size>=8) {
		e = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);
		if (e) {
			if (a) gf_isom_box_del(a);
			return e;
		}
		//sub box parsing aborted with no error
		if (!a) return GF_OK;

		// <MASK>

		//check container validity
		if (strlen(a->registry->parents_4cc)) {
			Bool parent_OK = GF_FALSE;
			const char *parent_code = gf_4cc_to_str(parent->type);
			if (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)
				parent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );
			if (strstr(a->registry->parents_4cc, parent_code) != NULL) {
				parent_OK = GF_TRUE;
			} else if (!strcmp(a->registry->parents_4cc, "*") || strstr(a->registry->parents_4cc, "* ") || strstr(a->registry->parents_4cc, " *")) {
				parent_OK = GF_TRUE;
			} else {
				//parent must be a sample entry
				if (strstr(a->registry->parents_4cc, "sample_entry") !=	NULL) {
					//parent is in an stsd
					if (strstr(parent->registry->parents_4cc, "stsd") != NULL) {
						if (strstr(a->registry->parents_4cc, "video_sample_entry") !=	NULL) {
							if (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {
								parent_OK = GF_TRUE;
							}
						} else {
							parent_OK = GF_TRUE;
						}
					}
				}
				//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level
				else if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;
				else if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;
			}
			if (! parent_OK && !skip_logs) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[iso file] Box \"%s\" is invalid in container %s\n", gf_4cc_to_str(a->type), parent_code));
			}
		}

		//always register boxes
		if (!parent->child_boxes) {
			parent->child_boxes = gf_list_new();
			if (!parent->child_boxes) return GF_OUT_OF_MEM;
		}
		e = gf_list_add(parent->child_boxes, a);
		if (e) return e;

		if (parent->registry->add_rem_fn) {
			e = parent->registry->add_rem_fn(parent, a, GF_FALSE);
			if (e) {
				if (e == GF_ISOM_INVALID_MEDIA) return GF_OK;
				//if the box is no longer present, consider it destroyed
				if (gf_list_find(parent->child_boxes, a) >=0) {
					gf_isom_box_del_parent(&parent->child_boxes, a);
				}
				return e;
			}
		}
	}
	return GF_OK;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/isomedia/box_funcs.c
// GF_Box *gf_isom_box_new_ex(u32 boxType, u32 parentType, Bool skip_logs, Bool is_root_box)
// {
// 	GF_Box *a;
// 	s32 idx = get_box_reg_idx(boxType, parentType, 0);
// 	if (idx==0) {
// #ifndef GPAC_DISABLE_LOG
// 		if (!skip_logs && (boxType != GF_ISOM_BOX_TYPE_UNKNOWN) && (boxType != GF_ISOM_BOX_TYPE_UUID)) {
// 			switch (parentType) {
// 			case GF_ISOM_BOX_TYPE_ILST:
// 			case GF_ISOM_BOX_TYPE_META:
// 			case GF_ISOM_BOX_TYPE_UDTA:
// 			case GF_ISOM_BOX_TYPE_UNKNOWN:
// 			case GF_ISOM_BOX_TYPE_iTunesSpecificInfo:
// 			case GF_QT_BOX_TYPE_WAVE:
// 				break;
// 			default:
// 				if (is_root_box) {
// 					GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("[iso file] Unknown top-level box type %s\n", gf_4cc_to_str(boxType)));
// 				} else if (parentType) {
// 					char szName[GF_4CC_MSIZE];
// 					strcpy(szName, gf_4cc_to_str(parentType));
// 					GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("[iso file] Unknown box type %s in parent %s\n", gf_4cc_to_str(boxType), szName));
// 				} else {
// 					GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("[iso file] Unknown box type %s\n", gf_4cc_to_str(boxType)));
// 				}
// 				break;
// 			}
// 		}
// #endif
//         if (boxType==GF_ISOM_BOX_TYPE_UUID) {
//             a = uuid_box_new();
//             if (a) a->registry = &box_registry[1];
//         } else {
//             a = unkn_box_new();
//             if (a) {
//             	((GF_UnknownBox *)a)->original_4cc = boxType;
//             	a->registry = &box_registry[0];
// 			}
//         }
// 		return a;
// 	}
// 	a = box_registry[idx].new_fn();
// 
// 	if (a) {
// 		if (a->type!=GF_ISOM_BOX_TYPE_UUID) {
// 			if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) {
// 				((GF_UnknownBox *)a)->original_4cc = boxType;
// 			} else {
// 				a->type = boxType;
// 			}
// 		}
// 		a->registry = &box_registry[idx];
// 
// 		if ((a->type==GF_ISOM_BOX_TYPE_COLR) && (parentType==GF_ISOM_BOX_TYPE_JP2H)) {
// 			((GF_ColourInformationBox *)a)->is_jp2 = GF_TRUE;
// 		}
// 
// 	}
// 	return a;
// }

// the below code fragment can be found in:
// src/isomedia/box_funcs.c
// GF_EXPORT
// u32 gf_isom_get_num_supported_boxes()
// {
// 	return sizeof(box_registry) / sizeof(struct box_registry_entry);
// }

// the below code fragment can be found in:
// src/isomedia/box_funcs.c
// GF_EXPORT
// GF_Box *gf_isom_box_new(u32 boxType)
// {
// 	return gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);
// }

// the below code fragment can be found in:
// src/isomedia/box_funcs.c
// GF_Box *gf_isom_box_find_child(GF_List *children, u32 code)
// {
// 	u32 i, count;
// 	if (!children) return NULL;
// 	count = gf_list_count(children);
// 	for (i=0; i<count; i++) {
// 		GF_Box *c = gf_list_get(children, i);
// 		if (c->type==code) return c;
// 
// 		if (c->type==GF_ISOM_BOX_TYPE_UNKNOWN) {
// 			if (((GF_UnknownBox*)c)->original_4cc==code)
// 				return c;
// 		}
// 		if (c->type==GF_ISOM_BOX_TYPE_UUID) {
// 			if (((GF_UUIDBox*)c)->internal_4cc==code)
// 				return c;
// 		}
// 	}
// 	return NULL;
// }

// the below code fragment can be found in:
// src/isomedia/box_funcs.c
// static GF_Err gf_isom_box_size_listing(GF_Box *a)
// {
// 	if (!a) return GF_BAD_PARAM;
// 	if (!a->registry) {
// 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Size invalid box type %s without registry\n", gf_4cc_to_str(a->type) ));
// 		return GF_ISOM_INVALID_FILE;
// 	}
// 	a->size = 8;
// 
// 	if (a->type == GF_ISOM_BOX_TYPE_UUID) {
// 		a->size += 16;
// 	}
// 	//the large size is handled during write, cause at this stage we don't know the size
// 	if (a->registry->max_version_plus_one) {
// 		a->size += 4;
// 	}
// 	return a->registry->size_fn(a);
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).