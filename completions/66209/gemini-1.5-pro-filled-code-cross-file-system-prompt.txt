bitint *ys_int, *ys_int_begin, *ys_int_end;
  bitint mask_first, mask_last;
  long i, j;

  if (m > n) return -1;

  /* Precompute the masks for the first and last characters. */
  mask_first = (bitint)xs[0] ^ MASK2;
  mask_last = (bitint)xs[m - 1] ^ MASK2;

  ys_int_begin = (bitint *)ys;
  ys_int_end = (bitint *)(ys + n - m + 1);

  for (ys_int = ys_int_begin; ys_int < ys_int_end; ++ys_int) {
    bitint mask;

    /* Check equality for the first character. */
    mask = (*ys_int) ^ (mask_first * MASK1);
    mask &= MASK3;
    if (mask) {
      /* Skip to the next word if the first character doesn't match. */
#ifdef MRB_ENDIAN_BIG
      ys_int += (mask & MASK4) >> (sizeof(bitint) * CHAR_BIT - 1);
#else
      ys_int += (mask & MASK4) >> 7;
#endif
      continue;
    }

    /* Check equality for the last character. */
    i = (long)((const unsigned char *)ys_int - ys);
    mask = (*(ys_int + (m - 1) / sizeof(bitint))) ^ (mask_last * MASK1);
    mask = (mask >> ((m - 1) % sizeof(bitint)) * CHAR_BIT) & 0xff;
    mask &= MASK3;
    if (mask) continue;

    /* Compare the rest of the substring. */
    for (j = 1; j < m - 1; ++j) {
      if (xs[j] != ys[i + j]) break;
    }
    if (j == m - 1) {
      return i;
    }
  }