TRACE_SERIALIZE (this);

    /* Sanity-check inputs */
    if (unlikely (!src || !src->axisCount || regionmapping.is_empty ()))
      return_trace (false);

    /* Allocate VarRegionList header (axisCount + regionCount) */
    VarRegionList *dest = c->extend_min (*this);
    if (unlikely (dest == nullptr))
      return_trace (false);

    dest->axisCount   = src->axisCount;
    dest->regionCount = regionmapping.get_dst_count ();

    /* Calculate total size for all VarRegion records that need to be copied. Each
     * VarRegion record is axisCount * VarRegionAxis::static_size bytes.  */
    unsigned int var_region_size =
	      VarRegion::static_size (dest->axisCount) * dest->regionCount;

    /* Reserve space for VarRegion array */
    VarRegion *d_regions = c->allocate_size<VarRegion> (var_region_size);
    if (unlikely (d_regions == nullptr))
      return_trace (false);

    /* Iterate over mapping; for every destination region index locate the
     * corresponding source region index and copy its VarRegion record. */
    for (unsigned int dst_idx = 0; dst_idx < dest->regionCount; ++dst_idx)
    {
      unsigned int src_idx = regionmapping[dst_idx]; /* map dest â†’ src */
      if (unlikely (src_idx >= src->regionCount))
	return_trace (false);

      const VarRegion *src_region = &src->regions (src->axisCount)[src_idx];
      VarRegion       *dst_region = (VarRegion*)
				    ((char*)d_regions +
				     VarRegion::static_size (dest->axisCount) * dst_idx);

      memcpy (dst_region,
	      src_region,
	      VarRegion::static_size (dest->axisCount));
    }

    return_trace (true);