if (inputStream == NULL) {
        xmlFreeParserInputBuffer(buf);
        return(NULL);
    }

    URI = xmlBuildURI((const char *) filename, &directory);
    if (URI == NULL) {
        xmlFreeParserInputBuffer(buf);
        xmlFree(directory);
        return(NULL);
    }

    inputStream->filename = (char *) URI;
    if (directory != NULL) {
        inputStream->directory = directory;
    } else {
        inputStream->directory = xmlStrdup((xmlChar *) ".");
    }

    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromFd:
 * @ctxt:  an XML parser context
 * @fd:  the file descriptor
 *
 * Create a new input stream based on a file descriptor.
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromFd(xmlParserCtxtPtr ctxt, int fd) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		"new input from fd: %d\n", fd);
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
    if (buf == NULL) {
        xmlErrMemory(ctxt, "couldn't allocate a new input stream\n");
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
        xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromMem:
 * @ctxt:  an XML parser context
 * @buffer:  the memory buffer
 * @size:  the size of the buffer
 *
 * Create a new input stream based on a memory buffer.
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromMem(xmlParserCtxtPtr ctxt, const char *buffer, int size) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		"new input from mem: %.30s\n", buffer);
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
    if (buf == NULL) {
        xmlErrMemory(ctxt, "couldn't allocate a new input stream\n");
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
        xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlNewInputFromIO:
 * @ctxt:  an XML parser context
 * @ioread:  the read callback
 * @ioclose:  the close callback
 * @ioinfo:  the user data
 *
 * Create a new input stream based on a custom I/O callback.
 *
 * Returns the new input stream or NULL in case of error
 */
xmlParserInputPtr
xmlNewInputFromIO(xmlParserCtxtPtr ctxt,
                   xmlInputReadCallback ioread,
                   xmlInputCloseCallback ioclose,
                   void *ioinfo) {
    xmlParserInputBufferPtr buf;
    xmlParserInputPtr inputStream;

    if (xmlParserDebugEntities)
	xmlGenericError(xmlGenericErrorContext,
		"new input from I/O callback\n");
    if (ctxt == NULL) return(NULL);
    buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioinfo,
                                       XML_CHAR_ENCODING_NONE);
    if (buf == NULL) {
        xmlErrMemory(ctxt, "couldn't allocate a new input stream\n");
	return(NULL);
    }

    inputStream = xmlNewInputStream(ctxt);
    if (inputStream == NULL) {
        xmlFreeParserInputBuffer(buf);
	return(NULL);
    }

    inputStream->buf = buf;
    xmlBufResetInput(inputStream->buf->buffer, inputStream);
    return(inputStream);
}

/**
 * xmlFreeParserInputBuffer:
 * @buf:  the input buffer
 *
 * Free up an input buffer.
 */
void
xmlFreeParserInputBuffer(xmlParserInputBufferPtr buf) {
    if (buf == NULL) return;
    if (buf->buffer != NULL) xmlBufFree(buf->buffer);
    if (buf->encoder != NULL) xmlCharEncCloseFunc(buf->encoder);
    xmlFree(buf);
}

/**
 * xmlParserInputBufferCreateFilename:
 * @filename:  the filename to use as entity
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer based on a file or an URL.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateFilename(const char *filename,
                                   xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreate();
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = xmlFileRead;
    buf->closecallback = xmlFileClose;
    buf->ioread = xmlFileRead;
    buf->ioclose = xmlFileClose;
    buf->ioinfo = (void *) filename;

    return(buf);
}

/**
 * xmlParserInputBufferCreateFd:
 * @fd:  the file descriptor
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer based on a file descriptor.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateFd(int fd, xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreate();
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = xmlFdRead;
    buf->closecallback = xmlFdClose;
    buf->ioread = xmlFdRead;
    buf->ioclose = xmlFdClose;
    buf->ioinfo = (void *) (intptr_t) fd;

    return(buf);
}

/**
 * xmlParserInputBufferCreateMem:
 * @buffer:  the memory buffer
 * @size:  the size of the buffer
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer based on a memory buffer.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateMem(const char *buffer, int size,
                              xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreateStatic((xmlChar *) buffer, size);
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = NULL;
    buf->closecallback = NULL;
    buf->ioread = NULL;
    buf->ioclose = NULL;
    buf->ioinfo = NULL;

    return(buf);
}

/**
 * xmlParserInputBufferCreateString:
 * @buffer:  the memory buffer
 *
 * Create a new input buffer based on a string buffer.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateString(const xmlChar *buffer) {
    xmlParserInputBufferPtr buf;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    buf->buffer = xmlBufCreateStatic(buffer, xmlStrlen(buffer));
    if (buf->buffer == NULL) {
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = NULL;
    buf->readcallback = NULL;
    buf->closecallback = NULL;
    buf->ioread = NULL;
    buf->ioclose = NULL;
    buf->ioinfo = NULL;

    return(buf);
}

/**
 * xmlParserInputBufferCreateIO:
 * @ioread:  the read callback
 * @ioclose:  the close callback
 * @ioinfo:  the user data
 * @encoding:  the charset encoding if known
 *
 * Create a new input buffer based on a custom I/O callback.
 *
 * Returns the new input buffer or NULL
 */
xmlParserInputBufferPtr
xmlParserInputBufferCreateIO(xmlInputReadCallback ioread,
                             xmlInputCloseCallback ioclose,
                             void *ioinfo, xmlCharEncoding encoding) {
    xmlParserInputBufferPtr buf;
    xmlCharEncodingHandlerPtr handler;
    int res;

    buf = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
    if (buf == NULL) {
        xmlErrMemory(NULL, "couldn't allocate a new input buffer\n");
        return(NULL);
    }
    memset(buf, 0, sizeof(xmlParserInputBuffer));

    res = xmlLookupCharEncodingHandler(encoding, &handler);
    if (res != 0) {
        xmlFree(buf);
        return(NULL);
    }

    buf->buffer = xmlBufCreate();
    if (buf->buffer == NULL) {
        xmlCharEncCloseFunc(handler);
        xmlFree(buf);
        return(NULL);
    }

    buf->encoder = handler;
    buf->readcallback = ioread;
    buf->closecallback = ioclose;
    buf->ioread = ioread;
    buf->ioclose = ioclose;
    buf->ioinfo = ioinfo;

    return(buf);
}

/**
 * xmlParserInputBufferGrow:
 * @buf:  the input buffer
 * @len:  the length to grow
 *
 * Grow the input buffer.
 *
 * Returns the number of bytes read or -1 in case of error
 */
int
xmlParserInputBufferGrow(xmlParserInputBufferPtr buf, int len) {
    int ret;

    if (buf == NULL)
        return(-1);
    if (buf->error != 0)