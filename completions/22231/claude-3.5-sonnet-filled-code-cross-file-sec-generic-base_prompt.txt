Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
int cram_decode_slice(cram_fd *fd, cram_container *c, cram_slice *s,
                      sam_hdr_t *sh) {
    cram_block *blk = s->block[0];
    int32_t bf, ref_id;
    unsigned char cf;
    int out_sz, r = 0;
    int rec;
    char *seq = NULL, *qual = NULL;
    int unknown_rg = -1;
    int embed_ref;
    char **refs = NULL;
    uint32_t ds;
    sam_hrecs_t *bfd = sh->hrecs;

    if (cram_dependent_data_series(fd, c->comp_hdr, s) != 0)
        return -1;

    ds = s->data_series;

    blk->bit = 7; // MSB first

    // Study the blocks and estimate approx sizes to preallocate.
    // This looks to speed up decoding by around 8-9%.
    // We can always shrink back down at the end if we overestimated.
    // However it's likely that this also saves memory as own growth
    // factor (*=1.5) is never applied.
    {
        int qsize, nsize, q_id;
        cram_decode_estimate_sizes(c->comp_hdr, s, &qsize, &nsize, &q_id);
        //fprintf(stderr, "qsize=%d nsize=%d\n", qsize, nsize);

        if (qsize && (ds & CRAM_RL)) BLOCK_RESIZE_EXACT(s->seqs_blk, qsize+1);
        if (qsize && (ds & CRAM_RL)) BLOCK_RESIZE_EXACT(s->qual_blk, qsize+1);
        if (nsize && (ds & CRAM_NS)) BLOCK_RESIZE_EXACT(s->name_blk, nsize+1);

        // To do - consider using q_id here to usurp the quality block and
        // avoid a memcpy during decode.
        // Specifically when quality is an external block uniquely used by
        // DS_QS only, then we can set s->qual_blk directly to this
        // block and save the codec->decode() calls. (Approx 3% cpu saving)
    }

    /* Look for unknown RG, added as last by Java CRAM? */
    if (bfd->nrg > 0 &&
        bfd->rg[bfd->nrg-1].name != NULL &&
        !strcmp(bfd->rg[bfd->nrg-1].name, "UNKNOWN"))
        unknown_rg = bfd->nrg-1;

    if (blk->content_type != CORE)
        return -1;

    if (s->crecs)
        free(s->crecs);
    if (!(s->crecs = malloc(s->hdr->num_records * sizeof(*s->crecs))))
        return -1;

    ref_id = s->hdr->ref_seq_id;
    embed_ref = s->hdr->ref_base_id >= 0 ? 1 : 0;

    if (ref_id >= 0) {
        if (embed_ref) {
            cram_block *b;
            if (s->hdr->ref_base_id < 0) {
                hts_log_error("No reference specified and no embedded reference is available"
                              " at #%d:%"PRId64"-%"PRId64, ref_id, s->hdr->ref_seq_start,
                              s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
                return -1;
            }
            b = cram_get_block_by_id(s, s->hdr->ref_base_id);
            if (!b)
                return -1;
            if (cram_uncompress_block(b) != 0)
                return -1;
            // Assign the decompressed data from the block as the reference sequence for the slice.
            // Set the start and end positions of this reference sequence based on the slice header.
            // Check if the embedded reference is smaller than expected by comparing the slice's reference
            // span with the decompressed block size. Log an error and return -1 if the reference is too small.
            // <MASK>
        } else if (!c->comp_hdr->no_ref) {
            //// Avoid Java cramtools bug by loading entire reference seq
            //s->ref = cram_get_ref(fd, s->hdr->ref_seq_id, 1, 0);
            //s->ref_start = 1;

            if (fd->required_fields & SAM_SEQ) {
                s->ref =
                cram_get_ref(fd, s->hdr->ref_seq_id,
                             s->hdr->ref_seq_start,
                             s->hdr->ref_seq_start + s->hdr->ref_seq_span -1);
            }
            s->ref_start = s->hdr->ref_seq_start;
            s->ref_end   = s->hdr->ref_seq_start + s->hdr->ref_seq_span-1;

            /* Sanity check */
            if (s->ref_start < 0) {
                hts_log_warning("Slice starts before base 1"
                                " at #%d:%"PRId64"-%"PRId64, ref_id, s->hdr->ref_seq_start,
                                s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
                s->ref_start = 0;
            }
            pthread_mutex_lock(&fd->ref_lock);
            pthread_mutex_lock(&fd->refs->lock);
            if ((fd->required_fields & SAM_SEQ) &&
                ref_id < fd->refs->nref &&
                s->ref_end > fd->refs->ref_id[ref_id]->length) {
                s->ref_end = fd->refs->ref_id[ref_id]->length;
            }
            pthread_mutex_unlock(&fd->refs->lock);
            pthread_mutex_unlock(&fd->ref_lock);
        }
    }

    if ((fd->required_fields & SAM_SEQ) &&
        s->ref == NULL && s->hdr->ref_seq_id >= 0 && !c->comp_hdr->no_ref) {
        hts_log_error("Unable to fetch reference #%d:%"PRId64"-%"PRId64"\n",
                      ref_id, s->hdr->ref_seq_start,
                      s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
        return -1;
    }

    if (CRAM_MAJOR_VERS(fd->version) != 1
        && (fd->required_fields & SAM_SEQ)
        && s->hdr->ref_seq_id >= 0
        && !fd->ignore_md5
        && memcmp(s->hdr->md5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16)) {
        hts_md5_context *md5;
        unsigned char digest[16];

        if (s->ref && s->hdr->ref_seq_id >= 0) {
            int start, len;

            if (s->hdr->ref_seq_start >= s->ref_start) {
                start = s->hdr->ref_seq_start - s->ref_start;
            } else {
                hts_log_warning("Slice starts before base 1 at #%d:%d-%d",
                                ref_id, s->ref_start, s->ref_end);
                start = 0;
            }

            if (s->hdr->ref_seq_span <= s->ref_end - s->ref_start + 1) {
                len = s->hdr->ref_seq_span;
            } else {
                hts_log_warning("Slice ends beyond reference end at #%d:%d-%d",
                                ref_id, s->ref_start, s->ref_end);
                len = s->ref_end - s->ref_start + 1;
            }

            if (!(md5 = hts_md5_init()))
                return -1;
            if (start + len > s->ref_end - s->ref_start + 1)
                len = s->ref_end - s->ref_start + 1 - start;
            if (len >= 0)
                hts_md5_update(md5, s->ref + start, len);
            hts_md5_final(digest, md5);
            hts_md5_destroy(md5);
        } else if (!s->ref && s->hdr->ref_base_id >= 0) {
            cram_block *b = cram_get_block_by_id(s, s->hdr->ref_base_id);
            if (b) {
                if (!(md5 = hts_md5_init()))
                    return -1;
                hts_md5_update(md5, b->data, b->uncomp_size);
                hts_md5_final(digest, md5);
                hts_md5_destroy(md5);
            }
        }

        if ((!s->ref && s->hdr->ref_base_id < 0)
            || memcmp(digest, s->hdr->md5, 16) != 0) {
            char M[33];
            hts_log_error("MD5 checksum reference mismatch at #%d:%d-%d",
                          ref_id, s->ref_start, s->ref_end);
            hts_log_error("CRAM: %s", md5_print(s->hdr->md5, M));
            hts_log_error("Ref : %s", md5_print(digest, M));
            return -1;
        }
    }

    if (ref_id == -2) {
        pthread_mutex_lock(&fd->ref_lock);
        pthread_mutex_lock(&fd->refs->lock);
        refs = calloc(fd->refs->nref, sizeof(char *));
        pthread_mutex_unlock(&fd->refs->lock);
        pthread_mutex_unlock(&fd->ref_lock);
        if (!refs)
            return -1;
    }

    int last_ref_id = -9; // Arbitrary -ve marker for not-yet-set
    for (rec = 0; rec < s->hdr->num_records; rec++) {
        cram_record *cr = &s->crecs[rec];
        int has_MD, has_NM;

        //fprintf(stderr, "Decode seq %d, %d/%d\n", rec, blk->byte, blk->bit);

        cr->s = s;

        out_sz = 1; /* decode 1 item */
        if (ds & CRAM_BF) {
            if (!c->comp_hdr->codecs[DS_BF]) goto block_err;
            r |= c->comp_hdr->codecs[DS_BF]
                            ->decode(s, c->comp_hdr->codecs[DS_BF], blk,
                                     (char *)&bf, &out_sz);
            if (r || bf < 0 ||
                bf >= sizeof(fd->bam_flag_swap)/sizeof(*fd->bam_flag_swap))
                goto block_err;
            bf = fd->bam_flag_swap[bf];
            cr->flags = bf;
        } else {
            cr->flags = bf = 0x4; // unmapped
        }

        if (ds & CRAM_CF) {
            if (CRAM_MAJOR_VERS(fd->version) == 1) {
                /* CF is byte in 1.0, int32 in 2.0 */
                if (!c->comp_hdr->codecs[DS_CF]) goto block_err;
                r |= c->comp_hdr->codecs[DS_CF]
                                ->decode(s, c->comp_hdr->codecs[DS_CF], blk,
                                         (char *)&cf, &out_sz);
                if (r) goto block_err;
                cr->cram_flags = cf;
            } else {
                if (!c->comp_hdr->codecs[DS_CF]) goto block_err;
                r |= c->comp_hdr->codecs[DS_CF]
                                ->decode(s, c->comp_hdr->codecs[DS_CF], blk,
                                         (char *)&cr->cram_flags, &out_sz);
                if (r) goto block_err;
                cf = cr->cram_flags;
            }
        } else {
            cf = cr->cram_flags = 0;
        }

        if (CRAM_MAJOR_VERS(fd->version) != 1 && ref_id == -2) {
            if (ds & CRAM_RI) {
                if (!c->comp_hdr->codecs[DS_RI]) goto block_err;
                r |= c->comp_hdr->codecs[DS_RI]
                                ->decode(s, c->comp_hdr->codecs[DS_RI], blk,
                                         (char *)&cr->ref_id, &out_sz);
                if (r) goto block_err;
                if ((fd->required_fields & (SAM_SEQ|SAM_TLEN))
                    && cr->ref_id >= 0
                    && cr->ref_id != last_ref_id) {
                    if (!c->comp_hdr->no_ref) {
                        // Range(fd):  seq >= 0, unmapped -1, unspecified   -2
                        // Slice(s):   seq >= 0, unmapped -1, multiple refs -2
                        // Record(cr): seq >= 0, unmapped -1
                        pthread_mutex_lock(&fd->range_lock);
                        int need_ref = (fd->range.refid == -2 || cr->ref_id == fd->range.refid);
                        pthread_mutex_unlock(&fd->range_lock);
                        if  (need_ref) {
                            if (!refs[cr->ref_id])
                                refs[cr->ref_id] = cram_get_ref(fd, cr->ref_id, 1, 0);
                            if (!(s->ref = refs[cr->ref_id]))
                                goto block_err;
                        } else {
                            // For multi-ref containers, we don't need to fetch all
                            // refs if we're only querying one.
                            s->ref = NULL;
                        }

                        pthread_mutex_lock(&fd->range_lock);
                        int discard_last_ref = (last_ref_id >= 0 &&
                                                refs[last_ref_id] &&
                                                (fd->range.refid == -2 ||
                                                 last_ref_id == fd->range.refid));
                        pthread_mutex_unlock(&fd->range_lock);
                        if (discard_last_ref) {
                            pthread_mutex_lock(&fd->ref_lock);
                            discard_last_ref = !fd->unsorted;
                            pthread_mutex_unlock(&fd->ref_lock);
                        }
                        if (discard_last_ref) {
                            cram_ref_decr(fd->refs, last_ref_id);
                            refs[last_ref_id] = NULL;
                        }
                    }
                    s->ref_start = 1;
                    pthread_mutex_lock(&fd->ref_lock);
                    pthread_mutex_lock(&fd->refs->lock);
                    s->ref_end = fd->refs->ref_id[cr->ref_id]->length;
                    pthread_mutex_unlock(&fd->refs->lock);
                    pthread_mutex_unlock(&fd->ref_lock);

                    last_ref_id = cr->ref_id;
                }
            } else {
                cr->ref_id = -1;
            }
        } else {
            cr->ref_id = ref_id; // Forced constant in CRAM 1.0
        }
        if (cr->ref_id < -1 || cr->ref_id >= bfd->nref) {
            hts_log_error("Requested unknown reference ID %d", cr->ref_id);
            goto block_err;
        }

        if (ds & CRAM_RL) {
            if (!c->comp_hdr->codecs[DS_RL]) goto block_err;
            r |= c->comp_hdr->codecs[DS_RL]
                            ->decode(s, c->comp_hdr->codecs[DS_RL], blk,
                                     (char *)&cr->len, &out_sz);
            if (r) goto block_err;
            if (cr->len < 0) {
                hts_log_error("Read has negative length");
                goto block_err;
            }
        }

        if (ds & CRAM_AP) {
            if (!c->comp_hdr->codecs[DS_AP]) goto block_err;
#ifdef LARGE_POS
            r |= c->comp_hdr->codecs[DS_AP]
                            ->decode(s, c->comp_hdr->codecs[DS_AP], blk,
                                     (char *)&cr->apos, &out_sz);
#else
            int32_t i32;
            r |= c->comp_hdr->codecs[DS_AP]
                            ->decode(s, c->comp_hdr->codecs[DS_AP], blk,
                                     (char *)&i32, &out_sz);
            cr->apos = i32;
#endif
            if (r) goto block_err;
            if (c->comp_hdr->AP_delta)
                cr->apos += s->last_apos;
            s->last_apos=  cr->apos;
        } else {
            cr->apos = c->ref_seq_start;
        }

        if (ds & CRAM_RG) {
            if (!c->comp_hdr->codecs[DS_RG]) goto block_err;
            r |= c->comp_hdr->codecs[DS_RG]
                           ->decode(s, c->comp_hdr->codecs[DS_RG], blk,
                                    (char *)&cr->rg, &out_sz);
            if (r) goto block_err;
            if (cr->rg == unknown_rg)
                cr->rg = -1;
        } else {
            cr->rg = -1;
        }

        cr->name_len = 0;

        if (c->comp_hdr->read_names_included) {
            int32_t out_sz2 = 1;

            // Read directly into name cram_block
            cr->name = BLOCK_SIZE(s->name_blk);
            if (ds & CRAM_RN) {
                if (!c->comp_hdr->codecs[DS_RN]) goto block_err;
                r |= c->comp_hdr->codecs[DS_RN]
                                ->decode(s, c->comp_hdr->codecs[DS_RN], blk,
                                         (char *)s->name_blk, &out_sz2);
                if (r) goto block_err;
                cr->name_len = out_sz2;
            }
        }

        cr->mate_pos = 0;
        cr->mate_line = -1;
        cr->mate_ref_id = -1;
        if ((ds & CRAM_CF) && (cf & CRAM_FLAG_DETACHED)) {
            if (ds & CRAM_MF) {
                if (CRAM_MAJOR_VERS(fd->version) == 1) {
                    /* MF is byte in 1.0, int32 in 2.0 */
                    unsigned char mf;
                    if (!c->comp_hdr->codecs[DS_MF]) goto block_err;
                    r |= c->comp_hdr->codecs[DS_MF]
                                    ->decode(s, c->comp_hdr->codecs[DS_MF],
                                             blk, (char *)&mf, &out_sz);
                    if (r) goto block_err;
                    cr->mate_flags = mf;
                } else {
                    if (!c->comp_hdr->codecs[DS_MF]) goto block_err;
                    r |= c->comp_hdr->codecs[DS_MF]
                                    ->decode(s, c->comp_hdr->codecs[DS_MF],
                                             blk,
                                             (char *)&cr->mate_flags,
                                             &out_sz);
                    if (r) goto block_err;
                }
            } else {
                cr->mate_flags = 0;
            }

            if (!c->comp_hdr->read_names_included) {
                int32_t out_sz2 = 1;

                // Read directly into name cram_block
                cr->name = BLOCK_SIZE(s->name_blk);
                if (ds & CRAM_RN) {
                    if (!c->comp_hdr->codecs[DS_RN]) goto block_err;
                    r |= c->comp_hdr->codecs[DS_RN]
                                    ->decode(s, c->comp_hdr->codecs[DS_RN],
                                             blk, (char *)s->name_blk,
                                             &out_sz2);
                    if (r) goto block_err;
                    cr->name_len = out_sz2;
                }
            }

            if (ds & CRAM_NS) {
                if (!c->comp_hdr->codecs[DS_NS]) goto block_err;
                r |= c->comp_hdr->codecs[DS_NS]
                                ->decode(s, c->comp_hdr->codecs[DS_NS], blk,
                                         (char *)&cr->mate_ref_id, &out_sz);
                if (r) goto block_err;
            }

            // Skip as mate_ref of "*" is legit. It doesn't mean unmapped, just unknown.
            // if (cr->mate_ref_id == -1 && cr->flags & 0x01) {
            //     /* Paired, but unmapped */
            //     cr->flags |= BAM_FMUNMAP;
            // }

            if (ds & CRAM_NP) {
                if (!c->comp_hdr->codecs[DS_NP]) goto block_err;
#ifdef LARGE_POS
                r |= c->comp_hdr->codecs[DS_NP]
                                ->decode(s, c->comp_hdr->codecs[DS_NP], blk,
                                         (char *)&cr->mate_pos, &out_sz);
#else
                int32_t i32;
                r |= c->comp_hdr->codecs[DS_NP]
                                ->decode(s, c->comp_hdr->codecs[DS_NP], blk,
                                         (char *)&i32, &out_sz);
                cr->mate_pos = i32;
#endif
                if (r) goto block_err;
            }

            if (ds & CRAM_TS) {
                if (!c->comp_hdr->codecs[DS_TS]) goto block_err;
#ifdef LARGE_POS
                r |= c->comp_hdr->codecs[DS_TS]
                                ->decode(s, c->comp_hdr->codecs[DS_TS], blk,
                                         (char *)&cr->tlen, &out_sz);
#else
                int32_t i32;
                r |= c->comp_hdr->codecs[DS_TS]
                                ->decode(s, c->comp_hdr->codecs[DS_TS], blk,
                                         (char *)&i32, &out_sz);
                cr->tlen = i32;
#endif
                if (r) goto block_err;
            } else {
                cr->tlen = INT_MIN;
            }
        } else if ((ds & CRAM_CF) && (cf & CRAM_FLAG_MATE_DOWNSTREAM)) {
            if (ds & CRAM_NF) {
                if (!c->comp_hdr->codecs[DS_NF]) goto block_err;
                r |= c->comp_hdr->codecs[DS_NF]
                                ->decode(s, c->comp_hdr->codecs[DS_NF], blk,
                                         (char *)&cr->mate_line, &out_sz);
                if (r) goto block_err;
                cr->mate_line += rec + 1;

                //cr->name_len = sprintf(name, "%d", name_id++);
                //cr->name = DSTRING_LEN(name_ds);
                //dstring_nappend(name_ds, name, cr->name_len);

                cr->mate_ref_id = -1;
                cr->tlen = INT_MIN;
                cr->mate_pos = 0;
            } else  {
                cr->mate_flags = 0;
                cr->tlen = INT_MIN;
            }
        } else {
            cr->mate_flags = 0;
            cr->tlen = INT_MIN;
        }
        /*
        else if (!name[0]) {
            //name[0] = '?'; name[1] = 0;
            //cr->name_len = 1;
            //cr->name=  DSTRING_LEN(s->name_ds);
            //dstring_nappend(s->name_ds, "?", 1);

            cr->mate_ref_id = -1;
            cr->tlen = 0;
            cr->mate_pos = 0;
        }
        */

        /* Auxiliary tags */
        has_MD = has_NM = 0;
        if (CRAM_MAJOR_VERS(fd->version) == 1)
            r |= cram_decode_aux_1_0(c, s, blk, cr);
        else
            r |= cram_decode_aux(c, s, blk, cr, &has_MD, &has_NM);
        if (r) goto block_err;

        /* Fake up dynamic string growth and appending */
        if (ds & CRAM_RL) {
            cr->seq = BLOCK_SIZE(s->seqs_blk);
            BLOCK_GROW(s->seqs_blk, cr->len);
            seq = (char *)BLOCK_END(s->seqs_blk);
            BLOCK_SIZE(s->seqs_blk) += cr->len;

            if (!seq)
                goto block_err;

            cr->qual = BLOCK_SIZE(s->qual_blk);
            BLOCK_GROW(s->qual_blk, cr->len);
            qual = (char *)BLOCK_END(s->qual_blk);
            BLOCK_SIZE(s->qual_blk) += cr->len;

            if (!s->ref)
                memset(seq, '=', cr->len);
        }

        if (!(bf & BAM_FUNMAP)) {
            if ((ds & CRAM_AP) && cr->apos <= 0) {
                hts_log_error("Read has alignment position %"PRId64
                              " but no unmapped flag",
                              cr->apos);
                goto block_err;
            }
            /* Decode sequence and generate CIGAR */
            if (ds & (CRAM_SEQ | CRAM_MQ)) {
                r |= cram_decode_seq(fd, c, s, blk, cr, sh, cf, seq, qual,
                                     has_MD, has_NM);
                if (r) goto block_err;
            } else {
                cr->cigar = 0;
                cr->ncigar = 0;
                cr->aend = cr->apos;
                cr->mqual = 0;
            }
        } else {
            int out_sz2 = cr->len;

            //puts("Unmapped");
            cr->cigar = 0;
            cr->ncigar = 0;
            cr->aend = cr->apos;
            cr->mqual = 0;

            if (ds & CRAM_BA && cr->len) {
                if (!c->comp_hdr->codecs[DS_BA]) goto block_err;
                r |= c->comp_hdr->codecs[DS_BA]
                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
                                         (char *)seq, &out_sz2);
                if (r) goto block_err;
            }

            if ((ds & CRAM_CF) && (cf & CRAM_FLAG_PRESERVE_QUAL_SCORES)) {
                out_sz2 = cr->len;
                if (ds & CRAM_QS && cr->len >= 0) {
                    if (!c->comp_hdr->codecs[DS_QS]) goto block_err;
                    r |= c->comp_hdr->codecs[DS_QS]
                                    ->decode(s, c->comp_hdr->codecs[DS_QS],
                                             blk, qual, &out_sz2);
                    if (r) goto block_err;
                }
            } else {
                if (ds & CRAM_RL)
                    memset(qual, 255, cr->len);
            }
        }
    }

    pthread_mutex_lock(&fd->ref_lock);
    if (refs) {
        int i;
        for (i = 0; i < fd->refs->nref; i++) {
            if (refs[i])
                cram_ref_decr(fd->refs, i);
        }
        free(refs);
        refs = NULL;
    } else if (ref_id >= 0 && s->ref != fd->ref_free && !embed_ref) {
        cram_ref_decr(fd->refs, ref_id);
    }
    pthread_mutex_unlock(&fd->ref_lock);

    /* Resolve mate pair cross-references between recs within this slice */
    r |= cram_decode_slice_xref(s, fd->required_fields);

    // Free the original blocks as we no longer need these.
    {
        int i;
        for (i = 0; i < s->hdr->num_blocks; i++) {
            cram_block *b = s->block[i];
            cram_free_block(b);
            s->block[i] = NULL;
        }
    }

    // Also see initial BLOCK_RESIZE_EXACT at top of function.
    // As we grow blocks we overallocate by up to 50%. So shrink
    // back to their final sizes here.
    //
    //fprintf(stderr, "%d %d // %d %d // %d %d // %d %d\n",
    //      (int)s->seqs_blk->byte, (int)s->seqs_blk->alloc,
    //      (int)s->qual_blk->byte, (int)s->qual_blk->alloc,
    //      (int)s->name_blk->byte, (int)s->name_blk->alloc,
    //      (int)s->aux_blk->byte,  (int)s->aux_blk->alloc);
    BLOCK_RESIZE_EXACT(s->seqs_blk, BLOCK_SIZE(s->seqs_blk)+1);
    BLOCK_RESIZE_EXACT(s->qual_blk, BLOCK_SIZE(s->qual_blk)+1);
    BLOCK_RESIZE_EXACT(s->name_blk, BLOCK_SIZE(s->name_blk)+1);
    BLOCK_RESIZE_EXACT(s->aux_blk,  BLOCK_SIZE(s->aux_blk)+1);

    return r;

 block_err:
    if (refs) {
        int i;
        pthread_mutex_lock(&fd->ref_lock);
        for (i = 0; i < fd->refs->nref; i++) {
            if (refs[i])
                cram_ref_decr(fd->refs, i);
        }
        free(refs);
        pthread_mutex_unlock(&fd->ref_lock);
    }

    return -1;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// cram/cram_decode.c
// static cram_map *map_find(cram_map **map, unsigned char *key, int id) {
//     cram_map *m;
// 
//     m = map[CRAM_MAP(key[0],key[1])];
//     while (m && m->key != id)
//         m= m->next;
// 
//     return m;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// static int cram_decode_slice_xref(cram_slice *s, int required_fields) {
//     int rec;
// 
//     if (!(required_fields & (SAM_RNEXT | SAM_PNEXT | SAM_TLEN))) {
//         for (rec = 0; rec < s->hdr->num_records; rec++) {
//             cram_record *cr = &s->crecs[rec];
// 
//             cr->tlen = 0;
//             cr->mate_pos = 0;
//             cr->mate_ref_id = -1;
//         }
// 
//         return 0;
//     }
// 
//     for (rec = 0; rec < s->hdr->num_records; rec++) {
//         cram_record *cr = &s->crecs[rec];
// 
//         if (cr->mate_line >= 0) {
//             if (cr->mate_line < s->hdr->num_records) {
//                 /*
//                  * On the first read, loop through computing lengths.
//                  * It's not perfect as we have one slice per reference so we
//                  * cannot detect when TLEN should be zero due to seqs that
//                  * map to multiple references.
//                  *
//                  * We also cannot set tlen correct when it spans a slice for
//                  * other reasons. This may make tlen too small. Should we
//                  * fix this by forcing TLEN to be stored verbatim in such cases?
//                  *
//                  * Or do we just admit defeat and output 0 for tlen? It's the
//                  * safe option...
//                  */
//                 if (cr->tlen == INT_MIN) {
//                     int id1 = rec, id2 = rec;
//                     int64_t aleft = cr->apos, aright = cr->aend;
//                     int64_t tlen;
//                     int ref = cr->ref_id;
// 
//                     // number of segments starting at the same point.
//                     int left_cnt = 0;
// 
//                     do {
//                         if (aleft > s->crecs[id2].apos)
//                             aleft = s->crecs[id2].apos, left_cnt = 1;
//                         else if (aleft == s->crecs[id2].apos)
//                             left_cnt++;
//                         if (aright < s->crecs[id2].aend)
//                             aright = s->crecs[id2].aend;
//                         if (s->crecs[id2].mate_line == -1) {
//                             s->crecs[id2].mate_line = rec;
//                             break;
//                         }
//                         if (s->crecs[id2].mate_line <= id2 ||
//                             s->crecs[id2].mate_line >= s->hdr->num_records)
//                             return -1;
//                         id2 = s->crecs[id2].mate_line;
// 
//                         if (s->crecs[id2].ref_id != ref)
//                             ref = -1;
//                     } while (id2 != id1);
// 
//                     if (ref != -1) {
//                         tlen = aright - aleft + 1;
//                         id1 = id2 = rec;
// 
//                         /*
//                          * When we have two seqs with identical start and
//                          * end coordinates, set +/- tlen based on 1st/last
//                          * bit flags instead, as a tie breaker.
//                          */
//                         if (s->crecs[id2].apos == aleft) {
//                             if (left_cnt == 1 ||
//                                 (s->crecs[id2].flags & BAM_FREAD1))
//                                 s->crecs[id2].tlen = tlen;
//                             else
//                                 s->crecs[id2].tlen = -tlen;
//                         } else {
//                             s->crecs[id2].tlen = -tlen;
//                         }
// 
//                         id2 = s->crecs[id2].mate_line;
//                         while (id2 != id1) {
//                             if (s->crecs[id2].apos == aleft) {
//                                 if (left_cnt == 1 ||
//                                     (s->crecs[id2].flags & BAM_FREAD1))
//                                     s->crecs[id2].tlen = tlen;
//                                 else
//                                     s->crecs[id2].tlen = -tlen;
//                             } else {
//                                 s->crecs[id2].tlen = -tlen;
//                             }
//                             id2 = s->crecs[id2].mate_line;
//                         }
//                     } else {
//                         id1 = id2 = rec;
// 
//                         s->crecs[id2].tlen = 0;
//                         id2 = s->crecs[id2].mate_line;
//                         while (id2 != id1) {
//                             s->crecs[id2].tlen = 0;
//                             id2 = s->crecs[id2].mate_line;
//                         }
//                     }
//                 }
// 
//                 cr->mate_pos = s->crecs[cr->mate_line].apos;
//                 cr->mate_ref_id = s->crecs[cr->mate_line].ref_id;
// 
//                 // paired
//                 cr->flags |= BAM_FPAIRED;
// 
//                 // set mate unmapped if needed
//                 if (s->crecs[cr->mate_line].flags & BAM_FUNMAP) {
//                     cr->flags |= BAM_FMUNMAP;
//                     cr->tlen = 0;
//                 }
//                 if (cr->flags & BAM_FUNMAP) {
//                     cr->tlen = 0;
//                 }
// 
//                 // set mate reversed if needed
//                 if (s->crecs[cr->mate_line].flags & BAM_FREVERSE)
//                     cr->flags |= BAM_FMREVERSE;
//             } else {
//                 hts_log_error("Mate line out of bounds: %d vs [0, %d]",
//                               cr->mate_line, s->hdr->num_records-1);
//             }
// 
//             /* FIXME: construct read names here too if needed */
//         } else {
//             if (cr->mate_flags & CRAM_M_REVERSE) {
//                 cr->flags |= BAM_FPAIRED | BAM_FMREVERSE;
//             }
//             if (cr->mate_flags & CRAM_M_UNMAP) {
//                 cr->flags |= BAM_FMUNMAP;
//                 //cr->mate_ref_id = -1;
//             }
//             if (!(cr->flags & BAM_FPAIRED))
//                 cr->mate_ref_id = -1;
//         }
// 
//         if (cr->tlen == INT_MIN)
//             cr->tlen = 0; // Just incase
//     }
//     return 0;
// }

// the below code fragment can be found in:
// cram/cram_decode.c
// static int cram_decode_aux(cram_container *c, cram_slice *s,
//                            cram_block *blk, cram_record *cr,
//                            int *has_MD, int *has_NM) {
//     int i, r = 0, out_sz = 1;
//     int32_t TL = 0;
//     unsigned char *TN;
//     uint32_t ds = s->data_series;
// 
//     if (!(ds & (CRAM_TL|CRAM_aux))) {
//         cr->aux = 0;
//         cr->aux_size = 0;
//         return 0;
//     }
// 
//     if (!c->comp_hdr->codecs[DS_TL]) return -1;
//     r |= c->comp_hdr->codecs[DS_TL]->decode(s, c->comp_hdr->codecs[DS_TL], blk,
//                                             (char *)&TL, &out_sz);
//     if (r || TL < 0 || TL >= c->comp_hdr->nTL)
//         return -1;
// 
//     TN = c->comp_hdr->TL[TL];
//     cr->ntags = strlen((char *)TN)/3; // optimise to remove strlen
// 
//     //printf("TC=%d\n", cr->ntags);
//     cr->aux_size = 0;
//     cr->aux = BLOCK_SIZE(s->aux_blk);
// 
//     if (!(ds & CRAM_aux))
//         return 0;
// 
//     for (i = 0; i < cr->ntags; i++) {
//         int32_t id, out_sz = 1;
//         unsigned char tag_data[3];
//         cram_map *m;
// 
//         if (TN[0] == 'M' && TN[1] == 'D' && has_MD)
//             *has_MD = 1;
//         if (TN[0] == 'N' && TN[1] == 'M' && has_NM)
//             *has_NM = 1;
// 
//         //printf("Tag %d/%d\n", i+1, cr->ntags);
//         tag_data[0] = *TN++;
//         tag_data[1] = *TN++;
//         tag_data[2] = *TN++;
//         id = (tag_data[0]<<16) | (tag_data[1]<<8) | tag_data[2];
// 
//         m = map_find(c->comp_hdr->tag_encoding_map, tag_data, id);
//         if (!m)
//             return -1;
//         BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
// 
//         if (!m->codec) return -1;
//         r |= m->codec->decode(s, m->codec, blk, (char *)s->aux_blk, &out_sz);
//         if (r) break;
//         cr->aux_size += out_sz + 3;
//     }
// 
//     return r;
// 
//  block_err:
//     return -1;
// }

// the below code fragment can be found in:
// cram/cram_encode.c
// int cram_put_bam_seq(cram_fd *fd, bam_seq_t *b) {
//     cram_container *c;
// 
//     if (!fd->ctr) {
//         fd->ctr = cram_new_container(fd->seqs_per_slice,
//                                      fd->slices_per_container);
//         if (!fd->ctr)
//             return -1;
//         fd->ctr->record_counter = fd->record_counter;
//     }
//     c = fd->ctr;
// 
//     if (!c->slice || c->curr_rec == c->max_rec ||
//         (bam_ref(b) != c->curr_ref && c->curr_ref >= -1) ||
//         (c->s_num_bases >= fd->bases_per_slice)) {
//         int slice_rec, curr_rec, multi_seq = fd->multi_seq == 1;
//         int curr_ref = c->slice ? c->curr_ref : bam_ref(b);
// 
//         /*
//          * Start packing slices when we routinely have under 1/4tr full.
//          *
//          * This option isn't available if we choose to embed references
//          * since we can only have one per slice.
//          *
//          * The multi_seq var here refers to our intention for the next slice.
//          * This slice has already been encoded so we output as-is.
//          */
//         if (fd->multi_seq == -1 && c->curr_rec < c->max_rec/4+10 &&
//             fd->last_slice && fd->last_slice < c->max_rec/4+10 &&
//             !fd->embed_ref) {
//             if (!c->multi_seq)
//                 hts_log_info("Multi-ref enabled for next container");
//             multi_seq = 1;
//         } else if (fd->multi_seq == 1) {
//             pthread_mutex_lock(&fd->metrics_lock);
//             if (fd->last_RI_count <= c->max_slice && fd->multi_seq_user != 1) {
//                 multi_seq = 0;
//                 hts_log_info("Multi-ref disabled for next container");
//             }
//             pthread_mutex_unlock(&fd->metrics_lock);
//         }
// 
//         slice_rec = c->slice_rec;
//         curr_rec  = c->curr_rec;
// 
//         if (CRAM_MAJOR_VERS(fd->version) == 1 ||
//             c->curr_rec == c->max_rec || fd->multi_seq != 1 || !c->slice ||
//             c->s_num_bases >= fd->bases_per_slice) {
//             if (NULL == (c = cram_next_container(fd, b))) {
//                 if (fd->ctr) {
//                     // prevent cram_close attempting to flush
//                     cram_free_container(fd->ctr);
//                     fd->ctr = NULL;
//                 }
//                 return -1;
//             }
//         }
// 
//         /*
//          * Due to our processing order, some things we've already done we
//          * cannot easily undo. So when we first notice we should be packing
//          * multiple sequences per container we emit the small partial
//          * container as-is and then start a fresh one in a different mode.
//          */
//         if (multi_seq == 0 && fd->multi_seq == 1 && fd->multi_seq_user == -1) {
//             // User selected auto-mode, we're currently using multi-seq, but
//             // have detected we don't need to.  Switch back to auto.
//             fd->multi_seq = -1;
//         } else if (multi_seq) {
//             // We detected we need multi-seq
//             fd->multi_seq = 1;
//             c->multi_seq = 1;
//             c->pos_sorted = 0; // required atm for multi_seq slices
// 
//             if (!c->refs_used) {
//                 pthread_mutex_lock(&fd->ref_lock);
//                 c->refs_used = calloc(fd->refs->nref, sizeof(int));
//                 pthread_mutex_unlock(&fd->ref_lock);
//                 if (!c->refs_used)
//                     return -1;
//             }
//         }
// 
//         fd->last_slice = curr_rec - slice_rec;
//         c->slice_rec = c->curr_rec;
// 
//         // Have we seen this reference before?
//         if (bam_ref(b) >= 0 && curr_ref >= 0 && bam_ref(b) != curr_ref && !fd->embed_ref &&
//             !fd->unsorted && multi_seq) {
// 
//             if (!c->refs_used) {
//                 pthread_mutex_lock(&fd->ref_lock);
//                 c->refs_used = calloc(fd->refs->nref, sizeof(int));
//                 pthread_mutex_unlock(&fd->ref_lock);
//                 if (!c->refs_used)
//                     return -1;
//             } else if (c->refs_used && c->refs_used[bam_ref(b)]) {
//                 pthread_mutex_lock(&fd->ref_lock);
//                 fd->unsorted = 1;
//                 pthread_mutex_unlock(&fd->ref_lock);
//                 fd->multi_seq = 1;
//             }
//         }
// 
//         c->curr_ref = bam_ref(b);
//         if (c->refs_used && c->curr_ref >= 0) c->refs_used[c->curr_ref]++;
//     }
// 
//     if (!c->bams) {
//         /* First time through, allocate a set of bam pointers */
//         pthread_mutex_lock(&fd->bam_list_lock);
//         if (fd->bl) {
//             spare_bams *spare = fd->bl;
//             c->bams = spare->bams;
//             fd->bl = spare->next;
//             free(spare);
//         } else {
//             c->bams = calloc(c->max_c_rec, sizeof(bam_seq_t *));
//             if (!c->bams) {
//                 pthread_mutex_unlock(&fd->bam_list_lock);
//                 return -1;
//             }
//         }
//         pthread_mutex_unlock(&fd->bam_list_lock);
//     }
// 
//     /* Copy or alloc+copy the bam record, for later encoding */
//     if (c->bams[c->curr_c_rec]) {
//         if (bam_copy1(c->bams[c->curr_c_rec], b) == NULL)
//             return -1;
//     } else {
//         c->bams[c->curr_c_rec] = bam_dup1(b);
//         if (c->bams[c->curr_c_rec] == NULL)
//             return -1;
//     }
//     c->curr_rec++;
//     c->curr_c_rec++;
//     c->s_num_bases += bam_seq_len(b);
//     c->n_mapped += (bam_flag(b) & BAM_FUNMAP) ? 0 : 1;
//     fd->record_counter++;
// 
//     return 0;
// }

// the below code fragment can be found in:
// cram/cram_encode.c
// static int cram_compress_slice(cram_fd *fd, cram_container *c, cram_slice *s) {
//     int level = fd->level, i;
//     int method = 1<<GZIP | 1<<GZIP_RLE, methodF = method;
// 
//     /* Compress the CORE Block too, with minimal zlib level */
//     if (level > 5 && s->block[0]->uncomp_size > 500)
//         cram_compress_block(fd, s->block[0], NULL, 1<<GZIP, 1);
// 
//     if (fd->use_bz2)
//         method |= 1<<BZIP2;
// 
//     if (fd->use_rans)
//         method |= (1<<RANS0) | (1<<RANS1);
// 
//     if (fd->use_lzma)
//         method |= (1<<LZMA);
// 
//     /* Faster method for data series we only need entropy encoding on */
//     methodF = method & ~(1<<GZIP | 1<<BZIP2 | 1<<LZMA);
//     if (level >= 6)
//         methodF = method;
// 
// 
//     /* Specific compression methods for certain block types */
//     if (cram_compress_block(fd, s->block[DS_IN], fd->m[DS_IN], //IN (seq)
//                             method, level))
//         return -1;
// 
//     if (fd->level == 0) {
//         /* Do nothing */
//     } else if (fd->level == 1) {
//         if (cram_compress_block(fd, s->block[DS_QS], fd->m[DS_QS],
//                                 methodF, 1))
//             return -1;
//         for (i = DS_aux; i <= DS_aux_oz; i++) {
//             if (s->block[i])
//                 if (cram_compress_block(fd, s->block[i], fd->m[i],
//                                         method, 1))
//                     return -1;
//         }
//     } else if (fd->level < 3) {
//         if (cram_compress_block(fd, s->block[DS_QS], fd->m[DS_QS],
//                                 method, 1))
//             return -1;
//         if (cram_compress_block(fd, s->block[DS_BA], fd->m[DS_BA],
//                                 method, 1))
//             return -1;
//         if (s->block[DS_BB])
//             if (cram_compress_block(fd, s->block[DS_BB], fd->m[DS_BB],
//                                     method, 1))
//                 return -1;
//         for (i = DS_aux; i <= DS_aux_oz; i++) {
//             if (s->block[i])
//                 if (cram_compress_block(fd, s->block[i], fd->m[i],
//                                         method, level))
//                     return -1;
//         }
//     } else {
//         if (cram_compress_block(fd, s->block[DS_QS], fd->m[DS_QS],
//                                 method, level))
//             return -1;
//         if (cram_compress_block(fd, s->block[DS_BA], fd->m[DS_BA],
//                                 method, level))
//             return -1;
//         if (s->block[DS_BB])
//             if (cram_compress_block(fd, s->block[DS_BB], fd->m[DS_BB],
//                                     method, level))
//                 return -1;
//         for (i = DS_aux; i <= DS_aux_oz; i++) {
//             if (s->block[i])
//                 if (cram_compress_block(fd, s->block[i], fd->m[i],
//                                         method, level))
//                     return -1;
//         }
//     }
// 
//     // NAME: best is generally xz, bzip2, zlib then rans1
//     if (cram_compress_block(fd, s->block[DS_RN], fd->m[DS_RN],
//                             method & ~(1<<RANS0 | 1<<GZIP_RLE),
//                             level))
//         return -1;
// 
//     // NS shows strong local correlation as rearrangements are localised
//     if (s->block[DS_NS] != s->block[0])
//         if (cram_compress_block(fd, s->block[DS_NS], fd->m[DS_NS],
//                                 method, level))
//             return -1;
// 
// 
//     /*
//      * Compress any auxiliary tags with their own per-tag metrics
//      */
//     {
//         int i;
//         for (i = 0; i < s->naux_block; i++) {
//             if (!s->aux_block[i] || s->aux_block[i] == s->block[0])
//                 continue;
// 
//             if (s->aux_block[i]->method != RAW)
//                 continue;
// 
//             if (cram_compress_block(fd, s->aux_block[i], s->aux_block[i]->m,
//                                     method, level))
//                 return -1;
//         }
//     }
// 
//     /*
//      * Minimal compression of any block still uncompressed, bar CORE
//      */
//     {
//         int i;
//         for (i = 1; i < s->hdr->num_blocks && i < DS_END; i++) {
//             if (!s->block[i] || s->block[i] == s->block[0])
//                 continue;
// 
//             if (s->block[i]->method != RAW)
//                 continue;
// 
//             if (cram_compress_block(fd, s->block[i], fd->m[i],
//                                     methodF, level))
//                 return -1;
//         }
//     }
// 
//     return 0;
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).