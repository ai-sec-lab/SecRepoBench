if (embed_ref) {
    cram_block *b;
    if (s->hdr->ref_base_id < 0) {
        hts_log_error("No reference specified and no embedded reference is available"
                      " at #%d:%"PRId64"-%"PRId64, ref_id, s->hdr->ref_seq_start,
                      s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
        return -1;
    }
    b = cram_get_block_by_id(s, s->hdr->ref_base_id);
    if (!b)
        return -1;
    if (cram_uncompress_block(b)!= 0)
        return -1;
    // Assign the decompressed data from the block as the reference sequence for the slice.
    // Set the start and end positions of this reference sequence based on the slice header.
    // Check if the embedded reference is smaller than expected by comparing the slice's reference
    // span with the decompressed block size. Log an error and return -1 if the reference is too small.
    s->ref = BLOCK_SIZE(s->seqs_blk);
    BLOCK_GROW(s->seqs_blk, b->uncomp_size);
    s->ref = (char *)BLOCK_END(s->seqs_blk);
    BLOCK_SIZE(s->seqs_blk) += b->uncomp_size;
    s->ref_start = 1;
    s->ref_end = s->ref_start + s->hdr->ref_seq_span - 1;
    if (s->ref_end > b->uncomp_size) {
        hts_log_error("Embedded reference too small at #%d:%d-%d",
                      ref_id, s->ref_start, s->ref_end);
        return -1;
    }
}