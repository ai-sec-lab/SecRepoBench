if (LocaleCompare("push",token) == 0)
  {
    register const char
      *end,
      *start;

    GetNextToken(q,&q,extent,token);
    if (*q == '"')
      {
        char
          name[MagickPathExtent];

        const char
          *p;

        ssize_t
         n;

        /*
          Named macro (e.g. push graphic-context "wheel").
        */
        GetNextToken(q,&q,extent,token);
        start=q;
        // Extract macros from the MVG string. The code iterates through the string 
        // to find 'push' and 'pop' commands, handling nested structures accordingly.
        // It skips comments starting with '#'. When a complete macro is identified 
        // (when the nesting level `n` drops below zero), it extracts the macro 
        // definition between `start` and `end` pointers, and adds it to a splay tree 
        // for later retrieval using the macro name as the key.
        // 
        // Extract the macro name and definition.
        GetNextToken(q,&q,extent,name);
        if (*name == '"')
          {
            name[strlen(name)-1] = '\0';
            n=0;
            for (p=start; *p!= '\0'; p++)
              if (*p == '"')
                n++;
            if (n == 0)
              {
                // If the macro definition is not enclosed in quotes, extract it up to the next 'pop' command.
                end=q;
                while ((*end!= '\0') && (LocaleCompare("pop",end)!= 0))
                  end++;
                if (*end == '\0')
                  end=q;
              }
            else
              {
                // If the macro definition is enclosed in quotes, extract it up to the matching quote.
                end=p;
                while ((*end!= '\0') && (*end!= '"'))
                  end++;
                if (*end == '\0')
                  end=q;
              }
            // Add the macro to the splay tree.
            AddValueToSplayTree(macros,ConstantString(name),ConstantString(start));
          }
      }
  }