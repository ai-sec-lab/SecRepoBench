/*
              token is the quoted macro name.  Save it, then locate the
              matching pop command taking nested push/pop sequences into
              account.  Everything between the end of the quoted name and
              the matching pop constitutes the macro definition.
            */
            (void) CopyMagickString(name,token,MagickPathExtent);

            /*
              Search forward for the matching pop while respecting nesting.
            */
            n=1;                    /* current push nesting level          */
            p=q;                    /* scanning pointer                    */
            for ( ; (*q != '\0') && (n > 0) ; )
            {
              const char
                *mark;

              mark=q;               /* remember where this token starts    */
              GetNextToken(q,&q,length,token);
              if (*token == '\0')
                break;
              if (*token == '#')
                {
                  /*  Skip comment. */
                  while ((*q != '\n') && (*q != '\0'))
                    q++;
                  continue;
                }
              if (LocaleCompare("push",token) == 0)
                {
                  n++;              /* nested push                        */
                  continue;
                }
              if (LocaleCompare("pop",token) == 0)
                {
                  /*
                    A pop always has a following token (its class).  Read it
                    so that the scanning pointer advances past the pop
                    command.
                  */
                  GetNextToken(q,&q,length,token);
                  n--;
                  if (n == 0)
                    {
                      end=mark;     /* mark points to beginning of "pop"  */
                      break;
                    }
                }
            }

            /*
              If a balanced push/pop pair was found, copy the macro
              definition and add it to the splay tree.
            */
            if ((n == 0) && (end > start))
              {
                size_t
                  extent_macro=(size_t) (end-start);

                char
                  *definition=(char *) AcquireCriticalMemory(extent_macro+1);

                (void) memcpy(definition,start,extent_macro);
                definition[extent_macro]='\0';
                (void) AddValueToSplayTree(macros,ConstantString(name),
                  definition);
              }
            continue;