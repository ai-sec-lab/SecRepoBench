for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t tmp[4];
        if (i % KC == 0) {
            t = rconpointer;
            rconpointer = (rconpointer + 1) % FF_ARRAY_ELEMS(rcon);

            memcpy(tmp, tk[0], 4);

            // Cyclic shift of the first word
            for (j = 0; j < 4; j++)
                tk[j][0] = tk[j][1], tk[j][1] = tk[j][2], tk[j][2] = tk[j][3], tk[j][3] = tmp[j];

            // Substitute bytes using S-box
            for (j = 0; j < 4; j++)
                tk[j][0] = sbox[tk[j][0]];

            tk[0][0] ^= rcon[t];
        } else if (KC > 6 && i % KC == 4) {
            for (j = 0; j < 4; j++)
                tk[j][0] = sbox[tk[j][0]];
        }

        for (j = 0; j < 4; j++) {
            int index = (i - KC) + j;
            if (index >= 0 && index < (rounds + 1) * 4) { // Check index bounds
                a->round_key[i / 4].u8[j] = tk[j][0] ^ a->round_key[(i - KC) / 4].u8[j];
            }
        }


        if (i % 4 == 0) {
            for (j = 0; j < 4; j++) {
                tk[j][0] = a->round_key[i / 4].u8[j];
            }
        }
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            for (j = 0; j < 4; j++) {
                uint8_t tmp;
                tmp = a->round_key[i].u8[j];
                a->round_key[i].u8[j] = inv_sbox[a->round_key[i].u8[(j + 1) & 3]];
                a->round_key[i].u8[(j + 1) & 3] = inv_sbox[a->round_key[i].u8[(j + 2) & 3]];
                a->round_key[i].u8[(j + 2) & 3] = inv_sbox[a->round_key[i].u8[(j + 3) & 3]];
                a->round_key[i].u8[(j + 3) & 3] = inv_sbox[tmp];
            }
        }
    } else {
        for (i = 1; i < rounds; i++) {
            AES_KEY ark;
            ark.rounds = rounds;
            memcpy(ark.round_key, a->round_key, sizeof(ark.round_key));
            for (j = 0; j < 4; j++) {
                a->round_key[i].u8[j] = ark.round_key[rounds - i].u8[j];
            }
        }
    }