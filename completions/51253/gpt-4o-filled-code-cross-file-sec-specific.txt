for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t temp[4];
        memcpy(temp, a->round_key[i - 1].u8, 4);

        if (i % KC == 0) {
            // Rotate the 4 bytes in a word to the left
            uint8_t t = temp[0];
            temp[0] = temp[1];
            temp[1] = temp[2];
            temp[2] = temp[3];
            temp[3] = t;

            // Apply S-box to all 4 bytes of the word
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];

            // XOR the first byte with the rcon value
            temp[0] ^= rcon[rconpointer++];
        } else if (KC > 6 && i % KC == 4) {
            // Apply S-box to all 4 bytes of the word
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }

        a->round_key[i].u32 = a->round_key[i - KC].u32 ^ AV_RB32(temp);
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            for (j = 0; j < 4; j++) {
                a->round_key[i].u32[j] = dec_multbl[0][sbox[a->round_key[i].u8[j * 4 + 0]]] ^
                                         dec_multbl[1][sbox[a->round_key[i].u8[j * 4 + 1]]] ^
                                         dec_multbl[2][sbox[a->round_key[i].u8[j * 4 + 2]]] ^
                                         dec_multbl[3][sbox[a->round_key[i].u8[j * 4 + 3]]];
            }
        }
    }