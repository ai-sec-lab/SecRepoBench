for (i = 1; i < rounds; i++) {
        for (j = 0; j < KC; j++) {
            uint8_t tmp[4];
            if (i == 1) {
                uint8_t t = tk[j][0];
                tk[j][0] = sbox[tk[j][1]];
                tk[j][1] = sbox[tk[j][2]];
                tk[j][2] = sbox[tk[j][3]];
                tk[j][3] = sbox[t];
            } else {
                tmp[0] = tk[j][0];
                tmp[1] = tk[j][1];
                tmp[2] = tk[j][2];
                tmp[3] = tk[j][3];
                tk[j][0] = sbox[tmp[1]];
                tk[j][1] = sbox[tmp[2]];
                tk[j][2] = sbox[tmp[3]];
                tk[j][3] = sbox[tmp[0]];
            }
            if (j == 0) {
                t = rcon[rconpointer++];
                tk[j][0] ^= t;
            } else {
                tk[j][0] ^= tk[j - 1][0];
                tk[j][1] ^= tk[j - 1][1];
                tk[j][2] ^= tk[j - 1][2];
                tk[j][3] ^= tk[j - 1][3];
            }
            a->round_key[i].u8[j * 4 + 0] = tk[j][0];
            a->round_key[i].u8[j * 4 + 1] = tk[j][1];
            a->round_key[i].u8[j * 4 + 2] = tk[j][2];
            a->round_key[i].u8[j * 4 + 3] = tk[j][3];
        }
    }
    if (!decrypt) {
        for (i = 0; i < rounds; i++) {
            uint32_t tmp = a->round_key[i].u32[0];
            a->round_key[i].u32[0] = a->round_key[rounds - 1 - i].u32[0];
            a->round_key[rounds - 1 - i].u32[0] = tmp;
        }
    }