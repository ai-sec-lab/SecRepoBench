for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t *rki = a->round_key[i / 4].u8;
        memcpy(rki, a->round_key[i / 4 - 1].u8, 4);
        if (i % KC == 0) {
            t = rki[0];
            rki[0] = sbox[rki[1]] ^ rcon[rconpointer++];
            rki[1] = sbox[rki[2]];
            rki[2] = sbox[rki[3]];
            rki[3] = sbox[t];
        } else if (KC > 6 && i % KC == 4) {
            rki[0] = sbox[rki[0]];
            rki[1] = sbox[rki[1]];
            rki[2] = sbox[rki[2]];
            rki[3] = sbox[rki[3]];
        }
        rki[0] ^= a->round_key[i / 4 - KC].u8[0];
        rki[1] ^= a->round_key[i / 4 - KC].u8[1];
        rki[2] ^= a->round_key[i / 4 - KC].u8[2];
        rki[3] ^= a->round_key[i / 4 - KC].u8[3];
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            for (j = 0; j < 4; j++) {
                uint8_t *rki = a->round_key[i].u8 + j * 4;
                inv_shift_row(rki);
                inv_mix_column(rki);
            }
        }
    }