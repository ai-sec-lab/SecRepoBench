for (i = KC; i < (rounds + 1) * 4; i++) {
    memcpy(tk[0], tk[KC - 1], 4);
    if (KC == 8 || (KC == 4 && i % KC == 0)) {
        t = tk[0][0];
        tk[0][0] = sbox[tk[0][1]] ^ rcon[rconpointer++];
        tk[0][1] = sbox[tk[0][2]];
        tk[0][2] = sbox[tk[0][3]];
        tk[0][3] = sbox[t];
    } else if (KC == 8 && i % KC == 4) {
        tk[0][0] = sbox[tk[0][0]];
        tk[0][1] = sbox[tk[0][1]];
        tk[0][2] = sbox[tk[0][2]];
        tk[0][3] = sbox[tk[0][3]];
    }
    for (t = 0; t < 4; t++)
        tk[0][t] ^= tk[KC - 1][t];
    memcpy(tk[1], tk[0], 4);
    for (t = 1; t < KC - 1; t++)
        for (int j = 0; j < 4; j++)
            tk[t + 1][j] = tk[t][j] ^ tk[t - 1][j];
    memcpy(a->round_key[i / 4].u8 + 4 * (i % 4), tk[0], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        av_aes_inv_mix_columns(&a->round_key[i]);
    }
}