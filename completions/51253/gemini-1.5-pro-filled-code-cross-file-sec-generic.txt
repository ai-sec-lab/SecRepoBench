for (i = KC; i < (rounds + 1) * 4; i++) {
        if (i % KC == 0) {
            t = tk[(i - 1) % KC][0];
            tk[(i - 1) % KC][0] = sbox[tk[i % KC][1]] ^ rcon[rconpointer++];
            tk[(i - 1) % KC][1] = sbox[tk[i % KC][2]];
            tk[(i - 1) % KC][2] = sbox[tk[i % KC][3]];
            tk[(i - 1) % KC][3] = sbox[t];
        } else if (KC > 6 && i % KC == 4) {
            tk[(i - 1) % KC][0] = sbox[tk[(i - 1) % KC][0]];
            tk[(i - 1) % KC][1] = sbox[tk[(i - 1) % KC][1]];
            tk[(i - 1) % KC][2] = sbox[tk[(i - 1) % KC][2]];
            tk[(i - 1) % KC][3] = sbox[tk[(i - 1) % KC][3]];
        }
        tk[i % KC][0] = a->round_key[i / 4].u8[i % 4] = tk[(i - KC) % KC][0] ^ tk[(i - 1) % KC][0];
        tk[i % KC][1] = a->round_key[i / 4].u8[(i + 1) % 4] = tk[(i - KC) % KC][1] ^ tk[(i - 1) % KC][1];
        tk[i % KC][2] = a->round_key[i / 4].u8[(i + 2) % 4] = tk[(i - KC) % KC][2] ^ tk[(i - 1) % KC][2];
        tk[i % KC][3] = a->round_key[i / 4].u8[(i + 3) % 4] = tk[(i - KC) % KC][3] ^ tk[(i - 1) % KC][3];
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            inv_subshiftrows(a->round_key[i].u8);
            inv_mixcolumns(a->round_key[i].u32);
        }
    } else {
        for (i = 0; i < (rounds + 1) / 2; i++) {
            FFSWAP(AVRoundKey, a->round_key[i], a->round_key[rounds - i]);
        }
    }