for (i = KC; i < 4 * rounds; i++) {
        memcpy(temp, a->round_key[i - KC].u8, 4);
        if (i % KC == 0) {
            j = sbox[temp[0]] ^ sbox[temp[1]] ^ sbox[temp[2]] ^ sbox[temp[3]] ^ rcon[rconpointer++];
            temp[0] = j;
            temp[1] ^= j;
            temp[2] ^= j;
            temp[3] ^= j;
        } else if (KC > 6 && i % KC == 4) {
            j = sbox[temp[0]] ^ sbox[temp[1]] ^ sbox[temp[2]] ^ sbox[temp[3]];
            temp[0] = j;
            temp[1] ^= j;
            temp[2] ^= j;
            temp[3] ^= j;
        }
        for (j = 0; j < 4; j++)
            a->round_key[i].u8[j] = a->round_key[i - KC].u8[j] ^ temp[j];
    }
    if (!decrypt) {
        for (i = 0; i < rounds; i++) {
            t = i;
            i = rounds - 1 - i;
            memcpy(temp, a->round_key[i].u8, 16);
            memcpy(a->round_key[i].u8, a->round_key[t].u8, 16);
            memcpy(a->round_key[t].u8, temp, 16);
        }
    }