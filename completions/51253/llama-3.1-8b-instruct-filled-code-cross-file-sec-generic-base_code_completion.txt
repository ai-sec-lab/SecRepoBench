// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (i = 1; i < rounds; i++) {
    uint8_t *rcon = (i < 6)? &rcon_table[i] : &rcon_table[6];
    memcpy(tk[i], tk[i - 1], 4);
    tk[i][0] ^= rcon[0];
    for (j = 1; j < 4; j++) {
        tk[i][j] ^= sbox[tk[i - 1][j - 1]];
    }
    if (decrypt) {
        // Inverse subshift and mix transformations for decryption
        for (j = 0; j < 4; j++) {
            tk[i][j] = inv_sbox[tk[i][j]];
        }
        tk[i][0] ^= rcon[0];
        for (j = 1; j < 4; j++) {
            tk[i][j] ^= sbox[tk[i - 1][j - 1]];
        }
    }
    memcpy(a->round_key[i].u8, tk[i], 4);
}
if (decrypt) {
    // Reverse the round keys for decryption
    for (i = rounds - 1; i > 0; i--) {
        memcpy(a->round_key[i].u8, a->round_key[i - 1].u8, 4);
    }
}