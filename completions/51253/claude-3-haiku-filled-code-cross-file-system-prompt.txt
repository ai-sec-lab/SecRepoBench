// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (i = 0; i < rounds; i++) {
    if (i > 0) {
        memcpy(tk[0], tk[KC - 1], 4);
        for (j = 0; j < 4; j++) {
            tk[0][j] = sbox[tk[0][(j + 1) % 4]];
        }
        tk[0][0] ^= rcon[rconpointer++];
        for (j = 1; j < KC; j++) {
            for (t = 0; t < 4; t++) {
                tk[j][t] = tk[j - 1][t] ^ tk[j][t];
            }
        }
        memcpy(a->round_key[i].u8, tk, KC * 4);
    }
    if (decrypt) {
        for (j = 0; j < KC; j++) {
            a->round_key[rounds - i].u32[j] = a->round_key[i].u32[j];
        }
        inv_shift_mix(a->round_key[rounds - i].u8);
    } else {
        memcpy(a->round_key[i + 1].u8, a->round_key[i].u8, KC * 4);
    }
}