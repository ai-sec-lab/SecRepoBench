// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (i = 0; i < rounds; i++) {
    uint8_t *rk = a->round_key[i].u8;
    if (i > 0) {
        memcpy(tk[0], tk[KC - 1], 4);
        if (i % KC == 0) {
            t = tk[0][0];
            tk[0][0] = tk[0][1];
            tk[0][1] = tk[0][2];
            tk[0][2] = tk[0][3];
            tk[0][3] = t;
            for (j = 0; j < 4; j++)
                tk[0][j] = sbox[tk[0][j]];
            tk[0][0] ^= rcon[rconpointer++];
        } else if (KC > 6 && i % KC == 4) {
            for (j = 0; j < 4; j++)
                tk[0][j] = sbox[tk[0][j]];
        }
        for (j = 0; j < KC; j++)
            tk[j][0] ^= tk[j - 1][0];
    }
    memcpy(rk, tk, KC * 4);
    if (decrypt) {
        for (j = 1; j < a->rounds; j++) {
            uint8_t *rk2 = a->round_key[j].u8;
            AV_WN32A(rk2 +  0, AV_RN32A(rk2 +  0) ^ AV_RN32A(rk2 + 4) ^ AV_RN32A(rk2 +  8) ^ AV_RN32A(rk2 + 12));
            AV_WN32A(rk2 +  4, AV_RN32A(rk2 +  0) ^ AV_RN32A(rk2 + 4) ^ AV_RN32A(rk2 + 12) ^ AV_RN32A(rk2 + 16));
            AV_WN32A(rk2 +  8, AV_RN32A(rk2 +  0) ^ AV_RN32A(rk2 +  8) ^ AV_RN32A(rk2 + 12) ^ AV_RN32A(rk2 + 16));
            AV_WN32A(rk2 + 12, AV_RN32A(rk2 +  4) ^ AV_RN32A(rk2 +  8) ^ AV_RN32A(rk2 + 12) ^ AV_RN32A(rk2 + 16));
        }
    } else {
        for (j = 1; j < a->rounds; j++) {
            uint8_t *rk2 = a->round_key[a->rounds - j].u8;
            AV_WN32A(rk2 +  0, AV_RN32A(rk + 0) ^ AV_RN32A(rk + 4) ^ AV_RN32A(rk + 8) ^ AV_RN32A(rk + 12));
            AV_WN32A(rk2 +  4, AV_RN32A(rk + 0) ^ AV_RN32A(rk + 4) ^ AV_RN32A(rk + 12) ^ AV_RN32A(rk + 16));
            AV_WN32A(rk2 +  8, AV_RN32A(rk + 0) ^ AV_RN32A(rk + 8) ^ AV_RN32A(rk + 12) ^ AV_RN32A(rk + 16));
            AV_WN32A(rk2 + 12, AV_RN32A(rk + 4) ^ AV_RN32A(rk + 8) ^ AV_RN32A(rk + 12) ^ AV_RN32A(rk + 16));
            rk += 16;
        }
    }
}