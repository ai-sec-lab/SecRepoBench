for (i = KC; i < (rounds + 1) * 4; i++) {
        uint8_t tmp[4];
        memcpy(tmp, tk[i & 3 ? i - 1 : i - KC], 4);

        if (!(i % KC)) {
            uint8_t t0 = tmp[0];
            tmp[0] = sbox[tmp[1]] ^ rcon[rconpointer++];
            tmp[1] = sbox[tmp[2]];
            tmp[2] = sbox[tmp[3]];
            tmp[3] = sbox[t0];
        } else if (KC > 6 && i % KC == 4) {
            tmp[0] = sbox[tmp[0]];
            tmp[1] = sbox[tmp[1]];
            tmp[2] = sbox[tmp[2]];
            tmp[3] = sbox[tmp[3]];
        }

        tk[i & 3][0] = a->round_key[i >> 2].u8[0] = tk[i - KC][0] ^ tmp[0];
        tk[i & 3][1] = a->round_key[i >> 2].u8[1] = tk[i - KC][1] ^ tmp[1];
        tk[i & 3][2] = a->round_key[i >> 2].u8[2] = tk[i - KC][2] ^ tmp[2];
        tk[i & 3][3] = a->round_key[i >> 2].u8[3] = tk[i - KC][3] ^ tmp[3];
    }

    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            inv_subshiftrows(a->round_key[i].u8);
            inv_mixcolumns(a->round_key[i].u8);
        }
    } else {
        for (i = 1, j = rounds; i < j; i++, j--) {
            AV_SWAP(AESKey, a->round_key[i], a->round_key[j]);
        }
    }