for (i = 1; i < rounds; i++) {
    for (j = 0; j < KC; j++) {
        if (j == 0 && i > 1) {
            t = tk[0][0];
            tk[0][0] = tk[0][3];
            tk[0][3] = tk[0][2];
            tk[0][2] = tk[0][1];
            tk[0][1] = t;
            tk[0][0] = sbox[tk[0][0]];
            tk[0][1] = sbox[tk[0][1]];
            tk[0][2] = sbox[tk[0][2]];
            tk[0][3] = sbox[tk[0][3]];
            tk[0][0] ^= rcon[rconpointer++];
        } else {
            tk[j][0] ^= tk[j - 1][0];
            tk[j][1] ^= tk[j - 1][1];
            tk[j][2] ^= tk[j - 1][2];
            tk[j][3] ^= tk[j - 1][3];
        }
        memcpy(a->round_key[i].u8 + j * 4, tk[j], 4);
    }
}
if (decrypt) {
    for (i = 0; i < rounds / 2; i++) {
        FFSWAP(uint32_t, a->round_key[i].u32[0], a->round_key[rounds - 1 - i].u32[0]);
        FFSWAP(uint32_t, a->round_key[i].u32[1], a->round_key[rounds - 1 - i].u32[1]);
        FFSWAP(uint32_t, a->round_key[i].u32[2], a->round_key[rounds - 1 - i].u32[2]);
        FFSWAP(uint32_t, a->round_key[i].u32[3], a->round_key[rounds - 1 - i].u32[3]);
    }
    if (rounds % 2)
        FFSWAP(uint32_t, a->round_key[rounds / 2].u32[0], a->round_key[rounds / 2].u32[1]);
}