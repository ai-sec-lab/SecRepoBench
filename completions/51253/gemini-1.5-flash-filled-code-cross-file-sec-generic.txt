for (i = KC; i < 4 * rounds; i++) {
        memcpy(tk[i % 8], a->round_key[i / 8].u8, 4);
        if (i % KC == 0) {
            t = tk[i % 8][0];
            t = sbox[t >> 4] << 4 | sbox[t & 0xF];
            t ^= rcon[rconpointer++];
            tk[i % 8][0] = t;
            tk[i % 8][1] ^= tk[i % 8][0];
            tk[i % 8][2] ^= tk[i % 8][1];
            tk[i % 8][3] ^= tk[i % 8][2];
        } else if (KC > 6 && i % KC == 4) {
            for (j = 0; j < 4; j++)
                tk[i % 8][j] = sbox[tk[i % 8][j]];
        }
        for (j = 0; j < 4; j++)
            a->round_key[i / 8].u8[j] ^= tk[(i - KC + 8) % 8][j];
    }
    if (!decrypt) {
        for (i = 0; i < rounds; i++) {
            uint32_t tmp = a->round_key[i].u32[0];
            a->round_key[i].u32[0] = a->round_key[rounds - 1 - i].u32[0];
            a->round_key[rounds - 1 - i].u32[0] = tmp;
        }
    }