// Generate round keys for AES encryption or decryption.
// Iterates over the key schedule and computes each round key
// using the provided S-box and Rcon tables. The initial key is
// expanded into a series of round keys using an XOR-based process
// with a cyclic shift and substitution for the first word of each
// key. If decryption is requested, the round keys are modified
// using inverse subshift and mix transformations. Finally, if
// encryption is intended, the round keys are reversed for use
// in the forward order during encryption.
for (i = 0; i < rounds; i++) {
    uint8_t *rk = a->round_key[i].u8;
    if (i > 0) {
        memcpy(tk[0], tk[KC - 1], 4);
        for (j = 0; j < 4; j++) {
            tk[0][j] = sbox[tk[0][(j + 1) % 4]];
        }
        tk[0][0] ^= rcon[rconpointer++];
        for (j = 0; j < 4; j++) {
            for (t = 0; t < 4; t++) {
                tk[t][j] ^= tk[t - 1][j];
            }
        }
    }
    memcpy(rk, tk, KC * 4);
    if (decrypt) {
        for (j = 1; j < 4; j++) {
            for (t = 0; t < 4; t++) {
                rk[j * 4 + t] = inv_sbox[rk[j * 4 + t]];
            }
        }
        for (j = 1; j < a->rounds; j++) {
            uint8_t *prev_rk = a->round_key[j].u8;
            for (t = 0; t < 4; t++) {
                FFSWAP(uint8_t, prev_rk[t], prev_rk[t + 4]);
                FFSWAP(uint8_t, prev_rk[t + 4], prev_rk[t + 8]);
                FFSWAP(uint8_t, prev_rk[t + 8], prev_rk[t + 12]);
            }
        }
    } else {
        for (j = 1; j < a->rounds; j++) {
            uint8_t *prev_rk = a->round_key[j].u8;
            for (t = 0; t < 4; t++) {
                FFSWAP(uint8_t, prev_rk[t], prev_rk[t + 12]);
                FFSWAP(uint8_t, prev_rk[t + 4], prev_rk[t + 8]);
            }
        }
    }
}