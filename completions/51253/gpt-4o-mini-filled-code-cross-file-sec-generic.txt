for (i = 0; i < rounds; i++) {
        // Copy the last 4 bytes of the previous round key
        uint8_t temp[4];
        memcpy(temp, &tk[KC - 1][0], 4);

        // Perform the key schedule core
        if (i % KC == 0) {
            // Rotate the bytes
            uint8_t t = temp[0];
            temp[0] = temp[1];
            temp[1] = temp[2];
            temp[2] = temp[3];
            temp[3] = t;

            // Substitute the bytes using the S-box
            for (j = 0; j < 4; j++) {
                temp[j] = sbox[temp[j]];
            }

            // XOR with the round constant
            temp[0] ^= rcon[rconpointer++];
        } else if (KC > 6 && i % KC == 4) {
            // Substitute the bytes using the S-box for the 4th byte of each key
            for (j = 0; j < 4; j++) {
                temp[j] = sbox[temp[j]];
            }
        }

        // Generate the round key
        for (j = 0; j < 4; j++) {
            tk[i % KC][j] = tk[(i - 1) % KC][j] ^ temp[j];
        }

        // Store the round key
        memcpy(a->round_key[i + 1].u8, tk[i % KC], 4);
    }

    // If decryption is requested, reverse the order of the round keys
    if (decrypt) {
        for (i = 0; i < rounds / 2; i++) {
            uint8_t temp[16];
            memcpy(temp, a->round_key[i + 1].u8, 16);
            memcpy(a->round_key[i + 1].u8, a->round_key[rounds - i].u8, 16);
            memcpy(a->round_key[rounds - i].u8, temp, 16);
        }
    }