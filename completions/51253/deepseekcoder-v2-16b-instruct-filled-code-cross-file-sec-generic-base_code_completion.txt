// Generate round keys for AES encryption or decryption.
    // Iterates over the key schedule and computes each round key
    // using the provided S-box and Rcon tables. The initial key is
    // expanded into a series of round keys using an XOR-based process
    // with a cyclic shift and substitution for the first word of each
    // key. If decryption is requested, the round keys are modified
    // using inverse subshift and mix transformations. Finally, if
    // encryption is intended, the round keys are reversed for use
    // in the forward order during encryption.

    // Copy the key into the round key array
    for (i = 0; i < KC; i++) {
        for (j = 0; j < 4; j++) {
            a->round_key[0].u8[i * 4 + j] = tk[i][j];
        }
    }

    // Generate the round keys
    for (i = 1; i < rounds; i++) {
        for (j = 0; j < 4; j++) {
            tk[0][j] = a->round_key[i - 1].u8[(KC * 4) - 4 + j];
        }

        if (j == 0) {
            // Apply the Rcon value
            tk[0][0] = Rcon[rconpointer++];
            for (j = 1; j < 4; j++) {
                tk[0][j] = 0;
            }
        }

        // Apply the S-box transformation
        for (j = 0; j < 4; j++) {
            tk[0][j] = sbox[tk[0][j]];
        }

        // XOR with the previous round key
        for (j = 0; j < 4; j++) {
            tk[0][j] ^= a->round_key[i - 1].u8[j];
        }

        // Copy the new round key to the array
        for (j = 0; j < 4; j++) {
            a->round_key[i].u8[i * 4 + j] = tk[0][j];
        }
    }

    // If decryption is requested, apply the inverse transformations
    if (decrypt) {
        for (i = 1; i < rounds; i++) {
            for (j = 0; j < 4; j++) {
                tk[0][j] = a->round_key[i].u8[i * 4 + j];
            }

            // Apply the inverse S-box transformation
            for (j = 0; j < 4; j++) {
                tk[0][j] = inv_sbox[tk[0][j]];
            }

            // XOR with the previous round key
            for (j = 0; j < 4; j++) {
                tk[0][j] ^= a->round_key[i].u8[j];
            }

            // Copy the new round key to the array
            for (j = 0; j < 4; j++) {
                a->round_key[i].u8[i * 4 + j] = tk[0][j];
            }
        }
    }