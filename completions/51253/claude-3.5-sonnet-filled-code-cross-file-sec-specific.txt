for (i = KC; i < (rounds + 1) * 4; i++) {
    memcpy(tk[0], tk[KC - 1], 4);
    if (KC == 8 || (KC == 4 && i % KC == 0)) {
        uint8_t temp = tk[0][0];
        tk[0][0] = sbox[tk[0][1]] ^ rcon[rconpointer++];
        tk[0][1] = sbox[tk[0][2]];
        tk[0][2] = sbox[tk[0][3]];
        tk[0][3] = sbox[temp];
    } else if (KC == 8 && i % KC == 4) {
        tk[0][0] = sbox[tk[0][0]];
        tk[0][1] = sbox[tk[0][1]];
        tk[0][2] = sbox[tk[0][2]];
        tk[0][3] = sbox[tk[0][3]];
    }
    for (j = 0; j < 4; j++)
        tk[j][0] ^= tk[j - 1][0];
    memcpy(a->round_key[i / 4].u8 + 4 * (i % 4), tk[0], 4);
}

if (decrypt) {
    for (i = 1; i < rounds; i++) {
        av_aes_inv_mix_columns(&a->round_key[i]);
    }
}