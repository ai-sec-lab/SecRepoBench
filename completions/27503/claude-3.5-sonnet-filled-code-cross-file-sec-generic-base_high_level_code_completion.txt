switch (tag)
{
    case ID_SCE:
    case ID_LFE:
        // mono or LFE channel
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        p->mActiveElements |= (1u << elementInstanceTag);

        // read parameters
        BitBufferRead(bits, &chanBits, 4);
        BitBufferRead(bits, &unusedHeader, 12);
        escapeFlag = BitBufferReadOne(bits);

        if (escapeFlag == 0)
        {
            // compressed frame
            BitBufferRead(bits, &mixBits, 8);
            BitBufferRead(bits, &mixRes, 8);
            BitBufferRead(bits, &headerByte, 8);
            modeU = headerByte >> 4;
            denShiftU = headerByte & 0xF;
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorU = headerByte >> 5;
            numU = headerByte & 0x1F;

            for (i = 0; i < numU; i++)
                coefsU[i] = (int16_t) BitBufferRead(bits, 16);

            if (numU > 0)
            {
                status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits1);
                RequireNoErr(status, goto Exit;);

                if (modeU == 0)
                    unpc_block(p->mPredictor, p->mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU);
                else
                    // handle other modes if necessary
                    goto Exit;
            }
            else
            {
                memcpy(p->mMixBufferU, p->mPredictor, numSamples * sizeof(int32_t));
            }

            shift = bytesShifted * 8;
            if (bytesShifted > 0)
            {
                for (i = 0; i < numSamples; i++)
                {
                    uint32_t shiftedVal = BitBufferRead(bits, shift);
                    p->mMixBufferU[i] = (p->mMixBufferU[i] << shift) | shiftedVal;
                }
            }

            if (mixBits != 0)
                unmix16(p->mMixBufferU, p->mMixBufferU, numSamples, mixBits, mixRes);

            out32 = sampleBuffer + channelIndex;
            for (i = 0; i < numSamples; i++)
            {
                *out32 = p->mMixBufferU[i];
                out32 += numChannels;
            }
        }
        else
        {
            // uncompressed frame
            shift = bytesShifted * 8 + (32 - chanBits);
            for (i = 0; i < numSamples; i++)
            {
                val = (int32_t) BitBufferRead(bits, chanBits);
                val = (val << shift) >> shift;
                sampleBuffer[i * numChannels + channelIndex] = val;
            }
        }

        channelIndex++;
        break;

    case ID_CPE:
        // stereo channel
        elementInstanceTag = BitBufferReadSmall(bits, 4);
        p->mActiveElements |= (1u << elementInstanceTag);

        // read parameters
        BitBufferRead(bits, &chanBits, 4);
        BitBufferRead(bits, &unusedHeader, 12);
        escapeFlag = BitBufferReadOne(bits);

        if (escapeFlag == 0)
        {
            // compressed frame
            BitBufferRead(bits, &mixBits, 8);
            BitBufferRead(bits, &mixRes, 8);

            // read and process left channel
            BitBufferRead(bits, &headerByte, 8);
            modeU = headerByte >> 4;
            denShiftU = headerByte & 0xF;
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorU = headerByte >> 5;
            numU = headerByte & 0x1F;

            for (i = 0; i < numU; i++)
                coefsU[i] = (int16_t) BitBufferRead(bits, 16);

            // read and process right channel
            BitBufferRead(bits, &headerByte, 8);
            modeV = headerByte >> 4;
            denShiftV = headerByte & 0xF;
            headerByte = BitBufferReadSmall(bits, 8);
            pbFactorV = headerByte >> 5;
            numV = headerByte & 0x1F;

            for (i = 0; i < numV; i++)
                coefsV[i] = (int16_t) BitBufferRead(bits, 16);

            if (bytesShifted > 0)
            {
                for (i = 0; i < numSamples; i++)
                {
                    uint32_t shiftedVal = BitBufferRead(bits, bytesShifted * 8 * 2);
                    p->mShiftBufferUV[2 * i] = (shiftedVal >> (bytesShifted * 8)) & ((1 << (bytesShifted * 8)) - 1);
                    p->mShiftBufferUV[2 * i + 1] = shiftedVal & ((1 << (bytesShifted * 8)) - 1);
                }
            }

            status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits1);
            RequireNoErr(status, goto Exit;);

            if (modeU == 0)
                unpc_block(p->mPredictor, p->mMixBufferU, numSamples, &coefsU[0], numU, chanBits, denShiftU);
            else
                // handle other modes if necessary
                goto Exit;

            status = dyn_decomp(&agParams, bits, p->mPredictor, numSamples, chanBits, &bits2);
            RequireNoErr(status, goto Exit;);

            if (modeV == 0)
                unpc_block(p->mPredictor, p->mMixBufferV, numSamples, &coefsV[0], numV, chanBits, denShiftV);
            else
                // handle other modes if necessary
                goto Exit;

            unmix16(p->mMixBufferU, p->mMixBufferV, numSamples, mixBits, mixRes);

            shift = bytesShifted * 8;
            if (bytesShifted > 0)
            {
                for (i = 0; i < numSamples; i++)
                {
                    p->mMixBufferU[i] = (p->mMixBufferU[i] << shift) | p->mShiftBufferUV[2 * i];
                    p->mMixBufferV[i] = (p->mMixBufferV[i] << shift) | p->mShiftBufferUV[2 * i + 1];
                }
            }

            out32 = sampleBuffer + channelIndex;
            for (i = 0; i < numSamples; i++)
            {
                out32[0] = p->mMixBufferU[i];
                out32[1] = p->mMixBufferV[i];
                out32 += numChannels;
            }
        }
        else
        {
            // uncompressed frame
            shift = bytesShifted * 8 + (32 - chanBits);
            for (i = 0; i < numSamples; i++)
            {
                int32_t val1 = (int32_t) BitBufferRead(bits, chanBits);
                int32_t val2 = (int32_t) BitBufferRead(bits, chanBits);
                val1 = (val1 << shift) >> shift;
                val2 = (val2 << shift) >> shift;
                sampleBuffer[i * numChannels + channelIndex] = val1;
                sampleBuffer[i * numChannels + channelIndex + 1] = val2;
            }
        }

        channelIndex += 2;
        break;

    case ID_CCE:
    case ID_PCE:
        // unsupported element
        status = kALAC_UnsupportedElement;
        goto Exit;

    case ID_DSE:
        // data stream element - parse but ignore
        BitBufferReadSmall(bits, 4);
        if (BitBufferReadOne(bits))
            BitBufferReadSmall(bits, 8);
        dataByteAlign(bits);
        break;

    case ID_FIL:
        // fill element - parse but ignore
        i = BitBufferRead(bits, 4);
        j = (i == 15) ? (BitBufferRead(bits, 8) + 15) : i;
        BitBufferAdvance(bits, 8 * j);
        break;

    case ID_END:
        goto NoMoreChannels;
}