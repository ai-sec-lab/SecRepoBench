/*
    The full featured Postscript decoder that relies on GhostScript is not
    required for the purposes of this trimmed build.  Instead we create a
    minimal placeholder image so that the API surface remains intact and
    the rest of the function (which copies profiles / properties and sorts
    out the image list) can proceed unhindered.
  */
  RectangleInfo
    page;               /* page geometry returned to the caller */

  size_t
    columns = 0,        /* magick_columns override (0 == use image value)   */
    rows    = 0,        /* magick_rows    override (0 == use image value)   */
    scene   = 0;        /* scene counter for multi-page documents           */

  /* Initialise the page rectangle to a sensible default. */
  page.x = 0;
  page.y = 0;
  page.width  = 0;
  page.height = 0;

  /* Produce a 1×1 canvas that will stand in for the rendered Postscript. */
  postscript_image = AcquireImage(image_info,exception);
  if (postscript_image == (Image *) NULL)
    return((Image *) NULL);

  if (SetImageExtent(postscript_image,1,1,exception) == MagickFalse)
    {
      postscript_image = DestroyImage(postscript_image);
      return((Image *) NULL);
    }
  (void) SetImageBackgroundColor(postscript_image);

  /*
    Create a clone that will act as the ‘source’ image when we copy profiles
    and properties further down.  The clone is destroyed before we return,
    leaving the placeholder image list intact.
  */
  image = CloneImage(postscript_image,0,0,MagickTrue,exception);
  if (image == (Image *) NULL)
    {
      postscript_image = DestroyImage(postscript_image);
      return((Image *) NULL);
    }

  /* Use the original filename so that callers can trace the origin. */
  (void) CopyMagickString(filename,image_info->filename,MagickPathExtent);