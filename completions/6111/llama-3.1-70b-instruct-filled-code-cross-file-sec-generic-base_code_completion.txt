// Initialize necessary variables and structures for processing Postscript images.
image = NewImageList();
read_info = CloneImageInfo(image_info);
*read_info->magick = '\0';

// Open the input image file and create a symbolic link to it for processing.
file = OpenBlob(image_info->filename,ReadBinaryBlobMode,exception);
if (file == -1)
  {
    image=DestroyImageList(image);
    return((Image *) NULL);
  }

// Initialize an array to map hex characters to their integer values.
for (c=0; c < (int) MagickMax(256,sizeof(hex_digit)); c++)
  hex_digit[c]= -1;
for (c=0; c < (int) MagickMax(16,sizeof(hex_digit)); c++)
  {
    hex_digit[(int) ('0'+c)]= (char) c;
    hex_digit[(int) ('A'+c)]= (char) c;
    hex_digit[(int) ('a'+c)]= (char) c;
  }

// Set the page density for the image based on the provided resolution or default values.
density=GetImageOption(image_info,"density");
if (density == (char *) NULL)
  density=GetImageOption(image_info,"resolution");
if (density == (char *) NULL)
  density="72";
sscanf(density,"%f %f",&x_resolution,&y_resolution);

// Determine the page geometry using the Postscript bounding box comments.
options=GetImageOption(image_info,"page");
if (options == (char *) NULL)
  {
    (void) ParseAbsoluteGeometry("0x0+0+0",&geometry_info);
    image_info->page.geometry=geometry_info;
  }
else
  image_info->page.geometry=ParsePageGeometry(options,&geometry_info);

// Initialize various variables including color space, resolution, and page dimensions.
image_info->colorspace=CMYKColorspace;
image_info->resolution.x=x_resolution;
image_info->resolution.y=y_resolution;
image_info->page.width=geometry_info.width;
image_info->page.height=geometry_info.height;

// Create a control file for Ghostscript to render the Postscript image.
postscript_filename[0]='\0';
strcat(postscript_filename,"gs -q -dBATCH -dNOPAUSE -r");
strcat(postscript_filename," ");
strcat(postscript_filename,density);
strcat(postscript_filename," -sDEVICE=ppmraw -sOutputFile=");
strcat(postscript_filename,image_info->filename);
strcat(postscript_filename,".ppm ");

// Use the Ghostscript delegate to render the Postscript into a raster format.
delegate_info=GetDelegateInfo("ppm","PPM",image_info,exception);
if ((delegate_info == (DelegateInfo *) NULL) ||
    (delegate_info->decode == (DecodeImageHandler *) NULL))
  {
    InheritException(exception,&image_info->exception);
    image=DestroyImageList(image);
    return((Image *) NULL);
  }

// Read the rendered images and append them to the image list, handling profiles if necessary.
do
{
  (void) CopyMagickString(postscript_image->filename,filename,
    MagickPathExtent);
  (void) CopyMagickString(postscript_image->magick,image->magick,
    MagickPathExtent);
  if (columns!= 0)
    postscript_image->magick_columns=columns;
  if (rows!= 0)
    postscript_image->magick_rows=rows;
  postscript_image->page=page;
  (void) CloneImageProfiles(postscript_image,image);
  (void) CloneImageProperties(postscript_image,image);
  next=SyncNextImageInList(postscript_image);
  if (next!= (Image *) NULL)
    postscript_image=next;
} while (next!= (Image *) NULL);

// Clean up and return the processed image list, handling any errors that occur.
image=DestroyImageList(image);
scene=0;
for (next=GetFirstImageInList(postscript_image); next!= (Image *) NULL; )
{
  next->scene=scene++;
  next=GetNextImageInList(next);
}
return(GetFirstImageInList(postscript_image));