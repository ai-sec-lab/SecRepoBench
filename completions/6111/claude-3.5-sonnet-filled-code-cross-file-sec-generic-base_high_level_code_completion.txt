MagickBooleanType
  status;

long
  y;

PixelInfo
  pixel;

register Quantum
  *q;

register ssize_t
  x;

size_t
  columns,
  rows;

image=AcquireImage(image_info,exception);
if (image == (Image *) NULL)
  return((Image *) NULL);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
  {
    image=DestroyImageList(image);
    return((Image *) NULL);
  }
columns=0;
rows=0;
for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
{
  if (c == '\n')
    {
      rows++;
      if (columns == 0)
        columns=image->columns;
    }
  else
    image->columns++;
}
if (columns == 0)
  columns=image->columns;
image->columns=columns;
image->rows=rows;
if (image_info->ping != MagickFalse)
  {
    (void) CloseBlob(image);
    return(GetFirstImageInList(image));
  }
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
  return(DestroyImageList(image));
(void) ResetImagePixels(image,exception);
(void) SeekBlob(image,0,SEEK_SET);
GetPixelInfo(image,&pixel);
for (y=0; y < (long) image->rows; y++)
{
  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    break;
  for (x=0; x < (ssize_t) image->columns; x++)
  {
    c=ReadBlobByte(image);
    if (c == EOF)
      break;
    pixel.red=(double) ScaleCharToQuantum((unsigned char) c);
    pixel.green=pixel.red;
    pixel.blue=pixel.red;
    SetPixelViaPixelInfo(image,&pixel,q);
    q+=GetPixelChannels(image);
  }
  if (SyncAuthenticPixels(image,exception) == MagickFalse)
    break;
}
(void) CloseBlob(image);
return(GetFirstImageInList(image));