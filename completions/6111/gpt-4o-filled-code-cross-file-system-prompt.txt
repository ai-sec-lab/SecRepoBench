// Initialize necessary variables and structures for processing Postscript images.
  image=(Image *) NULL;
  postscript_image=(Image *) NULL;
  read_info=CloneImageInfo(image_info);
  if (read_info == (ImageInfo *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  (void) CopyMagickString(read_info->filename,image_info->filename,
    MagickPathExtent);
  (void) CopyMagickString(input_filename,image_info->filename,
    MagickPathExtent);
  file=OpenBlob(image_info,input_filename,ReadBinaryBlobMode,exception);
  if (file == -1)
    {
      read_info=DestroyImageInfo(read_info);
      return((Image *) NULL);
    }
  // Open the input image file and create a symbolic link to it for processing.
  (void) FormatLocaleString(filename,MagickPathExtent,"%s.ps",
    image_info->unique);
  (void) CopyMagickString(postscript_filename,filename,MagickPathExtent);
  if (IsAccessibleNoLogging(filename) == MagickFalse)
    {
      (void) CloseBlob(image);
      ThrowReaderException(FileOpenError,"UnableToOpenFile");
    }
  // Initialize an array to map hex characters to their integer values.
  for (c=0; c < 256; c++)
    hex_digits[c]=0;
  for (c='0'; c <= '9'; c++)
    hex_digits[c]=c-'0';
  for (c='A'; c <= 'F'; c++)
    hex_digits[c]=c-'A'+10;
  for (c='a'; c <= 'f'; c++)
    hex_digits[c]=c-'a'+10;
  // Set the page density for the image based on the provided resolution or default values.
  density=GetImageOption(image_info,"density");
  if (density == (const char *) NULL)
    density=DefaultResolution;
  (void) ParseGeometry(density,&geometry_info);
  // Determine the page geometry using the Postscript bounding box comments.
  option=GetImageOption(image_info,"page");
  if (option != (const char *) NULL)
    (void) ParseAbsoluteGeometry(option,&geometry_info);
  else
    (void) ParseAbsoluteGeometry(DefaultPageGeometry,&geometry_info);
  // Initialize various variables including color space, resolution, and page dimensions.
  columns=(size_t) floor(geometry_info.rho+0.5);
  rows=(size_t) floor(geometry_info.sigma+0.5);
  page.width=(size_t) floor(geometry_info.rho+0.5);
  page.height=(size_t) floor(geometry_info.sigma+0.5);
  page.x=0;
  page.y=0;
  // Create a control file for Ghostscript to render the Postscript image.
  (void) FormatLocaleString(command,MagickPathExtent,
    "gs -q -dSAFER -dBATCH -dNOPAUSE -sDEVICE=ppmraw -dTextAlphaBits=4 "
    "-dGraphicsAlphaBits=4 -r%gx%g -g%gx%g -sOutputFile=%s %s",
    (unsigned int) geometry_info.rho,(unsigned int) geometry_info.sigma,
    (unsigned int) columns,(unsigned int) rows,filename,
    postscript_filename);
  // Use the Ghostscript delegate to render the Postscript into a raster format.
  delegate_info=GetDelegateInfo("ps:decode","ppm",(ExceptionInfo *) NULL);
  if (delegate_info == (const DelegateInfo *) NULL)
    ThrowReaderException(DelegateError,"PostscriptDelegateFailed");
  (void) InvokeDelegate(read_info,image,command,exception);
  // Read the rendered images and append them to the image list, handling profiles if necessary.
  postscript_image=ReadImages(read_info,filename,exception);
  if (postscript_image == (Image *) NULL)
    {
      read_info=DestroyImageInfo(read_info);
      return((Image *) NULL);
    }
  // Clean up and return the processed image list, handling any errors that occur.
  (void) CloseBlob(image);
  read_info=DestroyImageInfo(read_info);