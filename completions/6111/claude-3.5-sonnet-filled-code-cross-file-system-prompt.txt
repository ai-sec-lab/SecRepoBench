MagickBooleanType
  status;

Image
  *images;

unsigned char
  *pixels;

QuantumInfo
  *quantum_info;

size_t
  columns,
  length,
  rows;

ssize_t
  count,
  y;

unsigned int
  page;

size_t
  scene;

register ssize_t
  x;

register Quantum
  *q;

image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
  {
    image=DestroyImageList(image);
    return((Image *) NULL);
  }
images=NewImageList();
page=1;
scene=0;
do
{
  /*
    Read Postscript image.
  */
  image->page.type=SinglePageType;
  image->page.x=0;
  image->page.y=0;
  (void) ParseAbsoluteGeometry(page_geometry,&image->page);
  image->compression=NoCompression;
  image->depth=8;
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Create virtual canvas to support scaling.
  */
  SetGeometry(image,&geometry);
  (void) ParseAbsoluteGeometry(page_geometry,&geometry);
  geometry.width=(size_t) ((geometry.width*image->x_resolution+0.5)/
    default_resolution+0.5);
  geometry.height=(size_t) ((geometry.height*image->y_resolution+0.5)/
    default_resolution+0.5);
  (void) SetImageExtent(image,geometry.width,geometry.height,exception);
  (void) SetImageColorspace(image,RGBColorspace,exception);
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetQuantumPixels(quantum_info);
  if (pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  length=GetQuantumExtent(image,quantum_info,RGBQuantum);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    count=ReadBlob(image,length,pixels);
    if (count != (ssize_t) length)
      break;
    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      RGBQuantum,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  SetQuantumImageType(image,RGBQuantum);
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (EOFBlob(image) != MagickFalse)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        "UnexpectedEndOfFile","`%s'",image->filename);
      break;
    }
  /*
    Proceed to next page.
  */
  if (image_info->number_scenes != 0)
    if (image->scene >= (image_info->scene+image_info->number_scenes-1))
      break;
  if (page >= pages)
    break;
  page++;
  count=ReadBlob(image,1,&c);
  if ((count != 0) && (c == 'P'))
    {
      /*
        Allocate next image structure.
      */
      AcquireNextImage(image_info,image,exception);
      if (GetNextImageInList(image) == (Image *) NULL)
        {
          image=DestroyImageList(image);
          return((Image *) NULL);
        }
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
        GetBlobSize(image));
      if (status == MagickFalse)
        break;
    }
} while (count != 0);