BITCODE_RL obj_size = bit_read_RL(dat);
LOG_TRACE(", size: " FORMAT_RL " [RL]", obj_size);
if (obj_size < 2 || obj_size > size)
  {
    LOG_ERROR("Invalid object size " FORMAT_RL " at pos 0x%zx", obj_size, dat->byte - 4);
    obj_size = size - 2;
    error |= DWG_ERR_VALUEOUTOFBOUNDS;
  }
obj->size = obj_size;

if (dat->version >= R_11)
  {
    BITCODE_RS crc;
    dat->byte += obj_size - 2;
    crc = bit_read_RS(dat);
    LOG_TRACE(", crc: %04X [RS]", crc);
    if (dat->byte - 2 - oldpos != obj_size)
      {
        long off = obj_size - (dat->byte - 2 - oldpos);
        LOG_WARN("Illegal object size: %ld", off);
        if (off > 0)
          bit_advance_position(dat, 8 * off);
        else if (off < 0)
          dat->byte += off;
      }
  }

if (obj->size + 2 > size)
  {
    LOG_ERROR("Invalid object size " FORMAT_RL " > %d at pos 0x%zx",
              obj->size, size, oldpos);
    obj->size = size - 2;
    error |= DWG_ERR_VALUEOUTOFBOUNDS;
  }
if (obj->address + obj->size != dat->byte - 2)
  {
    long off = (long)((obj->address + obj->size) - (dat->byte - 2));
    long absoff = labs(off);
    if (absoff > 0 && absoff < 0xffffff)
      {
        LOG_WARN("Illegal object size: %ld", off);
        if (off > 0)
          {
            obj->unknown_bits = (BITCODE_TF)calloc(absoff, 1);
            if (obj->unknown_bits)
              {
                memcpy(obj->unknown_bits, &dat->chain[dat->byte], absoff);
                LOG_TRACE("unknown_bits: ");
                LOG_TRACE_TF(obj->unknown_bits, absoff);
                dat->byte += absoff;
              }
          }
        else
          {
            dat->byte += off;
          }
      }
  }