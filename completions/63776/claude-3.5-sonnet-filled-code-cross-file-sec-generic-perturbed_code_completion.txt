// Pre-R11 versions
PRE (R_11)
{
  obj->size = bit_read_RS (bitchain);
  if (obj->size > size)
    {
      LOG_ERROR ("Invalid object size %d > %d", (int)obj->size, (int)size);
      obj->size = (BITCODE_RL)size;
    }
  if (obj->size < 2)
    {
      LOG_ERROR ("Invalid object size %d < 2", (int)obj->size);
      obj->size = 2;
    }
  if (bitchain->byte + obj->size > oldpos + size)
    {
      LOG_ERROR ("Invalid object size %d > %d", (int)obj->size,
                 (int)(oldpos + size - bitchain->byte));
      obj->size = (BITCODE_RL)(oldpos + size - bitchain->byte);
    }
  if (bitchain->byte + obj->size != oldpos + obj->size)
    {
      unsigned long pos = bitchain->byte;
      bitchain->byte = oldpos + obj->size;
      obj->unknown_bits = bit_read_TF (bitchain, obj->size - 2);
      LOG_TRACE ("unknown_bits: %d [TF]\n", obj->size - 2);
      bitchain->byte = pos;
    }
}
// R11 and later versions
LATER_VERSIONS
{
  obj->size = bit_read_RL (bitchain);
  if (obj->size > size)
    {
      LOG_ERROR ("Invalid object size %d > %d", (int)obj->size, (int)size);
      obj->size = (BITCODE_RL)size;
    }
  if (obj->size < 4)
    {
      LOG_ERROR ("Invalid object size %d < 4", (int)obj->size);
      obj->size = 4;
    }
  if (bitchain->byte + obj->size > oldpos + size)
    {
      LOG_ERROR ("Invalid object size %d > %d", (int)obj->size,
                 (int)(oldpos + size - bitchain->byte));
      obj->size = (BITCODE_RL)(oldpos + size - bitchain->byte);
    }
  if (bitchain->byte + obj->size != oldpos + obj->size)
    {
      unsigned long pos = bitchain->byte;
      BITCODE_RS crc;
      bitchain->byte = oldpos + obj->size - 2;
      crc = bit_read_RS (bitchain);
      LOG_TRACE ("crc: 0x%04X [RS]\n", crc);
      if (crc)
        {
          BITCODE_RS calc_crc = bit_calc_CRC (0xC0C1, &bitchain->chain[oldpos],
                                              obj->size - 2);
          if (crc != calc_crc)
            LOG_ERROR ("Wrong CRC 0x%04X != 0x%04X", crc, calc_crc);
        }
      bitchain->byte = pos;
    }
}
if (bitchain->byte - obj->address != obj->size)
  {
    long offset = obj->size - (bitchain->byte - obj->address);
    if (offset > 0)
      {
        obj->unknown_bits = (unsigned char *)calloc (1, offset);
        if (!obj->unknown_bits)
          {
            LOG_ERROR ("Out of memory");
            return DWG_ERR_OUTOFMEM;
          }
        memcpy (obj->unknown_bits, &bitchain->chain[bitchain->byte], offset);
        LOG_TRACE ("unknown_bits: %ld [TF]\n", offset);
        bitchain->byte += offset;
      }
    else
      {
        LOG_ERROR ("object size overflow %ld", -offset);
        error |= DWG_ERR_VALUEOUTOFBOUNDS;
      }
  }