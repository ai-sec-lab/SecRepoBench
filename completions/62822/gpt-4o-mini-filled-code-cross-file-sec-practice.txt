// Validate input parameters
  if (slen <= 0 || count <= 0 || ary == mrb_nil_value()) {
    return 0; // Invalid input, nothing to process
  }

  const char *sptr = (const char *)src;
  mrb_value dst;
  char *dptr;
  int processed_bits = 0;
  unsigned int byte = 0;

  // Ensure the destination array can hold the expected number of bits
  dst = mrb_ary_new_capa(mrb, (slen * 8) / count);
  
  for (int i = 0; i < slen; i++) {
    for (int bit = 0; bit < 8; bit++) {
      if (processed_bits >= count) {
        break; // Stop if we've processed the required number of bits
      }
      // Read the bit based on the flag
      if (flags & PACK_FLAG_LSB) {
        byte = (sptr[i] >> bit) & 1; // LSB first
      } else {
        byte = (sptr[i] >> (7 - bit)) & 1; // MSB first
      }
      // Append the bit to the destination array
      dptr = mrb_str_new_cstr(mrb, byte ? "1" : "0");
      mrb_ary_push(mrb, dst, dptr);
      processed_bits++;
    }
  }

  // Resize the destination array to the number of processed bits
  mrb_ary_resize(mrb, dst, processed_bits);
  mrb_ary_push(mrb, ary, dst); // Add the result to the output array

  return processed_bits; // Return the number of processed bits