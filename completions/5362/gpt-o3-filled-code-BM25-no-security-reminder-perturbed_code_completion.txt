/*
            The packed 10-bit samples are stored in a 32-bit word in the
            reverse order to the little-endian case.  Extract three gray
            samples from every 32-bit word (30 significant bits), convert
            them to Quantum values and store them in the image pixel array.
          */
          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)
          {
            p=PushLongPixel(quantum_info->endian,p,&pixel);
            /* first sample: least-significant 10 bits (bits 2-11) */
            SetPixelGray(img,ScaleAnyToQuantum((QuantumAny) ((pixel >> 2) &
              0x3ff),range),q);
            q+=GetPixelChannels(img);
            /* second sample: middle 10 bits (bits 12-21) */
            SetPixelGray(img,ScaleAnyToQuantum((QuantumAny) ((pixel >> 12) &
              0x3ff),range),q);
            q+=GetPixelChannels(img);
            /* third sample: most-significant 10 bits (bits 22-31) */
            SetPixelGray(img,ScaleAnyToQuantum((QuantumAny) ((pixel >> 22) &
              0x3ff),range),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(img);
          }
          /*
            Handle any remaining one or two pixels.
          */
          if (x++ < (ssize_t) (number_pixels-1))
            {
              p=PushLongPixel(quantum_info->endian,p,&pixel);
              SetPixelGray(img,ScaleAnyToQuantum((QuantumAny) ((pixel >> 2) &
                0x3ff),range),q);
              q+=GetPixelChannels(img);
            }
          if (x++ < (ssize_t) number_pixels)
            {
              SetPixelGray(img,ScaleAnyToQuantum((QuantumAny) ((pixel >> 12) &
                0x3ff),range),q);
              q+=GetPixelChannels(img);
            }
          break;