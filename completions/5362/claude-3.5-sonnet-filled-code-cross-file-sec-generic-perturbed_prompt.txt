Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static void ImportGrayQuantum(const Image *picture,QuantumInfo *quantum_info,
  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,
  Quantum *magick_restrict q)
{
  QuantumAny
    range;

  register ssize_t
    x;

  ssize_t
    bit;

  unsigned int
    pixel;

  assert(picture != (Image *) NULL);
  assert(picture->signature == MagickCoreSignature);
  pixel=0;
  switch (quantum_info->depth)
  {
    case 1:
    {
      register Quantum
        black,
        white;

      black=0;
      white=QuantumRange;
      if (quantum_info->min_is_white != MagickFalse)
        {
          black=QuantumRange;
          white=0;
        }
      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)
      {
        for (bit=0; bit < 8; bit++)
        {
          SetPixelGray(picture,((*p) & (1 << (7-bit))) == 0 ? black : white,q);
          q+=GetPixelChannels(picture);
        }
        p++;
      }
      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)
      {
        SetPixelGray(picture,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);
        q+=GetPixelChannels(picture);
      }
      if (bit != 0)
        p++;
      break;
    }
    case 4:
    {
      register unsigned char
        pixel;

      range=GetQuantumRange(quantum_info->depth);
      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)
      {
        pixel=(unsigned char) ((*p >> 4) & 0xf);
        SetPixelGray(picture,ScaleAnyToQuantum(pixel,range),q);
        q+=GetPixelChannels(picture);
        pixel=(unsigned char) ((*p) & 0xf);
        SetPixelGray(picture,ScaleAnyToQuantum(pixel,range),q);
        p++;
        q+=GetPixelChannels(picture);
      }
      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)
      {
        pixel=(unsigned char) (*p++ >> 4);
        SetPixelGray(picture,ScaleAnyToQuantum(pixel,range),q);
        q+=GetPixelChannels(picture);
      }
      break;
    }
    case 8:
    {
      unsigned char
        pixel;

      if (quantum_info->min_is_white != MagickFalse)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            p=PushCharPixel(p,&pixel);
            SetPixelGray(picture,QuantumRange-ScaleCharToQuantum(pixel),q);
            SetPixelAlpha(picture,OpaqueAlpha,q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushCharPixel(p,&pixel);
        SetPixelGray(picture,ScaleCharToQuantum(pixel),q);
        SetPixelAlpha(picture,OpaqueAlpha,q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(picture);
      }
      break;
    }
    case 10:
    {
      range=GetQuantumRange(quantum_info->depth);
      if (quantum_info->pack == MagickFalse)
        {
          if (picture->endian == LSBEndian)
            {
              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)
              {
                p=PushLongPixel(quantum_info->endian,p,&pixel);
                SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,
                  range),q);
                q+=GetPixelChannels(picture);
                SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,
                  range),q);
                q+=GetPixelChannels(picture);
                SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,
                  range),q);
                p+=quantum_info->pad;
                q+=GetPixelChannels(picture);
              }
              if (x++ < (ssize_t) (number_pixels-1))
                {
                  p=PushLongPixel(quantum_info->endian,p,&pixel);
                  SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,
                    range),q);
                  q+=GetPixelChannels(picture);
                }
              if (x++ < (ssize_t) number_pixels)
                {
                  SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,
                    range),q);
                  q+=GetPixelChannels(picture);
                }
              break;
            }
          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)
          {
            p=PushLongPixel(quantum_info->endian,p,&pixel);
            SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),
              q);
            q+=GetPixelChannels(picture);
            SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),
              q);
            q+=GetPixelChannels(picture);
            SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),
              q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          // The masked region handles the remaining pixels when the total number 
          // of pixels is not a multiple of three. It reads a long pixel from the 
          // source, applies a bitwise shift to extract a 10-bit gray value, scales 
          // it according to the quantum range, and then sets this gray value for 
          // the pixel. The operation is conditioned to ensure it does not exceed 
          // the number of pixels being processed.
          // <MASK>
          if (x++ < (ssize_t) number_pixels)
            {
              SetPixelGray(picture,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,
                range),q);
              q+=GetPixelChannels(picture);
            }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushQuantumPixel(quantum_info,p,&pixel);
        SetPixelGray(picture,ScaleAnyToQuantum(pixel,range),q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(picture);
      }
      break;
    }
    case 12:
    {
      range=GetQuantumRange(quantum_info->depth);
      if (quantum_info->pack == MagickFalse)
        {
          unsigned short
            pixel;

          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)
          {
            p=PushShortPixel(quantum_info->endian,p,&pixel);
            SetPixelGray(picture,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
              range),q);
            q+=GetPixelChannels(picture);
            p=PushShortPixel(quantum_info->endian,p,&pixel);
            SetPixelGray(picture,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
              range),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)
          {
            p=PushShortPixel(quantum_info->endian,p,&pixel);
            SetPixelGray(picture,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),
              range),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          if (bit != 0)
            p++;
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushQuantumPixel(quantum_info,p,&pixel);
        SetPixelGray(picture,ScaleAnyToQuantum(pixel,range),q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(picture);
      }
      break;
    }
    case 16:
    {
      unsigned short
        pixel;

      if (quantum_info->min_is_white != MagickFalse)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            p=PushShortPixel(quantum_info->endian,p,&pixel);
            SetPixelGray(picture,QuantumRange-ScaleShortToQuantum(pixel),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          break;
        }
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            p=PushShortPixel(quantum_info->endian,p,&pixel);
            SetPixelGray(picture,ClampToQuantum(QuantumRange*
              HalfToSinglePrecision(pixel)),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushShortPixel(quantum_info->endian,p,&pixel);
        SetPixelGray(picture,ScaleShortToQuantum(pixel),q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(picture);
      }
      break;
    }
    case 32:
    {
      unsigned int
        pixel;

      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          float
            pixel;

          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            p=PushQuantumFloatPixel(quantum_info,p,&pixel);
            SetPixelGray(picture,ClampToQuantum(pixel),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          break;
        }
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushLongPixel(quantum_info->endian,p,&pixel);
        SetPixelGray(picture,ScaleLongToQuantum(pixel),q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(picture);
      }
      break;
    }
    case 64:
    {
      if (quantum_info->format == FloatingPointQuantumFormat)
        {
          double
            pixel;

          for (x=0; x < (ssize_t) number_pixels; x++)
          {
            p=PushDoublePixel(quantum_info,p,&pixel);
            SetPixelGray(picture,ClampToQuantum(pixel),q);
            p+=quantum_info->pad;
            q+=GetPixelChannels(picture);
          }
          break;
        }
    }
    default:
    {
      range=GetQuantumRange(quantum_info->depth);
      for (x=0; x < (ssize_t) number_pixels; x++)
      {
        p=PushQuantumPixel(quantum_info,p,&pixel);
        SetPixelGray(picture,ScaleAnyToQuantum(pixel,range),q);
        p+=quantum_info->pad;
        q+=GetPixelChannels(picture);
      }
      break;
    }
  }
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// MagickCore/quantum-import.c
// static void ImportGreenQuantum(const Image *image,QuantumInfo *quantum_info,
//   const MagickSizeType number_pixels,const unsigned char *magick_restrict p,
//   Quantum *magick_restrict q)
// {
//   QuantumAny
//     range;
// 
//   register ssize_t
//     x;
// 
//   unsigned int
//     pixel;
// 
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   switch (quantum_info->depth)
//   {
//     case 8:
//     {
//       unsigned char
//         pixel;
// 
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushCharPixel(p,&pixel);
//         SetPixelGreen(image,ScaleCharToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 16:
//     {
//       unsigned short
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 32:
//     {
//       unsigned int
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           float
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleLongToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 64:
//     {
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           double
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//     }
//     default:
//     {
//       range=GetQuantumRange(quantum_info->depth);
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//   }
// }

// the below code fragment can be found in:
// MagickCore/quantum-import.c
// static void ImportBGRAQuantum(const Image *image,QuantumInfo *quantum_info,
//   const MagickSizeType number_pixels,const unsigned char *magick_restrict p,
//   Quantum *magick_restrict q)
// {
//   QuantumAny
//     range;
// 
//   register ssize_t
//     x;
// 
//   unsigned int
//     pixel;
// 
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   switch (quantum_info->depth)
//   {
//     case 8:
//     {
//       unsigned char
//         pixel;
// 
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushCharPixel(p,&pixel);
//         SetPixelBlue(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelGreen(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelRed(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 10:
//     {
//       pixel=0;
//       if (quantum_info->pack == MagickFalse)
//         {
//           register ssize_t
//             i;
// 
//           size_t
//             quantum;
// 
//           ssize_t
//             n;
// 
//           n=0;
//           quantum=0;
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             for (i=0; i < 4; i++)
//             {
//               switch (n % 3)
//               {
//                 case 0:
//                 {
//                   p=PushLongPixel(quantum_info->endian,p,&pixel);
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 22) & 0x3ff) << 6)));
//                   break;
//                 }
//                 case 1:
//                 {
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 12) & 0x3ff) << 6)));
//                   break;
//                 }
//                 case 2:
//                 {
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 2) & 0x3ff) << 6)));
//                   break;
//                 }
//               }
//               switch (i)
//               {
//                 case 0: SetPixelRed(image,(Quantum) quantum,q); break;
//                 case 1: SetPixelGreen(image,(Quantum) quantum,q); break;
//                 case 2: SetPixelBlue(image,(Quantum) quantum,q); break;
//                 case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;
//               }
//               n++;
//             }
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 16:
//     {
//       unsigned short
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelAlpha(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelBlue(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelRed(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 32:
//     {
//       unsigned int
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           float
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelAlpha(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelBlue(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelRed(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 64:
//     {
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           double
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelAlpha(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//     }
//     default:
//     {
//       range=GetQuantumRange(quantum_info->depth);
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//   }
// }

// the below code fragment can be found in:
// MagickCore/quantum-import.c
// static void ImportRGBAQuantum(const Image *image,QuantumInfo *quantum_info,
//   const MagickSizeType number_pixels,const unsigned char *magick_restrict p,
//   Quantum *magick_restrict q)
// {
//   QuantumAny
//     range;
// 
//   register ssize_t
//     x;
// 
//   unsigned int
//     pixel;
// 
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   switch (quantum_info->depth)
//   {
//     case 8:
//     {
//       unsigned char
//         pixel;
// 
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushCharPixel(p,&pixel);
//         SetPixelRed(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelGreen(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelBlue(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelAlpha(image,ScaleCharToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 10:
//     {
//       pixel=0;
//       if (quantum_info->pack == MagickFalse)
//         {
//           register ssize_t
//             i;
// 
//           size_t
//             quantum;
// 
//           ssize_t
//             n;
// 
//           n=0;
//           quantum=0;
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             for (i=0; i < 4; i++)
//             {
//               switch (n % 3)
//               {
//                 case 0:
//                 {
//                   p=PushLongPixel(quantum_info->endian,p,&pixel);
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 22) & 0x3ff) << 6)));
//                   break;
//                 }
//                 case 1:
//                 {
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 12) & 0x3ff) << 6)));
//                   break;
//                 }
//                 case 2:
//                 {
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 2) & 0x3ff) << 6)));
//                   break;
//                 }
//               }
//               switch (i)
//               {
//                 case 0: SetPixelRed(image,(Quantum) quantum,q); break;
//                 case 1: SetPixelGreen(image,(Quantum) quantum,q); break;
//                 case 2: SetPixelBlue(image,(Quantum) quantum,q); break;
//                 case 3: SetPixelAlpha(image,(Quantum) quantum,q); break;
//               }
//               n++;
//             }
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 16:
//     {
//       unsigned short
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelAlpha(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelRed(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelBlue(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelAlpha(image,ScaleShortToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 32:
//     {
//       unsigned int
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           float
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelAlpha(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelRed(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelBlue(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelAlpha(image,ScaleLongToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 64:
//     {
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           double
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelAlpha(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//     }
//     default:
//     {
//       range=GetQuantumRange(quantum_info->depth);
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelAlpha(image,ScaleAnyToQuantum(pixel,range),q);
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//   }
// }

// the below code fragment can be found in:
// MagickCore/quantum-import.c
// static void ImportOpacityQuantum(const Image *image,QuantumInfo *quantum_info,
//   const MagickSizeType number_pixels,const unsigned char *magick_restrict p,
//   Quantum *magick_restrict q)
// {
//   QuantumAny
//     range;
// 
//   register ssize_t
//     x;
// 
//   unsigned int
//     pixel;
// 
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   switch (quantum_info->depth)
//   {
//     case 8:
//     {
//       unsigned char
//         pixel;
// 
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushCharPixel(p,&pixel);
//         SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 16:
//     {
//       unsigned short
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelOpacity(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 32:
//     {
//       unsigned int
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           float
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelOpacity(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 64:
//     {
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           double
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelOpacity(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//     }
//     default:
//     {
//       range=GetQuantumRange(quantum_info->depth);
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//   }
// }

// the below code fragment can be found in:
// MagickCore/quantum-import.c
// static void ImportBGROQuantum(const Image *image,QuantumInfo *quantum_info,
//   const MagickSizeType number_pixels,const unsigned char *magick_restrict p,
//   Quantum *magick_restrict q)
// {
//   QuantumAny
//     range;
// 
//   register ssize_t
//     x;
// 
//   unsigned int
//     pixel;
// 
//   assert(image != (Image *) NULL);
//   assert(image->signature == MagickCoreSignature);
//   switch (quantum_info->depth)
//   {
//     case 8:
//     {
//       unsigned char
//         pixel;
// 
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushCharPixel(p,&pixel);
//         SetPixelBlue(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelGreen(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelRed(image,ScaleCharToQuantum(pixel),q);
//         p=PushCharPixel(p,&pixel);
//         SetPixelOpacity(image,ScaleCharToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 10:
//     {
//       pixel=0;
//       if (quantum_info->pack == MagickFalse)
//         {
//           register ssize_t
//             i;
// 
//           size_t
//             quantum;
// 
//           ssize_t
//             n;
// 
//           n=0;
//           quantum=0;
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             for (i=0; i < 4; i++)
//             {
//               switch (n % 3)
//               {
//                 case 0:
//                 {
//                   p=PushLongPixel(quantum_info->endian,p,&pixel);
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 22) & 0x3ff) << 6)));
//                   break;
//                 }
//                 case 1:
//                 {
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 12) & 0x3ff) << 6)));
//                   break;
//                 }
//                 case 2:
//                 {
//                   quantum=(size_t) (ScaleShortToQuantum((unsigned short)
//                     (((pixel >> 2) & 0x3ff) << 6)));
//                   break;
//                 }
//               }
//               switch (i)
//               {
//                 case 0: SetPixelRed(image,(Quantum) quantum,q); break;
//                 case 1: SetPixelGreen(image,(Quantum) quantum,q); break;
//                 case 2: SetPixelBlue(image,(Quantum) quantum,q); break;
//                 case 3: SetPixelOpacity(image,(Quantum) quantum,q); break;
//               }
//               n++;
//             }
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelRed(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelBlue(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelOpacity(image,ScaleShortToQuantum((unsigned short) (pixel << 6)),
//           q);
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 16:
//     {
//       unsigned short
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p=PushShortPixel(quantum_info->endian,p,&pixel);
//             SetPixelOpacity(image,ClampToQuantum(QuantumRange*
//               HalfToSinglePrecision(pixel)),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelBlue(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelRed(image,ScaleShortToQuantum(pixel),q);
//         p=PushShortPixel(quantum_info->endian,p,&pixel);
//         SetPixelOpacity(image,ScaleShortToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 32:
//     {
//       unsigned int
//         pixel;
// 
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           float
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(pixel),q);
//             p=PushQuantumFloatPixel(quantum_info,p,&pixel);
//             SetPixelOpacity(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelBlue(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelGreen(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelRed(image,ScaleLongToQuantum(pixel),q);
//         p=PushLongPixel(quantum_info->endian,p,&pixel);
//         SetPixelOpacity(image,ScaleLongToQuantum(pixel),q);
//         p+=quantum_info->pad;
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//     case 64:
//     {
//       if (quantum_info->format == FloatingPointQuantumFormat)
//         {
//           double
//             pixel;
// 
//           for (x=0; x < (ssize_t) number_pixels; x++)
//           {
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelRed(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelGreen(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelBlue(image,ClampToQuantum(pixel),q);
//             p=PushDoublePixel(quantum_info,p,&pixel);
//             SetPixelOpacity(image,ClampToQuantum(pixel),q);
//             p+=quantum_info->pad;
//             q+=GetPixelChannels(image);
//           }
//           break;
//         }
//     }
//     default:
//     {
//       range=GetQuantumRange(quantum_info->depth);
//       for (x=0; x < (ssize_t) number_pixels; x++)
//       {
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelBlue(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q);
//         p=PushQuantumPixel(quantum_info,p,&pixel);
//         SetPixelOpacity(image,ScaleAnyToQuantum(pixel,range),q);
//         q+=GetPixelChannels(image);
//       }
//       break;
//     }
//   }
// }
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).