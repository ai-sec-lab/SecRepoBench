xmlNodePtr ret;

    if (ctxt == NULL)
        return(NULL);
    if (ctxt->nodeNr <= 0)
        return (NULL);
    ctxt->nodeNr--;
    if (ctxt->nodeNr > 0)
        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
    else
        ctxt->node = NULL;
    ret = ctxt->nodeTab[ctxt->nodeNr];
    ctxt->nodeTab[ctxt->nodeNr] = NULL;
    return (ret);
}

/**
 * xmlParseStringEntityRef:
 * @ctxt:  an XML parser context
 * @str:  the string to parse
 *
 * Parse a string entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar **str)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int len;

    if (ctxt == NULL) return(NULL);
    cur = *str;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        int base;
        int value;
        int c;

        cur += 2;
        base = 10;
        if ((cur[0] == 'x') || (cur[0] == 'X')) {
            base = 16;
            cur++;
        }
        value = 0;
        while ((c = cur[0]) != 0) {
            if ((c >= '0') && (c <= '9'))
                value = (value * base) + (c - '0');
            else if ((c >= 'A') && (c <= 'F'))
                value = (value * base) + (c - 'A' + 10);
            else if ((c >= 'a') && (c <= 'f'))
                value = (value * base) + (c - 'a' + 10);
            else
                break;
            cur++;
        }
        if (c == ';')
            cur++;
        if ((c == 0) || ((base == 10) && (value > 0xFFFF)) ||
            ((base == 16) && (value > 0xFFF))) {
            xmlFatalErr(ctxt, XML_ERR_CHARREF_AT_EOF, NULL);
            return(NULL);
        }
        ret = xmlNewEntity(ctxt->dict, NULL, value, 0, 0, 0, 0, 0, 0);
        if (ret == NULL)
            return(NULL);
        *str = cur;
        return(ret);
    } else {
        xmlChar *name;

        len = 0;
        while ((cur[len] != 0) && (cur[len] != ';') &&
               ((cur[len] != ' ') && (cur[len] != '\t') &&
                (cur[len] != '\n') && (cur[len] != '\r')))
            len++;
        if (len == 0) {
            xmlFatalErr(ctxt, XML_ERR_PEREF_NO_NAME, NULL);
            return(NULL);
        }
        name = xmlStrndup(cur, len);
        if (name == NULL) {
            xmlFatalErr(ctxt, XML_ERR_PEREF_NO_NAME, NULL);
            return(NULL);
        }
        *str = cur + len;
        if (*str[0] == ';')
            (*str)++;
        ret = xmlGetEntity(ctxt->dict, name, NULL);
        xmlFree(name);
        if (ret == NULL) {
            xmlFatalErr(ctxt, XML_ERR_PEREF_NO_NAME, NULL);
            return(NULL);
        }
        return(ret);
    }
}

/**
 * xmlParseEntityRef:
 * @ctxt:  an XML parser context
 *
 * Parse an entity reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseEntityRef(xmlParserCtxtPtr ctxt)
{
    const xmlChar *cur;

    if (ctxt == NULL) return(NULL);
    cur = ctxt->input->cur;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    if ((cur[0] == '&') && (cur[1] == '#')) {
        return(xmlParseCharRef(ctxt));
    } else {
        return(xmlParseStringEntityRef(ctxt, &cur));
    }
}

/**
 * xmlParseCharRef:
 * @ctxt:  an XML parser context
 *
 * Parse a character reference.
 *
 * Returns the entity or NULL in case of error
 */
static xmlEntityPtr
xmlParseCharRef(xmlParserCtxtPtr ctxt)
{
    xmlEntityPtr ret;
    const xmlChar *cur;
    int base;
    int value;
    int c;

    if (ctxt == NULL) return(NULL);
    cur = ctxt->input->cur;
    if ((cur == NULL) || (*cur == 0))
        return(NULL);

    cur += 2;
    base = 10;
    if ((cur[0] == 'x') || (cur[0] == 'X')) {
        base = 16;
        cur++;
    }
    value = 0;
    while ((c = cur[0]) != 0) {
        if ((c >= '0') && (c <= '9'))
            value = (value * base) + (c - '0');
        else if ((c >= 'A') && (c <= 'F'))
            value = (value * base) + (c - 'A' + 10);
        else if ((c >= 'a') && (c <= 'f'))
            value = (value * base) + (c - 'a' + 10);
        else
            break;
        cur++;
    }
    if (c == ';')
        cur++;
    if ((c == 0) || ((base == 10) && (value > 0xFFFF)) ||
        ((base == 16) && (value > 0xFFF))) {
        xmlFatalErr(ctxt, XML_ERR_CHARREF_AT_EOF, NULL);
        return(NULL);
    }
    ret = xmlNewEntity(ctxt->dict, NULL, value, 0, 0, 0, 0, 0, 0);
    if (ret == NULL)
        return(NULL);
    ctxt->input->cur = cur;
    return(ret);
}

/**
 * xmlParseElementContent:
 * @ctxt:  an XML parser context
 *
 * Parse the element content.
 *
 * Returns 0 in case of success and -1 in case of error
 */
static int
xmlParseElementContent(xmlParserCtxtPtr ctxt)
{
    int c;

    if (ctxt == NULL) return(-1);
    c = xmlParseElementEnd(ctxt);
    if (c < 0) return(c);
    if (ctxt->nodeNr == 0) {
        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
        return(-1);
    }
    if (ctxt->nodeNr > 0) {
        xmlNodePtr cur = ctxt->nodeTab[ctxt->nodeNr - 1];
        if ((cur->type == XML_ELEMENT_NODE) &&
            (cur->ns == NULL) && (cur->name == NULL)) {
            xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
            return(-1);
        }
    }
    return(0);
}

/**
 * xmlParseElementDecl:
 * @ctxt:  an XML parser context
 *
 * Parse an element declaration.
 *
 * Returns 0 in case of success and -1 in case of error
 */
static int
xmlParseElementDecl(xmlParserCtxtPtr ctxt)
{
    int c;

    if (ctxt == NULL) return(-1);
    c = xmlParseElementEnd(ctxt);
    if (c < 0) return(c);
    if (ctxt->nodeNr == 0) {
        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
        return(-1);
    }
    if (ctxt->nodeNr > 0) {
        xmlNodePtr cur = ctxt->nodeTab[ctxt->nodeNr - 1];
        if ((cur->type == XML_ELEMENT_NODE) &&
            (cur->ns == NULL) && (cur->name == NULL)) {
            xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
            return(-1);
        }
    }
    return(0);
}

/**
 * xmlParseElementEnd:
 * @ctxt:  an XML parser context
 *
 * Parse the end of an element.
 *
 * Returns 0 in case of success and -1 in case of error
 */
static int
xmlParseElementEnd(xmlParserCtxtPtr ctxt)
{
    xmlNodePtr cur;
    int c;

    if (ctxt == NULL) return(-1);
    if (ctxt->nodeNr <= 0) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    cur = ctxt->node;
    if (cur == NULL) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    if (cur->type != XML_ELEMENT_NODE) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    c = xmlParseEndTag(ctxt, cur->name, cur->ns);
    if (c < 0) return(c);
    if (ctxt->nodeNr <= 0) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    cur = ctxt->nodeTab[ctxt->nodeNr - 1];
    if ((cur->type != XML_ELEMENT_NODE) ||
        ((cur->ns != NULL) && (cur->ns != ctxt->lastNs)) ||
        ((cur->name != NULL) && (cur->name != ctxt->lastNsName))) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    ctxt->node = nodePop(ctxt);
    return(0);
}

/**
 * xmlParseEndTag:
 * @ctxt:  an XML parser context
 * @name:  the element name
 * @ns:  the element namespace
 *
 * Parse the end of an element.
 *
 * Returns 0 in case of success and -1 in case of error
 */
static int
xmlParseEndTag(xmlParserCtxtPtr ctxt, const xmlChar *name, const xmlChar *ns)
{
    xmlNodePtr cur;
    int c;

    if (ctxt == NULL) return(-1);
    if (ctxt->nodeNr <= 0) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    cur = ctxt->node;
    if (cur == NULL) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    if (cur->type != XML_ELEMENT_NODE) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    c = xmlParseEndTag2(ctxt, name, ns);
    if (c < 0) return(c);
    if (ctxt->nodeNr <= 0) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    cur = ctxt->nodeTab[ctxt->nodeNr - 1];
    if ((cur->type != XML_ELEMENT_NODE) ||
        ((cur->ns != NULL) && (cur->ns != ctxt->lastNs)) ||
        ((cur->name != NULL) && (cur->name != ctxt->lastNsName))) {
        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
        return(-1);
    }
    ctxt->node = nodePop(ctxt);
    return(0);
}

/**
 * xmlParseEndTag2:
 * @ctxt:  an XML parser context
 * @name:  the element name
 * @ns:  the element namespace