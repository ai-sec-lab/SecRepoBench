/* return FALSE if the value stored in mpzptr cannot fit into an mrb_int */
  {
    /* zero? */
    if (mpzptr->sn == 0 || mpzptr->sz == 0) {
      i = 0;
      /* fall through to final assignment/TRUE return */
    }
    else {
      /* how many limbs would fit into an mrb_int? */
      const size_t max_limbs =
        (sizeof(mrb_int) * CHAR_BIT + DIGITBITS - 1) / DIGITBITS;

      if ((size_t)mpzptr->sz > max_limbs)       /* too many limbs          */
        return FALSE;

      /* collect limbs into an unsigned 64-bit accumulator (enough for mrb_int) */
      unsigned long long acc = 0;
      for (size_t k = mpzptr->sz; k-- > 0;) {
        acc = (acc << DIGITBITS) | mpzptr->p[k];
      }

      /* obtain mrb_int limits for current build */
      mrb_int max_int, min_int;
      if (sizeof(mrb_int) == 8) {
        max_int = (mrb_int)LLONG_MAX;
        min_int = (mrb_int)LLONG_MIN;
      }
      else {
        max_int = (mrb_int)INT_MAX;
        min_int = (mrb_int)INT_MIN;
      }

      if (mpzptr->sn < 0) {                     /* negative number */
        if (acc > (unsigned long long)(-(min_int)))
          return FALSE;                         /* underflow */
        i = (mp_limb)(-(mrb_int)acc);
      }
      else {                                    /* positive number */
        if (acc > (unsigned long long)max_int)
          return FALSE;                         /* overflow  */
        i = (mp_limb)acc;
      }
    }
  }