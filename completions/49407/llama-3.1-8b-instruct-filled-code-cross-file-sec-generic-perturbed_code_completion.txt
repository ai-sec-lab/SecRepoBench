void map_coords (int *coords, unsigned int coords_length) const
  {
    unsigned int effectiveaxiscount = hb_min (coords_length, axisCount);

    const SegmentMaps *map = &firstAxisSegmentMaps;
    unsigned int *output = (unsigned int *) malloc (coords_length * sizeof (unsigned int));
    unsigned int *variation_store = (unsigned int *) malloc (coords_length * sizeof (unsigned int));

    for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      // Apply mapping transformation using the current SegmentMaps object
      coords[i] = map->transform (coords[i]);

      // Advance to the next SegmentMaps object
      map++;
    }

    if (version >= 2)
    {
      // Allocate variation index map and variation store cache
      VariationIndexMap *variation_index_map = get_variation_index_map ();
      VariationStoreCache *variation_store_cache = get_variation_store_cache ();

      for (unsigned int i = 0; i < effectiveaxiscount; i++)
      {
        // Apply additional transformation involving variation index map and variation store
        unsigned int variation_index = variation_index_map->get_index (coords[i]);
        unsigned int delta = variation_store_cache->get_delta (variation_index);
        unsigned int transformed_coord = coords[i] + delta;

        // Clamp the result to a specified range
        transformed_coord = clamp (transformed_coord, min_value, max_value);

        // Store the transformed value in the output vector
        output[i] = transformed_coord;
      }

      // Deallocate variation store cache
      free (variation_store_cache);
    }

    // Update the original coordinates array with the transformed values from the output vector
    for (unsigned int i = 0; i < effectiveaxiscount; i++)
    {
      coords[i] = output[i];
    }

    // Deallocate output vector and variation store cache
    free (output);
    free (variation_store);
  }