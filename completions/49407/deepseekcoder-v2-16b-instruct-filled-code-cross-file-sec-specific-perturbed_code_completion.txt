// Allocate an output vector for the transformed coordinates.
    std::vector<int> transformed_coords(effectiveaxiscount);

    // Process each coordinate
    for (unsigned int i = 0; i < effectiveaxiscount; ++i) {
        // Apply mapping transformation using the current SegmentMaps object
        transformed_coords[i] = map->apply_mapping(coords[i]);
        // Advance to the next SegmentMaps object
        map = map->next();
    }

    // If the version is 2 or higher, further process the coordinates using variation data
    if (version >= 2) {
        // Allocate a variation index map and a variation store
        std::vector<int> variation_index_map(effectiveaxiscount);
        std::vector<int> variation_store(effectiveaxiscount);

        // Compute a delta value for each coordinate
        for (unsigned int i = 0; i < effectiveaxiscount; ++i) {
            variation_index_map[i] = map->get_variation_index(coords[i]);
            variation_store[i] = map->get_variation_store(variation_index_map[i]);
            int delta = map->compute_delta(coords[i], variation_store[i]);

            // Adjust each coordinate by the rounded delta, clamp the result to a specified range, and store it in the output vector
            int rounded_delta = std::round(delta);
            int clamped_value = std::clamp(coords[i] + rounded_delta, min_range, max_range);
            transformed_coords[i] = clamped_value;
        }
    }

    // Deallocate the variation store cache
    // (Assuming there's a method to deallocate the cache, which is not shown in the provided code)

    // Update the original coordinates array with the transformed values from the output vector
    for (unsigned int i = 0; i < effectiveaxiscount; ++i) {
        coords[i] = transformed_coords[i];
    }