void map_coords (int *coords, unsigned int coords_length) const
  {
    unsigned int effectiveaxiscount = hb_min (coords_length, axisCount);

    const SegmentMaps *map = &firstAxisSegmentMaps;
    unsigned int *output = (unsigned int *) malloc (coords_length * sizeof (unsigned int));
    if (output == NULL) {
      // Handle memory allocation failure
      return;
    }

    for (unsigned int i = 0; i < effectiveaxiscount; i++) {
      // Apply mapping transformation using the current SegmentMaps object
      coords[i] = map->transform (coords[i]);

      // Advance to the next SegmentMaps object
      map++;
    }

    if (version >= 2) {
      // Allocate a variation store cache
      VariationStore *variation_store = variationStoreCache->get (coords_length);
      if (variation_store == NULL) {
        // Handle cache allocation failure
        free (output);
        return;
      }

      // Allocate a variation index map
      VariationIndexMap *variation_index_map = variationIndexMapCache->get (coords_length);
      if (variation_index_map == NULL) {
        // Handle cache allocation failure
        variationStoreCache->release (variation_store);
        free (output);
        return;
      }

      for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        // Apply an additional transformation involving a variation index map and a variation store
        unsigned int variation_index = variation_index_map->get (coords[i]);
        unsigned int delta = variation_store->get (variation_index);
        coords[i] += (delta + 0.5);
        coords[i] = hb_clamp (coords[i], min_value, max_value);
        output[i] = coords[i];
      }

      // Deallocate the variation store cache
      variationStoreCache->release (variation_store);
      variationIndexMapCache->release (variation_index_map);
    } else {
      // Copy the transformed values from the output vector to the original coordinates array
      for (unsigned int i = 0; i < effectiveaxiscount; i++) {
        coords[i] = output[i];
      }
    }

    free (output);
  }