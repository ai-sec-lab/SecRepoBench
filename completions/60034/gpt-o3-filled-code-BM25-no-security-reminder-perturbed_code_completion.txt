// discard entry_result if it is explicitly forbidden in compounds
        if (entry_result && !hu_mov_rule && compoundforbidflag &&
            TESTAFF(entry_result->astr, compoundforbidflag, entry_result->alen)) {
          entry_result = NULL;
        }

        /*  Walk through the homonym list until we find an entry that can really
            start a compound.  A candidate is acceptable when

              – it is not marked with NEEDAFFIX,
              – it carries one of the compound enabling flags
                (compoundflag / compoundbegin / compoundmiddle),
              – it fulfils possible CHECKCOMPOUNDPATTERN constraints.

           If a homonym fails any of these tests we continue with the next one.
        */
        while (entry_result &&
               (
                 /* words that need an affix cannot be first part of compound */
                 (needaffix &&
                  TESTAFF(entry_result->astr, needaffix, entry_result->alen)) ||

                 /* the entry lacks the required compound flags */
                 !(
                     (compoundflag && !words &&
                      TESTAFF(entry_result->astr, compoundflag, entry_result->alen)) ||
                     ((wordnum == 0) && compoundbegin &&
                      TESTAFF(entry_result->astr, compoundbegin, entry_result->alen)) ||
                     ((wordnum > 0) && compoundmiddle &&
                      TESTAFF(entry_result->astr, compoundmiddle, entry_result->alen))
                   ) ||

                 /* does not satisfy extra CHECKCOMPOUNDPATTERN condition        */
                 (scpd != 0 &&
                  checkcpdtable[scpd - 1].cond != FLAG_NULL &&
                  !TESTAFF(entry_result->astr,
                           checkcpdtable[scpd - 1].cond,
                           entry_result->alen))
               )) {
          entry_result = entry_result->next_homonym;
        }