// <MASK>
mrb_value val = GETARG();
double fval;

if (mrb_float_p(val)) {
    fval = mrb_float(val);
}
else {
    fval = (double)mrb_as_float(mrb, val);
}

if (isfinite(fval)) {
    char fbuf[32];
    int need, n;
    char sign = '\0';

    if (fval >= 0.0) {
        if (flags & FPLUS) {
            sign = '+';
            width--;
        }
        else if (flags & FSPACE) {
            sign = ' ';
            width--;
        }
    }
    else {
        sign = '-';
        width--;
    }

    fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
    need = 0;
    if (*p != 'e' && *p != 'E') {
        int i;
        frexp(fval, &i);
        if (i > 0)
            need = BIT_DIGITS(i);
    }
    if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
        goto too_big_width;
    }
    need += (flags&FPREC) ? prec : 6;
    if ((flags&FWIDTH) && need < width)
        need = width;
    if (need > MRB_INT_MAX - 20) {
        goto too_big_width;
    }
    need += 20;

    CHECK(need);
    if (sign) {
        buf[blen++] = sign;
    }
    n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
    if (n < 0 || n >= need) {
        mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
    }
    blen += n;
}
else {
    const char *str = isnan(fval) ? "NaN" : "Inf";
    int len = (int)strlen(str);
    if ((flags & FWIDTH) && len < width) {
        if (!(flags & FMINUS)) {
            FILL(' ', width - len);
        }
        PUSH(str, len);
        if (flags & FMINUS) {
            FILL(' ', width - len);
        }
    }
    else {
        PUSH(str, len);
    }
}