// Retrieve the next argument and convert it to a float.
mrb_value val = GETARG();
double fval = mrb_float(mrb_convert_type(mrb, val, MRB_TT_FLOAT, "Float", NULL));

// Check if the float value is finite. If the value is NaN (Not a Number) or
// Infinity, prepare to format it as "NaN" or "Inf" respectively, 
// including potential sign handling ('+' or ' ' for positive numbers if specified).
int sign = 0;
if (isfinite(fval)) {
  if (fval >= 0.0) {
    if (flags & FPLUS) {
      sign = 1;
      width--;
    } else if (flags & FSPACE) {
      sign = 1;
      width--;
    }
  } else {
    sign = -1;
    width--;
  }
} else {
  const char* inf_str = (fval > 0.0) ? "Inf" : "-Inf";
  const char* nan_str = "NaN";
  int len = (fval > 0.0 && (flags & FPLUS)) ? 4 : 3;
  if (width > len) {
    width -= len;
    if (!(flags & FMINUS)) {
      FILL(' ', width);
    }
    PUSH(fval > 0.0 && (flags & FPLUS) ? "+" : "", sign == 1);
    PUSH(fval == 0.0 ? nan_str : inf_str, len);
    if (flags & FMINUS) {
      FILL(' ', width);
    }
    break;
  }
}

// Calculate the number of characters needed for representation, considering any specified
// width and flags. If the width is greater than the calculated size, adjust accordingly.
char fbuf[64];
int need;
fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
need = 0;
if (*p != 'e' && *p != 'E') {
  int i;
  frexp(fval, &i);
  if (i > 0)
    need = BIT_DIGITS(i);
}
if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
  goto too_big_width;
}
need += (flags&FPREC) ? prec : 6;
if ((flags&FWIDTH) && need < width)
  need = width;
if (need > MRB_INT_MAX - 20) {
  goto too_big_width;
}
need += 20;

// Handle padding and alignment (left or right) based on flags before storing the result
// in the buffer.
CHECK(need);
n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
if (n < 0 || n >= need) {
  mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
}
blen += n;