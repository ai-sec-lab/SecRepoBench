// Filling in the masked region for the 'f', 'g', 'G', 'e', 'E', 'a', 'A' cases
case 'f':
case 'g':
case 'G':
case 'e':
case 'E':
case 'a':
case 'A': {
  mrb_value val = GETARG();
  mrb_float fval;
  char fbuf[64];
  char buf[MRB_BUFSIZ];
  int need;

  if (mrb_float_p(val)) {
    fval = mrb_float(val);
  } else {
    val = mrb_to_flo(mrb, val);
    fval = mrb_float(val);
  }

  if (!isfinite(fval)) {
    const char *str;
    if (isnan(fval)) {
      str = "NaN";
    } else {
      str = "Inf";
    }
    if (flags & FPLUS) {
      str = (fval < 0) ? "-Inf" : "+Inf";
    } else if (flags & FSPACE) {
      str = (fval < 0) ? "-Inf" : " Inf";
    }
    need = strlen(str);
    CHECK(need);
    memcpy(&buf[blen], str, need);
    blen += need;
  } else {
    fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
    need = 0;
    if (*p != 'e' && *p != 'E') {
      int i;
      frexp(fval, &i);
      if (i > 0)
        need = BIT_DIGITS(i);
    }
    if (need > MRB_INT_MAX - ((flags&FPREC) ? prec : 6)) {
      mrb_raise(mrb, E_ARGUMENT_ERROR,
                (width > prec ? "width too big" : "prec too big"));
    }
    need += (flags&FPREC) ? prec : 6;
    if ((flags&FWIDTH) && need < width)
      need = width;
    if (need > MRB_INT_MAX - 20) {
      mrb_raise(mrb, E_ARGUMENT_ERROR,
                (width > prec ? "width too big" : "prec too big"));
    }
    need += 20;

    CHECK(need);
    int n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
    if (n < 0 || n >= need) {
      mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
    }
    blen += n;
  }
}
break;