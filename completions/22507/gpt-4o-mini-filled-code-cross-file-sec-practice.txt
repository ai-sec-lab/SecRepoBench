mrb_value val = GETARG();
        mrb_float fval;

        // Validate the argument type to ensure it is a number or can be converted to a float
        if (mrb_type(val) == MRB_TT_FLOAT) {
            fval = mrb_float(val);
        } else if (mrb_fixnum_p(val)) {
            fval = (mrb_float)mrb_fixnum(val);
        } else {
            // Attempt to convert the value to a float
            val = mrb_Float(mrb, val);
            fval = mrb_float(val);
        }

        // Check if the float value is finite
        if (isnan(fval)) {
            // Handle NaN case
            PUSH("NaN", 3);
        } else if (isinf(fval)) {
            // Handle Infinity case
            if (fval > 0) {
                PUSH("Inf", 3);
            } else {
                PUSH("-Inf", 4);
            }
        } else {
            // Format the float value into the buffer
            char fbuf[64]; // Buffer for formatted float
            fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
            int need = 0;

            // Calculate the number of characters needed for representation
            if (*p != 'e' && *p != 'E') {
                int exponent;
                frexp(fval, &exponent);
                if (exponent > 0) {
                    need = BIT_DIGITS(exponent);
                }
            }
            if (need > MRB_INT_MAX - ((flags & FPREC) ? prec : 6)) {
                goto too_big_width;
            }
            need += (flags & FPREC) ? prec : 6;
            if ((flags & FWIDTH) && need < width) {
                need = width;
            }
            if (need > MRB_INT_MAX - 20) {
                goto too_big_width;
            }
            need += 20;

            CHECK(need);
            n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
            if (n < 0 || n >= need) {
                mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
            }
            blen += n;
        }