mrb_value val = GETARG();
        mrb_float fval;

        // Convert the argument to a float
        if (mrb_type(val) == MRB_TT_FLOAT) {
            fval = mrb_float(val);
        } else {
            val = mrb_Float(mrb, val);
            fval = mrb_float(val);
        }

        // Check if the float value is finite
        if (isnan(fval)) {
            // Handle NaN case
            fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
            n = snprintf(&buf[blen], sizeof(buf) - blen, "NaN");
            if (n < 0 || n >= sizeof(buf) - blen) {
                mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
            }
            blen += n;
            continue;
        } else if (isinf(fval)) {
            // Handle Infinity case
            fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
            n = snprintf(&buf[blen], sizeof(buf) - blen, (fval > 0) ? "Inf" : "-Inf");
            if (n < 0 || n >= sizeof(buf) - blen) {
                mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
            }
            blen += n;
            continue;
        }

        // Prepare to format the float value
        fmt_setup(fbuf, sizeof(fbuf), *p, flags, width, prec);
        need = 0;
        if (*p != 'e' && *p != 'E') {
            int i;
            frexp(fval, &i);
            if (i > 0)
                need = BIT_DIGITS(i);
        }
        if (need > MRB_INT_MAX - ((flags & FPREC) ? prec : 6)) {
            goto too_big_width;
        }
        need += (flags & FPREC) ? prec : 6;
        if ((flags & FWIDTH) && need < width)
            need = width;
        if (need > MRB_INT_MAX - 20) {
            goto too_big_width;
        }
        need += 20;

        CHECK(need);
        n = mrb_float_to_cstr(mrb, &buf[blen], need, fbuf, fval);
        if (n < 0 || n >= need) {
            mrb_raise(mrb, E_RUNTIME_ERROR, "formatting error");
        }
        blen += n;