// Check if the codec ID is AV_CODEC_ID_HYMT and validate the buffer size
// and specific conditions at the end of the packet data. This helps determine
// the number of slices, slice height, and offset for slice information.
// The conditions ensure that the calculated offsets and sizes do not exceed
// the available buffer, and that the slice height is positive. If the conditions
// are not met, an error is returned. If the codec ID does not match, default to
// a single slice covering the full height.
if (avctx->codec_id == AV_CODEC_ID_HYMT) {
    // Check if the buffer size is sufficient to contain the slice information
    if (buf_size < 8 + (nb_slices - 1) * 8) {
        return AVERROR_INVALIDDATA;
    }

    // Calculate the slice height
    slice_height = (height + (nb_slices - 1) * slice_height) / nb_slices;

    // Validate the slice information
    for (slice = 0; slice < nb_slices; slice++) {
        unsigned slice_info_offset = 8 + slice * 8;
        unsigned slice_info_size = AV_RL32(buf + slice_info_offset);
        if (slice_info_size > buf_size - slice_info_offset) {
            return AVERROR_INVALIDDATA;
        }
        if (slice_info_size < 8) {
            return AVERROR_INVALIDDATA;
        }
    }
} else {
    // Default to a single slice covering the full height
    nb_slices = 1;
    slice_height = height;
}