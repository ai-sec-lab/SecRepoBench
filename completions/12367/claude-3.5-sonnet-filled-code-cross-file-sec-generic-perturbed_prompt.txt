Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                        AVPacket *packet)
{
    const uint8_t *buf = packet->data;
    int buf_size       = packet->size;
    HYuvContext *s = avctx->priv_data;
    const int width  = s->width;
    const int height = s->height;
    ThreadFrame frame = { .f = data };
    AVFrame *const p = data;
    int slice, table_size = 0, ret, nb_slices;
    unsigned slices_info_offset;
    int slice_height;

    if (buf_size < (width * height + 7)/8)
        return AVERROR_INVALIDDATA;

    av_fast_padded_malloc(&s->bitstream_buffer,
                   &s->bitstream_buffer_size,
                   buf_size);
    if (!s->bitstream_buffer)
        return AVERROR(ENOMEM);

    s->bdsp.bswap_buf((uint32_t *) s->bitstream_buffer,
                      (const uint32_t *) buf, buf_size / 4);

    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)
        return ret;

    if (s->context) {
        table_size = read_huffman_tables(s, s->bitstream_buffer, buf_size);
        if (table_size < 0)
            return table_size;
    }

    if ((unsigned) (buf_size - table_size) >= INT_MAX / 8)
        return AVERROR_INVALIDDATA;

    s->last_slice_end = 0;

    if (avctx->codec_id == AV_CODEC_ID_HYMT &&
        (buf_size > 32 && AV_RL32(packet->data + buf_size - 16) == 0)) {
        // Check if the codec ID is AV_CODEC_ID_HYMT and validate the buffer size
        // and specific conditions at the end of the packet data. This helps determine
        // the number of slices, slice height, and offset for slice information.
        // The conditions ensure that the calculated offsets and sizes do not exceed
        // the available buffer, and that the slice height is positive. If the conditions
        // are not met, an error is returned. If the codec ID does not match, default to
        // a single slice covering the full height.
        // <MASK>
    } else {
        slice_height = height;
        nb_slices = 1;
    }

    for (slice = 0; slice < nb_slices; slice++) {
        int y_offset, slice_offset, slice_size;

        if (nb_slices > 1) {
            slice_offset = AV_RL32(packet->data + slices_info_offset + slice * 8);
            slice_size = AV_RL32(packet->data + slices_info_offset + slice * 8 + 4);
            y_offset = height - (slice + 1) * slice_height;
            s->bdsp.bswap_buf((uint32_t *)s->bitstream_buffer,
                              (const uint32_t *)(buf + slice_offset), slice_size / 4);
        } else {
            y_offset = 0;
            slice_offset = 0;
            slice_size = buf_size;
        }

        ret = decode_slice(avctx, p, slice_height, slice_size, y_offset, table_size);
        emms_c();
        if (ret < 0)
            return ret;
    }

    *got_frame = 1;

    return (get_bits_count(&s->gb) + 31) / 32 * 4 + table_size;
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// libavcodec/asvdec.c
static av_cold int decode_init(AVCodecContext *avctx)
{
    ASV1Context *const a = avctx->priv_data;
    const int scale      = avctx->codec_id == AV_CODEC_ID_ASV1 ? 1 : 2;
    int i;

    if (avctx->extradata_size < 1) {
        av_log(avctx, AV_LOG_WARNING, "No extradata provided\n");
    }

    ff_asv_common_init(avctx);
    ff_blockdsp_init(&a->bdsp, avctx);
    ff_idctdsp_init(&a->idsp, avctx);
    init_vlcs(a);
    ff_init_scantable(a->idsp.idct_permutation, &a->scantable, ff_asv_scantab);
    avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    if (avctx->extradata_size < 1 || (a->inv_qscale = avctx->extradata[0]) == 0) {
        av_log(avctx, AV_LOG_ERROR, "illegal qscale 0\n");
        if (avctx->codec_id == AV_CODEC_ID_ASV1)
            a->inv_qscale = 6;
        else
            a->inv_qscale = 10;
    }

    for (i = 0; i < 64; i++) {
        int index = ff_asv_scantab[i];

        a->intra_matrix[i] = 64 * scale * ff_mpeg1_default_intra_matrix[index] /
                             a->inv_qscale;
    }

    return 0;
}

// the below code fragment can be found in:
// libavcodec/aic.c
static av_cold int aic_decode_init(AVCodecContext *avctx)
{
    AICContext *ctx = avctx->priv_data;
    int i;
    uint8_t scan[64];

    ctx->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    ff_idctdsp_init(&ctx->idsp, avctx);

    for (i = 0; i < 64; i++)
        scan[i] = i;
    ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, scan);
    for (i = 0; i < 64; i++)
        ctx->quant_matrix[ctx->idsp.idct_permutation[i]] = aic_quant_matrix[i];

    ctx->mb_width  = FFALIGN(avctx->width,  16) >> 4;
    ctx->mb_height = FFALIGN(avctx->height, 16) >> 4;

    ctx->num_x_slices = (ctx->mb_width + 15) >> 4;
    ctx->slice_width  = 16;
    for (i = 1; i < ctx->mb_width; i++) {
        if (!(ctx->mb_width % i) && (ctx->mb_width / i <= 32)) {
            ctx->slice_width  = ctx->mb_width / i;
            ctx->num_x_slices = i;
            break;
        }
    }

    ctx->slice_data = av_malloc_array(ctx->slice_width, AIC_BAND_COEFFS
                                * sizeof(*ctx->slice_data));
    if (!ctx->slice_data) {
        av_log(avctx, AV_LOG_ERROR, "Error allocating slice buffer\n");

        return AVERROR(ENOMEM);
    }

    for (i = 0; i < NUM_BANDS; i++)
        ctx->data_ptr[i] = ctx->slice_data + ctx->slice_width
                                             * aic_band_off[i];

    return 0;
}

// the below code fragment can be found in:
// libavcodec/magicyuv.c
static int magy_init_thread_copy(AVCodecContext *avctx)
{
    MagicYUVContext *s = avctx->priv_data;
    int i;

    for (i = 0; i < FF_ARRAY_ELEMS(s->slices); i++) {
        s->slices[i] = NULL;
        s->slices_size[i] = 0;
    }

    return 0;
}

// the below code fragment can be found in:
// libavcodec/mdec.c
static av_cold int decode_init(AVCodecContext *avctx)
{
    MDECContext * const a = avctx->priv_data;
    int i;

    a->mb_width  = (avctx->coded_width  + 15) / 16;
    a->mb_height = (avctx->coded_height + 15) / 16;

    a->avctx           = avctx;

    ff_blockdsp_init(&a->bdsp, avctx);
    ff_bswapdsp_init(&a->bbdsp);
    ff_idctdsp_init(&a->idsp, avctx);
    ff_mpeg12_init_vlcs();
    ff_init_scantable(a->idsp.idct_permutation, &a->scantable,
                      ff_zigzag_direct);

    avctx->pix_fmt  = AV_PIX_FMT_YUVJ420P;
    avctx->color_range = AVCOL_RANGE_JPEG;

    /* init q matrix */
    for (i = 0; i < 64; i++) {
        int j = a->idsp.idct_permutation[i];

        a->quant_matrix[j] = ff_mpeg1_default_intra_matrix[i];
    }

    return 0;
}

// the below code fragment can be found in:
// libavcodec/eatgq.c
static int tgq_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_frame,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    TgqContext *s      = avctx->priv_data;
    AVFrame *frame     = data;
    int x, y, ret;
    int big_endian;

    if (buf_size < 16) {
        av_log(avctx, AV_LOG_WARNING, "truncated header\n");
        return AVERROR_INVALIDDATA;
    }
    big_endian = AV_RL32(&buf[4]) > 0x000FFFFF;
    bytestream2_init(&s->gb, buf + 8, buf_size - 8);
    if (big_endian) {
        s->width  = bytestream2_get_be16u(&s->gb);
        s->height = bytestream2_get_be16u(&s->gb);
    } else {
        s->width  = bytestream2_get_le16u(&s->gb);
        s->height = bytestream2_get_le16u(&s->gb);
    }

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    tgq_calculate_qtable(s, bytestream2_get_byteu(&s->gb));
    bytestream2_skip(&s->gb, 3);

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    frame->key_frame = 1;
    frame->pict_type = AV_PICTURE_TYPE_I;

    for (y = 0; y < FFALIGN(avctx->height, 16) >> 4; y++)
        for (x = 0; x < FFALIGN(avctx->width, 16) >> 4; x++)
            if (tgq_decode_mb(s, frame, y, x) < 0)
                return AVERROR_INVALIDDATA;

    *got_frame = 1;

    return avpkt->size;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).