{
	      /* Common Name (CN) found inside the X509 certificate */
	      u_int8_t server_len = packet->payload[i+4];

	      /* Make sure the length is sane and the packet is not truncated    */
	      /* NOTE: we expect at least server_len printable bytes to follow   */
	      if((server_len > 0) && ((i + 5 + server_len) < packet->payload_packet_len)) {
		char *server_name = (char *)&packet->payload[i+5];
		u_int   copy_len   = (u_int)ndpi_min(server_len, buffer_len-1);
		u_int   k, is_printable = 1;

		/* Copy the server name */
		strncpy(buffer, server_name, copy_len);
		buffer[copy_len] = '\0';

		/* Remove eventual trailing characters (ASN.1 trailers, blanks, â€¦) */
		stripCertificateTrailer(buffer, buffer_len);

		/* Check that the string is made of printable characters           */
		for(k = 0; k < copy_len; k++) {
		  if(!ndpi_isprint(buffer[k])) {
		    is_printable = 0;
		    break;
		  }
		}

		if(is_printable) {
		  /* Store the server certificate string for export                */
		  if(!ndpi_struct->disable_metadata_export) {
		    snprintf(flow->protos.stun_ssl.ssl.server_certificate,
			     sizeof(flow->protos.stun_ssl.ssl.server_certificate),
			     "%s", buffer);
		  }

		  /* Try to match the hostname/IP against known application proto  */
		  /* This works only if it looks like a hostname (contains a dot). */
		  if(strchr(buffer, '.') != NULL) {
		    ndpi_match_host_subprotocol(ndpi_struct, flow, buffer);
		  }

		  /* All done: we found a valid server certificate CN              */
		  return(1 /* Server Certificate */);
		}
	      }
	    }