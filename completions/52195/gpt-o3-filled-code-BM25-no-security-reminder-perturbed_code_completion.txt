// --- prepare second part of the word ---------------------------------
            // handle simplified triple-letter checking (ll+l or l+ll sequences)
            // if enabled (checkcompoundtriple) and we have not processed it yet
            // we try both segmentation variants:
            //
            //   ...XYY Y...   -> first try  X | YYY...
            //                    second try XY | YY...
            //
            // this is done by backing up the position ‘i’ by one character after
            // the first unsuccessful attempt so the outer loop can re–evaluate
            // the second possibility.
            //
            // set striple to 1 if we are in the first pass and the pattern
            // matches, otherwise leave it at 0.
            //
            if (!checkedstriple && checkcompoundtriple && !compound_words &&
                (i > 0) && (i + 1 < (int)word.size()) &&
                word[i - 1] == word[i] && word[i] == word[i + 1]) {
              // pattern lll detected (e.g. “eee” in “coffeee”)
              striple = 1;
              checkedstriple = 1;
            }

            // lookup the remainder of the word beginning at position i
            // (this is the candidate for the second root word)
            sfx = NULL;
            pfx = NULL;
            rv = lookup(word.c_str() + i, word.size() - i);

            // Skip stems that cannot start a compound (see comments above).
            while (rv && compoundforbidflag &&
                   TESTAFF(rv->astr, compoundforbidflag, rv->alen)) {
              rv = rv->next_homonym;
            }

            // If triple-letter handling is active and nothing was found, we
            // let the surrounding loop retry with the alternative split point.
            if (!rv && striple) {
              continue;  // control will go to while (striple && !checkedstriple)
            }