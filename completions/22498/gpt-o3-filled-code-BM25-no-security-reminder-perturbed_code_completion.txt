{
    /* Maximum number of lines that can be stored in the current packet structure */
    const u_int32_t max_lines = (u_int32_t)(sizeof(packet->line) / sizeof(packet->line[0]));

    /* Walk through the payload looking for "\r\n"      */
    /* Each occurrence marks the end of the current line */
    for(a = 0;
        (a + 1) < packet->payload_packet_len &&            /* at least two bytes left */
        packet->parsed_lines < (max_lines - 1);            /* leave space for last entry */
        a++) {

      if(packet->payload[a] == '\r' && packet->payload[a + 1] == '\n') {
        /* Terminate current line */
        packet->line[packet->parsed_lines].len =
          (u_int16_t)(((unsigned long)&packet->payload[a]) -
                      ((unsigned long)packet->line[packet->parsed_lines].ptr));

        /* Move to the next line */
        packet->parsed_lines++;

        /* Check for double CR/LF => empty line separating header/body */
        if((a + 3) < packet->payload_packet_len &&
           packet->payload[a + 2] == '\r' &&
           packet->payload[a + 3] == '\n') {
          /* Empty line */
          packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
          packet->line[packet->parsed_lines].len = 0;
          /* We stop parsing header lines here */
          break;
        } else {
          /* Normal next line */
          packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];
          packet->line[packet->parsed_lines].len = 0;
        }

        /* Skip the '\n', the for() loop will increment 'a' again */
        a += 1;
      }
    }
  }