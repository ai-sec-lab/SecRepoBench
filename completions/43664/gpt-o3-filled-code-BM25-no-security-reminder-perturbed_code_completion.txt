} else if(extension_id == 43 /* supported versions */) {
		/* RFC 8446: In ClientHello the first byte is the list length,
		 * followed by 2-byte version identifiers. */
		u_int32_t s_off = offset + extension_offset;
		if((s_off < total_len) && (extension_len >= 3)) {
		  u_int8_t list_len = packet->payload[s_off];
		  u_int32_t v_off   = 1; /* Skip the length byte */

#ifdef DEBUG_TLS
		  printf("Client TLS [SUPPORTED_VERSIONS: list_len=%u]\n", list_len);
#endif
		  while((v_off + 1) < list_len &&
			(s_off + v_off + 1) < total_len) {
		    u_int16_t vers = ntohs(*((u_int16_t*)&packet->payload[s_off + v_off]));

		    /* Skip GREASE values (high and low byte identical) */
		    if(packet->payload[s_off + v_off] != packet->payload[s_off + v_off + 1]) {
		      char ver_buf[8];
		      size_t cur_len = strlen(ja3.client.supported_versions);
		      int rc = snprintf(ver_buf, sizeof(ver_buf), "%s%u",
					(cur_len > 0) ? "-" : "", vers);

		      if(rc > 0 &&
			 (cur_len + rc) < sizeof(ja3.client.supported_versions))
			strcat(ja3.client.supported_versions, ver_buf);
		    }

		    v_off += 2;
		  }
#ifdef DEBUG_TLS
		  printf("Client TLS [SUPPORTED_VERSIONS: %s]\n", ja3.client.supported_versions);
#endif
		}
	      } else if(extension_id == 0xFFCE /* encrypted server name (ESNI) */) {
		/* Just flag the presence of ESNI; detailed parsing, if any,
		 * is handled elsewhere. */
#ifdef DEBUG_TLS
		printf("Client TLS [ESNI present]\n");
#endif
		flow->protos.tls_quic.encrypted_sni.esni = 1;
	      } else if(is_quic && extension_id == 57 /* QUIC transport parameters */) {
#ifdef DEBUG_TLS
		printf("Client TLS [QUIC transport parameters len=%u]\n", extension_len);
#endif
		/* For now we simply acknowledge the presence of the extension.
		 * Detailed QUIC TP parsing (e.g., user-agent extraction) can be
		 * performed in a dedicated QUIC dissector. */
	      }