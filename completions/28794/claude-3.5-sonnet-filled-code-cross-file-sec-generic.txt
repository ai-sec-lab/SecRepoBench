if (base.arguments().size() == 1 && base.arguments()[0]->type().isScalar()) {
    // If the base constructor has a single scalar argument, we can simplify
    // the swizzle by reducing its size.
    replacement = construct(&componentType.toCompound(fContext, swizzleSize),
                            base.arguments()[0]->clone());
} else {
    // Map the arguments of the constructor
    std::vector<int> argMap(base.arguments().size());
    std::vector<int> argCount(base.arguments().size(), 0);
    for (int8_t c : s.components()) {
        argMap[c]++;
    }

    // Count how many times each argument is used
    bool canOptimize = true;
    for (size_t i = 0; i < base.arguments().size(); ++i) {
        if (argMap[i] > 0) {
            if (base.arguments()[i]->hasSideEffects()) {
                // If an argument has side effects, it must appear exactly once
                if (argMap[i] != 1) {
                    canOptimize = false;
                    break;
                }
            } else if (!base.arguments()[i]->isConstant()) {
                // If a non-constant argument appears more than once, we can't optimize
                if (argMap[i] > 1) {
                    canOptimize = false;
                    break;
                }
            }
        }
    }

    if (canOptimize) {
        // Create a new set of arguments for the optimized constructor
        ExpressionArray optimizedArgs;
        optimizedArgs.reserve_back(swizzleSize);
        for (int8_t c : s.components()) {
            optimizedArgs.push_back(base.arguments()[c]->clone());
        }
        replacement = std::make_unique<Constructor>(s.fOffset,
                                                    &componentType.toCompound(fContext, swizzleSize),
                                                    std::move(optimizedArgs));
    }
}

if (replacement) {
    optimizationContext->fUpdated = true;
    // Update usage information
    optimizationContext->fUsage->add(replacement.get());
    optimizationContext->fUsage->remove(&s);
    for (const auto& arg : base.arguments()) {
        optimizationContext->fUsage->remove(arg.get());
    }
    if (!try_replace_expression(&b, iter, &replacement)) {
        optimizationContext->fNeedsRescan = true;
        return;
    }
    SkASSERT((*iter)->isExpression());
}