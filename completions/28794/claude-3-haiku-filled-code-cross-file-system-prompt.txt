// This code block optimizes swizzles applied to constructors in expressions.
// It checks if the base constructor has a single scalar argument and optimizes
// it by reducing the swizzle size. For more complex expressions, it maps the
// arguments of the constructor and counts their usage within the swizzle. It
// then determines if the swizzle can be optimized by ensuring that non-trivial
// expressions are not repeated and expressions with side effects occur exactly
// once. If safe, it reorders and simplifies the arguments, creating a new
// constructor expression that avoids unnecessary computation and duplication.
if (base.arguments().size() == 1 && componentType.isScalar()) {
    // Optimize a swizzle of a single-argument constructor.
    // E.g. float4(x).xyxy -> float4(x, x, x, x)
    ExpressionArray args;
    for (int c : s.components()) {
        args.push_back(base.arguments()[0]->clone());
    }
    replacement = std::make_unique<Constructor>(s.fOffset, &s.type(), std::move(args));
} else {
    // Optimize a swizzle of a multi-argument constructor.
    // E.g. float4(x, y, z, w).ywxz -> float4(y, w, x, z)
    ExpressionArray args;
    std::vector<int> usageCount(base.arguments().size(), 0);
    for (int c : s.components()) {
        args.push_back(base.arguments()[c]->clone());
        usageCount[c]++;
    }
    // Ensure that non-trivial expressions are not repeated and expressions with side effects occur exactly once.
    if (std::all_of(usageCount.begin(), usageCount.end(), [](int count) { return count <= 1; })) {
        replacement = std::make_unique<Constructor>(s.fOffset, &s.type(), std::move(args));
    }
}
if (replacement) {
    optimizationContext->fUpdated = true;
    if (!try_replace_expression(&b, iter, &replacement)) {
        optimizationContext->fNeedsRescan = true;
        return;
    }
    SkASSERT((*iter)->isExpression());
}