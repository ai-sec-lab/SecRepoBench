// This code block optimizes swizzles applied to constructors in expressions.
// It checks if the base constructor has a single scalar argument and optimizes
// it by reducing the swizzle size. For more complex expressions, it maps the
// arguments of the constructor and counts their usage within the swizzle. It
// then determines if the swizzle can be optimized by ensuring that non-trivial
// expressions are not repeated and expressions with side effects occur exactly
// once. If safe, it reorders and simplifies the arguments, creating a new
// constructor expression that avoids unnecessary computation and duplication.
if (base.arguments().size() == 1 && componentType.isScalar()) {
    // Optimization for single-argument constructors.
    // Replace `foo.xxxx` with `foo`.
    optimizationContext->fUpdated = true;
    if (!try_replace_expression(&b, iter, &base.arguments()[0])) {
        optimizationContext->fNeedsRescan = true;
        return;
    }
    SkASSERT((*iter)->isExpression());
} else {
    // Optimization for multi-argument constructors.
    ExpressionArray optimizedArgs;
    optimizedArgs.reserve_back(swizzleSize);
    std::unordered_map<Expression*, int> argUsage;
    for (const std::unique_ptr<Expression>& arg : base.arguments()) {
        argUsage[arg.get()]++;
    }
    for (int c : s.components()) {
        const std::unique_ptr<Expression>& arg = base.arguments()[c];
        if (argUsage[arg.get()] == 1 && !arg->hasSideEffects()) {
            optimizedArgs.push_back(arg->clone());
        } else {
            optimizedArgs.push_back(construct(&componentType, arg->clone()));
        }
    }
    optimizationContext->fUpdated = true;
    std::unique_ptr<Expression> replacement(new Constructor(s.fOffset, &componentType, std::move(optimizedArgs)));
    if (!try_replace_expression(&b, iter, &replacement)) {
        optimizationContext->fNeedsRescan = true;
        return;
    }
    SkASSERT((*iter)->isExpression());
}