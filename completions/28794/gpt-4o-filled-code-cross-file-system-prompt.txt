// This code block optimizes swizzles applied to constructors in expressions.
                // It checks if the base constructor has a single scalar argument and optimizes
                // it by reducing the swizzle size. For more complex expressions, it maps the
                // arguments of the constructor and counts their usage within the swizzle. It
                // then determines if the swizzle can be optimized by ensuring that non-trivial
                // expressions are not repeated and expressions with side effects occur exactly
                // once. If safe, it reorders and simplifies the arguments, creating a new
                // constructor expression that avoids unnecessary computation and duplication.
                if (base.arguments().size() == 1) {
                    // If the base constructor has a single scalar argument, we can optimize by
                    // reducing the swizzle size.
                    replacement = construct(&componentType, base.arguments()[0]->clone());
                } else {
                    // Map the arguments of the constructor and count their usage within the swizzle.
                    std::vector<int> argUsage(base.arguments().size(), 0);
                    for (int c : s.components()) {
                        ++argUsage[c];
                    }

                    // Determine if the swizzle can be optimized.
                    bool canOptimize = true;
                    for (size_t i = 0; i < base.arguments().size(); ++i) {
                        if (argUsage[i] > 1 && base.arguments()[i]->hasSideEffects()) {
                            canOptimize = false;
                            break;
                        }
                    }

                    if (canOptimize) {
                        // Reorder and simplify the arguments.
                        ExpressionArray newArgs;
                        for (int c : s.components()) {
                            newArgs.push_back(base.arguments()[c]->clone());
                        }
                        replacement = std::make_unique<Constructor>(base.fOffset, &componentType, std::move(newArgs));
                    }
                }

                if (replacement) {
                    optimizationContext->fUpdated = true;
                    if (!try_replace_expression(&b, iter, &replacement)) {
                        optimizationContext->fNeedsRescan = true;
                        return;
                    }
                    SkASSERT((*iter)->isExpression());
                    break;
                }