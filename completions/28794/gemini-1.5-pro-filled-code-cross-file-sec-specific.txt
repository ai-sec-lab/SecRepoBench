if (base.arguments().size() == 1 && base.arguments()[0]->is<ScalarLiteral>()) {
                    // This is a splat constructor, so we can optimize expressions like
                    // `half4(x).yw` to `half2(x)`.
                    ScalarLiteral& splat = base.arguments()[0]->as<ScalarLiteral>();
                    ExpressionArray args;
                    args.reserve_back(swizzleSize);
                    for (int i = 0; i < swizzleSize; ++i) {
                        args.push_back(splat.clone());
                    }
                    replacement = std::make_unique<Constructor>(s.fOffset,
                                                                fContext->fTypes.fFloat.get(),
                                                                std::move(args));
                    if (componentType.isInteger()) {
                        replacement = fIRGenerator->convertToInt(std::move(replacement));
                    } else if (componentType.isBoolean()) {
                        replacement = fIRGenerator->convertToBool(std::move(replacement));
                    }
                    replacement = construct(&s.type(), std::move(replacement));
                } else {
                    // Map arguments of the constructor and count their usage within the swizzle
                    ExpressionMap argMap;
                    int8_t* usageCount = new int8_t[base.arguments().size()];
                    memset(usageCount, 0, base.arguments().size());
                    for (int c : s.components()) {
                        int index = base.constructorSwizzle(c);
                        if (index >= 0) {
                            usageCount[index]++;
                            argMap.add(base.arguments()[index].get(), index);
                        }
                    }

                    // Determine if the swizzle can be optimized
                    bool canOptimize = true;
                    for (const auto& [expr, index] : argMap) {
                        if (usageCount[index] > 1 && !expr->isTrivial()) {
                            canOptimize = false;
                            break;
                        }
                        if (expr->hasSideEffects() && usageCount[index] != 1) {
                            canOptimize = false;
                            break;
                        }
                    }

                    if (canOptimize) {
                        // Reorder and simplify the arguments
                        ExpressionArray newArgs;
                        newArgs.reserve_back(swizzleSize);
                        for (int c : s.components()) {
                            int index = base.constructorSwizzle(c);
                            if (index >= 0) {
                                newArgs.push_back(base.arguments()[index]->clone());
                            } else {
                                std::unique_ptr<Expression> zero =
                                        std::make_unique<ScalarLiteral>(s.fOffset, 0.0);
                                if (componentType.isInteger()) {
                                    zero = std::make_unique<IntLiteral>(s.fOffset, 0);
                                }
                                newArgs.push_back(std::move(zero));
                            }
                        }
                        replacement = std::unique_ptr<Expression>(
                                new Constructor(s.fOffset, &s.type(), std::move(newArgs)));
                    }
                    delete[] usageCount;
                }
                if (replacement) {
                    // No fUsage change: `float4(a, b, c, d).zyx` and `float3(c, b, a)` have
                    // equivalent reference counts
                    optimizationContext->fUpdated = true;
                    if (!try_replace_expression(&b, iter, &replacement)) {
                        optimizationContext->fNeedsRescan = true;
                        return;
                    }
                    SkASSERT((*iter)->isExpression());
                    break;
                }