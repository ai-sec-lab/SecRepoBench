if (base.arguments().size() == 1 && base.arguments()[0]->type().isScalar()) {
    // If the base constructor has a single scalar argument, we can simplify
    // the swizzle by reducing its size.
    replacement = construct(&componentType.toCompound(fContext, swizzleSize),
                            base.arguments()[0]->clone());
} else {
    // Map the arguments of the constructor to track their usage
    std::vector<int> argMap(base.arguments().size());
    std::vector<int> argCount(base.arguments().size(), 0);
    for (int i = 0; i < swizzleSize; ++i) {
        argMap[i] = s.components()[i];
        ++argCount[argMap[i]];
    }

    // Check if we can safely optimize this swizzle
    bool canOptimize = true;
    for (size_t i = 0; i < base.arguments().size(); ++i) {
        if (argCount[i] > 1 && !base.arguments()[i]->isConstantOrUniform()) {
            // We can't optimize if a non-trivial expression is repeated
            canOptimize = false;
            break;
        }
        if (argCount[i] != 1 && base.arguments()[i]->hasSideEffects()) {
            // We can't optimize if an expression with side effects doesn't occur exactly once
            canOptimize = false;
            break;
        }
    }

    if (canOptimize) {
        // Perform the optimization by reordering and simplifying arguments
        ExpressionArray optimizedArgs;
        optimizedArgs.reserve_back(swizzleSize);
        for (int i = 0; i < swizzleSize; ++i) {
            optimizedArgs.push_back(base.arguments()[argMap[i]]->clone());
        }
        replacement = std::make_unique<Constructor>(-1, &componentType.toCompound(fContext, swizzleSize),
                                                    std::move(optimizedArgs));
    }
}

if (replacement) {
    optimizationContext->fUpdated = true;
    // Update usage: remove old swizzle, add replacement
    optimizationContext->fUsage->remove(&s);
    optimizationContext->fUsage->add(replacement.get());
    if (!try_replace_expression(&b, iter, &replacement)) {
        optimizationContext->fNeedsRescan = true;
        return;
    }
    SkASSERT((*iter)->isExpression());
}