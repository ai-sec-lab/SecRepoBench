if (base.arguments().size() == 1) {
                    // If the base constructor has a single argument, we can directly create a new swizzle
                    // expression without needing to flatten.
                    replacement = std::make_unique<Swizzle>(*fContext, base.base()->clone(), s.components());
                } else {
                    // For multiple arguments, we need to ensure that we are not duplicating any expressions
                    // and that we are not introducing side effects.
                    std::unordered_set<Expression*> seenExpressions;
                    ExpressionArray newArgs;

                    for (const std::unique_ptr<Expression>& arg : base.arguments()) {
                        if (seenExpressions.find(arg.get()) == seenExpressions.end()) {
                            newArgs.push_back(arg->clone());
                            seenExpressions.insert(arg.get());
                        }
                    }

                    // Create a new constructor with the optimized arguments
                    replacement = std::make_unique<Constructor>(base.fOffset, &base.type(), std::move(newArgs));
                }

                // Replace the original swizzle with the optimized constructor
                optimizationContext->fUpdated = true;
                if (!try_replace_expression(&b, iter, &replacement)) {
                    optimizationContext->fNeedsRescan = true;
                    return;
                }
                SkASSERT((*iter)->isExpression());