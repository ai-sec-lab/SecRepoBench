// Check if the base constructor has a single scalar argument.
                if (base.arguments().size() == 1 && base.arguments()[0]->type().isScalar()) {
                    // If so, we can optimize by reducing the swizzle size.
                    replacement = construct(&componentType, base.arguments()[0]->clone());
                } else {
                    // Map the arguments of the constructor.
                    std::vector<int> argUsage(base.arguments().size(), 0);
                    for (int c : s.components()) {
                        ++argUsage[c];
                    }

                    // Count the number of times each argument is used in the swizzle.
                    int numUniqueArgs = 0;
                    for (int usage : argUsage) {
                        if (usage > 0) {
                            ++numUniqueArgs;
                        }
                    }

                    // If the swizzle can be optimized, reorder and simplify the arguments.
                    if (numUniqueArgs == swizzleSize) {
                        ExpressionArray newArgs;
                        newArgs.reserve_back(swizzleSize);
                        for (int c : s.components()) {
                            newArgs.push_back(base.arguments()[c]->clone());
                        }
                        replacement = std::make_unique<Constructor>(base.fOffset, &componentType, std::move(newArgs));
                    }
                }

                if (replacement) {
                    optimizationContext->fUpdated = true;
                    if (!try_replace_expression(&b, iter, &replacement)) {
                        optimizationContext->fNeedsRescan = true;
                        return;
                    }
                    SkASSERT((*iter)->isExpression());
                }