if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
    return ret;
p->pict_type = AV_PICTURE_TYPE_I;

if (encoding) {
    av_fast_padded_malloc(&c->new_video, &c->new_video_size,
                          h * w + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!c->new_video)
        return AVERROR(ENOMEM);
    if (c->bpp == 8)
        cdxl_decode_ham8(c, p);
    else
        cdxl_decode_ham6(c, p);
} else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
    cdxl_decode_rgb(c, p);
} else {
    cdxl_decode_raw(c, p);
}

// Determine the appropriate pixel format to use based on the encoding type,
// palette size, bits per pixel, and format.
switch (encoding) {
    case 0:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 1:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 2:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 3:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 4:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 5:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 6:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    case 7:
        if (c->palette_size == 0) {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        } else {
            if (c->bpp == 8)
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            else if (c->bpp == 6)
                avctx->pix_fmt = AV_PIX_FMT_YUV420P;
            else
                avctx->pix_fmt = AV_PIX_FMT_YUV422P;
        }
        break;
    default:
        avpriv_request_sample(avctx, "Invalid encoding type 0x%02x", encoding);
        return AVERROR_PATCHWELCOME;
}

*got_frame = 1;

return buf_size;