// Calculate the total size required for the video data
    int total_size = aligned_width * h * (c->bpp / 8);
    
    // Check if the video size is sufficient
    if (c->video_size < total_size) {
        avpriv_request_sample(avctx, "Insufficient video size: %d < %d", c->video_size, total_size);
        return AVERROR_INVALIDDATA;
    }

    // Determine the pixel format based on encoding and bits per pixel
    switch (c->bpp) {
        case 8:
            if (c->format == CHUNKY) {
                avctx->pix_fmt = AV_PIX_FMT_PAL8;
            } else {
                avctx->pix_fmt = AV_PIX_FMT_RGB8; // Assuming RGB8 for other formats
            }
            break;
        case 16:
            avctx->pix_fmt = AV_PIX_FMT_RGB565; // Example for 16 bpp
            break;
        case 24:
            avctx->pix_fmt = AV_PIX_FMT_BGR24; // Example for 24 bpp
            break;
        case 32:
            avctx->pix_fmt = AV_PIX_FMT_RGBA; // Example for 32 bpp
            break;
        default:
            avpriv_request_sample(avctx, "Unsupported bits per pixel: %d", c->bpp);
            return AVERROR_INVALIDDATA;
    }