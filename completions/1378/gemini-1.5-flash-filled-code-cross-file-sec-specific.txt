int pixel_size = c->bpp / 8;
    int video_size_expected = aligned_width * h * pixel_size;
    if (c->video_size < video_size_expected) {
        avpriv_request_sample(avctx, "Video size %d < expected size %d\n", c->video_size, video_size_expected);
        return AVERROR_PATCHWELCOME;
    }

    switch (encoding) {
    case HAM6:
        if (c->bpp != 6) {
            avpriv_request_sample(avctx, "bpp %d != 6 for HAM6\n", c->bpp);
            return AVERROR_PATCHWELCOME;
        }
        avctx->pix_fmt = AV_PIX_FMT_RGB565;
        break;
    case HAM8:
        if (c->bpp != 8) {
            avpriv_request_sample(avctx, "bpp %d != 8 for HAM8\n", c->bpp);
            return AVERROR_PATCHWELCOME;
        }
        avctx->pix_fmt = AV_PIX_FMT_PAL8;
        break;
    case RAW:
        if (c->bpp != 8 && c->bpp != 16 && c->bpp != 24 && c->bpp != 32) {
            avpriv_request_sample(avctx, "bpp %d not supported for RAW\n", c->bpp);
            return AVERROR_PATCHWELCOME;
        }
        switch (c->bpp) {
        case 8:
            avctx->pix_fmt = AV_PIX_FMT_GRAY8;
            break;
        case 16:
            avctx->pix_fmt = AV_PIX_FMT_GRAY16;
            break;
        case 24:
            avctx->pix_fmt = AV_PIX_FMT_BGR24;
            break;
        case 32:
            avctx->pix_fmt = AV_PIX_FMT_BGRA;
            break;
        }
        break;
    default:
        avpriv_request_sample(avctx, "Unknown encoding %d\n", encoding);
        return AVERROR_PATCHWELCOME;
    }