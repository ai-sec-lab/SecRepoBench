int padded_bits = aligned_width - codeccontext->width;
int required_size = ((aligned_width * c->bpp + 7) >> 3) * codeccontext->height;

if (c->video_size < required_size)
    return AVERROR_INVALIDDATA;

if (encoding == 0 && (c->palette_size != 0 || c->bpp != 8)) {
    avpriv_request_sample(codeccontext, "Encoding 0 with palette size %d and bpp %d", c->palette_size, c->bpp);
    return AVERROR_PATCHWELCOME;
}

switch (c->format) {
    case BIT_PLANAR:
        if (c->bpp == 8)
            codeccontext->pix_fmt = AV_PIX_FMT_PAL8;
        else
            return AVERROR_INVALIDDATA;
        break;
    case BIT_LINE:
        if (c->bpp == 8)
            codeccontext->pix_fmt = AV_PIX_FMT_PAL8;
        else
            return AVERROR_INVALIDDATA;
        break;
    case CHUNKY:
        if (c->bpp == 8)
            codeccontext->pix_fmt = AV_PIX_FMT_PAL8;
        else if (c->bpp == 24)
            codeccontext->pix_fmt = AV_PIX_FMT_BGR24;
        else
            return AVERROR_INVALIDDATA;
        break;
    default:
        return AVERROR_INVALIDDATA;
}

if (codeccontext->pix_fmt == AV_PIX_FMT_PAL8) {
    if (c->palette_size > AVPALETTE_SIZE)
        return AVERROR_INVALIDDATA;
    memcpy(p->data[1], c->palette, c->palette_size);
    if (c->palette_size < AVPALETTE_SIZE)
        memset(p->data[1] + c->palette_size, 0, AVPALETTE_SIZE - c->palette_size);
}