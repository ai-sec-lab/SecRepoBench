// Calculate the total size required for the video data
    int total_size = aligned_width * h * (c->bpp / 8);
    
    // Validate if the video size is sufficient
    if (c->video_size < total_size) {
        avpriv_request_sample(avctx, "Insufficient video size: %d < %d", c->video_size, total_size);
        return AVERROR_INVALIDDATA;
    }

    // Determine the pixel format based on encoding type and bits per pixel
    switch (c->bpp) {
        case 8:
            if (c->palette_size == 256) {
                avctx->pix_fmt = AV_PIX_FMT_PAL8; // Use palette format
            } else {
                avpriv_request_sample(avctx, "Invalid palette size for 8bpp: %d", c->palette_size);
                return AVERROR_INVALIDDATA;
            }
            break;
        case 16:
            avctx->pix_fmt = AV_PIX_FMT_RGB565; // Use RGB565 format
            break;
        case 24:
            avctx->pix_fmt = AV_PIX_FMT_BGR24; // Use BGR24 format
            break;
        default:
            avpriv_request_sample(avctx, "Unsupported bits per pixel: %d", c->bpp);
            return AVERROR_INVALIDDATA;
    }