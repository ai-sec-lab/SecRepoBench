case ReadStripMethod:
      {
        size_t
          number_pixels;

        /*
          Convert strip TIFF image.
        */
        if (TIFFNumberOfStrips(tiff) <= 0)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=TIFFScanlineSize(tiff)*rows_per_strip;
        if (HeapOverflowSanityCheck(rows_per_strip,number_pixels) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
        {
          size_t
            rows_remaining;

          rows_remaining=image->rows-y;
          if (rows_remaining < rows_per_strip)
            {
              number_pixels=TIFFScanlineSize(tiff)*rows_remaining;
              pixel_info=ResizeVirtualMemory(pixel_info,number_pixels*
                sizeof(uint32));
              if (pixel_info == (MemoryInfo *) NULL)
                ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
            }
          tiff_status=TIFFReadEncodedStrip(tiff,TIFFComputeStrip(tiff,y,0),
            pixels,number_pixels);
          if (tiff_status == -1)
            break;
          ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,quantum_type,
            pixels,exception);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          columns,
          rows;

        /*
          Convert tile TIFF image.
        */
        if (TIFFNumberOfTiles(tiff) <= 0)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns);
        TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows);
        if (HeapOverflowSanityCheck(rows,TIFFTileSize(tiff)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        for (y=0; y < (ssize_t) image->rows; y+=rows)
        {
          register ssize_t
            x;

          size_t
            rows_remaining;

          rows_remaining=image->rows-y;
          if (rows_remaining < rows)
            {
              pixel_info=ResizeVirtualMemory(pixel_info,TIFFTileSize(tiff)*
                sizeof(uint32));
              if (pixel_info == (MemoryInfo *) NULL)
                ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
            }
          for (x=0; x < (ssize_t) image->columns; x+=columns)
          {
            tiff_status=TIFFReadEncodedTile(tiff,TIFFComputeTile(tiff,x,y,0,0),
              pixels,TIFFTileSize(tiff));
            if (tiff_status == -1)
              break;
            ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,pixels,exception);
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }