case ReadStripMethod:
{
  /*
    Read TIFF image as strips.
  */
  number_pixels=(MagickSizeType) image->columns*image->rows;
  if (HeapOverflowSanityCheck(image->columns,image->rows) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *q;

    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    if (TIFFReadPixels(tiff,0,y,(char *) pixels) == -1)
      break;
    length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image as tiles.
  */
  uint32
    tile_height,
    tile_width;

  if (TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) == 0)
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  if (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) == 0)
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  number_pixels=(MagickSizeType) tile_width*tile_height;
  if (HeapOverflowSanityCheck((size_t) tile_width,tile_height) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    ssize_t
      tile_y;

    register ssize_t
      x;

    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      if (TIFFReadTile(tiff,pixels,x,y,0,0) == -1)
        break;
      for (tile_y=0; tile_y < (ssize_t) tile_height; tile_y++)
      {
        register Quantum
          *q;

        register ssize_t
          tile_x;

        if ((y+tile_y) >= (ssize_t) image->rows)
          break;
        q=QueueAuthenticPixels(image,x,y+tile_y,
          (size_t) MagickMin(tile_width,image->columns-x),1,exception);
        if (q == (Quantum *) NULL)
          break;
        length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          quantum_type,pixels+tile_y*tile_width*quantum_info->pad,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  break;
}