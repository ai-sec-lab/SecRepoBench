case ReadStripMethod:
      {
        uint32 strip_size = rows_per_strip * TIFFScanlineSize(tiff);
        unsigned char *strip_buffer = (unsigned char *) AcquireQuantumMemory(strip_size, sizeof(unsigned char));
        if (strip_buffer == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        for (y = 0; y < (ssize_t) image->rows; y += rows_per_strip)
        {
          ssize_t read_lines = TIFFReadEncodedStrip(tiff, y / rows_per_strip, strip_buffer, strip_size);
          if (read_lines < 0)
          {
            strip_buffer = RelinquishQuantumMemory(strip_buffer);
            ThrowTIFFException(CorruptImageError, "InsufficientImageDataInFile");
          }

          register Quantum *magick_restrict q = QueueAuthenticPixels(image, 0, y, image->columns, read_lines, exception);
          if (q == (Quantum *) NULL)
          {
            strip_buffer = RelinquishQuantumMemory(strip_buffer);
            break;
          }

          for (ssize_t x = 0; x < (ssize_t) image->columns; x++)
          {
            // Assuming the image is RGB
            SetPixelRed(image, ScaleCharToQuantum(strip_buffer[x * 3]), q);
            SetPixelGreen(image, ScaleCharToQuantum(strip_buffer[x * 3 + 1]), q);
            SetPixelBlue(image, ScaleCharToQuantum(strip_buffer[x * 3 + 2]), q);
            q += GetPixelChannels(image);
          }

          if (SyncAuthenticPixels(image, exception) == MagickFalse)
          {
            strip_buffer = RelinquishQuantumMemory(strip_buffer);
            break;
          }

          if (image->previous == (Image *) NULL)
          {
            status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y, image->rows);
            if (status == MagickFalse)
              break;
          }
        }

        strip_buffer = RelinquishQuantumMemory(strip_buffer);
        break;
      }

      case ReadTileMethod:
      {
        uint32 tile_width, tile_height;
        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_height);
        size_t tile_size = tile_width * tile_height * sizeof(uint32);
        unsigned char *tile_buffer = (unsigned char *) AcquireQuantumMemory(tile_size, sizeof(unsigned char));
        if (tile_buffer == (unsigned char *) NULL)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");

        for (y = 0; y < (ssize_t) image->rows; y += tile_height)
        {
          for (ssize_t x = 0; x < (ssize_t) image->columns; x += tile_width)
          {
            ssize_t read_tiles = TIFFReadTile(tiff, tile_buffer, x, y, 0, 0);
            if (read_tiles < 0)
            {
              tile_buffer = RelinquishQuantumMemory(tile_buffer);
              ThrowTIFFException(CorruptImageError, "InsufficientImageDataInFile");
            }

            register Quantum *magick_restrict q = QueueAuthenticPixels(image, x, y, tile_width, tile_height, exception);
            if (q == (Quantum *) NULL)
            {
              tile_buffer = RelinquishQuantumMemory(tile_buffer);
              break;
            }

            for (ssize_t tile_y = 0; tile_y < tile_height; tile_y++)
            {
              for (ssize_t tile_x = 0; tile_x < tile_width; tile_x++)
              {
                size_t pixel_index = (tile_y * tile_width + tile_x) * 3; // Assuming RGB
                SetPixelRed(image, ScaleCharToQuantum(tile_buffer[pixel_index]), q);
                SetPixelGreen(image, ScaleCharToQuantum(tile_buffer[pixel_index + 1]), q);
                SetPixelBlue(image, ScaleCharToQuantum(tile_buffer[pixel_index + 2]), q);
                q += GetPixelChannels(image);
              }
            }

            if (SyncAuthenticPixels(image, exception) == MagickFalse)
            {
              tile_buffer = RelinquishQuantumMemory(tile_buffer);
              break;
            }

            if (image->previous == (Image *) NULL)
            {
              status = SetImageProgress(image, LoadImageTag, (MagickOffsetType) y, image->rows);
              if (status == MagickFalse)
                break;
            }
          }
        }

        tile_buffer = RelinquishQuantumMemory(tile_buffer);
        break;
      }