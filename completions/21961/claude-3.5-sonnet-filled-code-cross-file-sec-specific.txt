case ReadStripMethod:
{
  /*
    Read TIFF image as strips.
  */
  number_pixels=(MagickSizeType) image->columns*rows_per_strip;
  if (HeapOverflowSanityCheck(image->columns, rows_per_strip) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if (number_pixels != (size_t) number_pixels)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
  {
    ssize_t
      count;

    size_t
      length;

    tsize_t
      strip_size;

    strip_size=TIFFStripSize(tiff);
    if (strip_size <= 0)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    length=(size_t) strip_size;
    count=TIFFReadEncodedStrip(tiff,(tstrip_t) TIFFComputeStrip(tiff,y,0),
      pixels,length);
    if (count == -1)
      break;
    for (i=0; i < (ssize_t) count; i+=(ssize_t) TIFFScanlineSize(tiff))
    {
      register uint32
        *p;

      p=(uint32 *) (pixels+i);
      if (y < (ssize_t) image->rows)
        {
          (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,p,exception);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
      y++;
    }
    if (y >= (ssize_t) image->rows)
      break;
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  break;
}
case ReadTileMethod:
{
  /*
    Read TIFF image as tiles.
  */
  uint32
    tile_height,
    tile_width;

  if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&tile_width) != 1) ||
      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height) != 1))
    ThrowTIFFException(CoderError,"ImageIsNotTiled");
  number_pixels=(MagickSizeType) tile_width*tile_height;
  if (HeapOverflowSanityCheck(tile_width, tile_height) != MagickFalse)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  if (number_pixels != (size_t) number_pixels)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
  if (pixel_info == (MemoryInfo *) NULL)
    ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  for (y=0; y < (ssize_t) image->rows; y+=tile_height)
  {
    ssize_t
      tile_y;

    for (x=0; x < (ssize_t) image->columns; x+=tile_width)
    {
      if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,(uint32 *) pixels) == 0)
        break;
      for (tile_y=0; tile_y < (ssize_t) tile_height; tile_y++)
      {
        register uint32
          *p;

        ssize_t
          tile_x;

        if ((y+tile_y) >= (ssize_t) image->rows)
          break;
        p=(uint32 *) (pixels+tile_y*tile_width);
        for (tile_x=0; tile_x < (ssize_t) tile_width; tile_x++)
        {
          if ((x+tile_x) < (ssize_t) image->columns)
            {
              register Quantum
                *q;

              q=QueueAuthenticPixels(image,x+tile_x,y+tile_y,1,1,exception);
              if (q == (Quantum *) NULL)
                break;
              q[RedPixelChannel]=ScaleCharToQuantum((unsigned char)
                TIFFGetR(*p));
              q[GreenPixelChannel]=ScaleCharToQuantum((unsigned char)
                TIFFGetG(*p));
              q[BluePixelChannel]=ScaleCharToQuantum((unsigned char)
                TIFFGetB(*p));
              q[AlphaPixelChannel]=ScaleCharToQuantum((unsigned char)
                TIFFGetA(*p));
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
            }
          p++;
        }
      }
    }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  pixel_info=RelinquishVirtualMemory(pixel_info);
  break;
}