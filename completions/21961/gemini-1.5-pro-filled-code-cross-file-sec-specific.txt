case ReadStripMethod:
      {
        size_t
          number_pixels;

        /*
          Convert strip TIFF image.
        */
        if (HeapOverflowSanityCheck(rows_per_strip,sizeof(*pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        number_pixels=rows_per_strip*image->columns;
        for (y=0; y < (ssize_t) image->rows; y+=rows_per_strip)
        {
          size_t
            rows_remaining;

          rows_remaining=image->rows-y;
          if (rows_remaining < rows_per_strip)
            {
              number_pixels=rows_remaining*image->columns;
              pixel_info=ResizeVirtualMemory(pixel_info,number_pixels*
                sizeof(uint32));
              if (pixel_info == (MemoryInfo *) NULL)
                ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
              pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
            }
          tiff_status=TIFFReadScanline(tiff,(char *) pixels,y,0);
          if (tiff_status == -1)
            break;
          ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
            quantum_type,pixels,exception);
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case ReadTileMethod:
      {
        uint32
          *tile_pixels,
          columns,
          rows;

        size_t
          number_pixels;

        /*
          Convert tile TIFF image.
        */
        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
          ThrowTIFFException(CoderError,"ImageTypeNotSupported");

        if (HeapOverflowSanityCheck(columns,rows) != MagickFalse)
          ThrowTIFFException(ResourceLimitError, "MemoryAllocationFailed");
        if (HeapOverflowSanityCheck(columns*rows,sizeof(*tile_pixels)) != MagickFalse)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");

        number_pixels = columns*rows;
        pixel_info=ResizeVirtualMemory(pixel_info, number_pixels*sizeof(uint32));
        if (pixel_info == (MemoryInfo *) NULL)
          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
        tile_pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
        for (y=0; y < (ssize_t) image->rows; y+=rows)
        {
          register ssize_t
            x;

          size_t
            rows_remaining;

          rows_remaining = image->rows-y;
          if (rows_remaining < rows)
            {
              number_pixels = rows_remaining * columns;
              pixel_info=ResizeVirtualMemory(pixel_info,number_pixels*
                sizeof(uint32));
              if (pixel_info == (MemoryInfo *) NULL)
                ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
              tile_pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
            }

          for (x=0; x < (ssize_t) image->columns; x+=columns)
          {
            size_t
              columns_remaining;

            columns_remaining = image->columns-x;
            if (columns_remaining < columns)
              {
                number_pixels = rows * columns_remaining;
                pixel_info=ResizeVirtualMemory(pixel_info,number_pixels*
                  sizeof(uint32));
                if (pixel_info == (MemoryInfo *) NULL)
                  ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
                tile_pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
              }

            tiff_status=TIFFReadTile(tiff,(char *) tile_pixels,x,y,0,0);
            if (tiff_status == -1)
              break;
            ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
              quantum_type,tile_pixels,exception);
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }