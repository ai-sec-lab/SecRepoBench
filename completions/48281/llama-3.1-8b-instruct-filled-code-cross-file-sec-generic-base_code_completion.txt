if (buf_size < 16) {
    av_log(avctx, AV_LOG_WARNING, "truncated header\n");
    return AVERROR_INVALIDDATA;
}
big_endian = AV_RL32(&buf[4]) > 0x000FFFFF;
bytestream2_init(&s->gb, buf + 8, buf_size - 8);
if (big_endian) {
    s->width  = bytestream2_get_be16u(&s->gb);
    s->height = bytestream2_get_be16u(&s->gb);
} else {
    s->width  = bytestream2_get_le16u(&s->gb);
    s->height = bytestream2_get_le16u(&s->gb);
}

ret = ff_set_dimensions(s->avctx, s->width, s->height);
if (ret < 0)
    return ret;

compute_quant_matrix(s->quant_matrix, 100 - quality);

second_field_offset = AV_RL24(buf + 1);
if (second_field_offset >= buf_size - 3) {
    return AVERROR_INVALIDDATA;
}

avctx->coded_width = FFALIGN(avctx->width, 16);
avctx->coded_height = FFALIGN(avctx->height, 16);

if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
    return ret;
}
frame->key_frame = 1;

if (second_field_offset == 4 || second_field_offset == (buf_size-4)) {
    /*
     * Overlapping first and second fields is used to signal
     * encoding only a single field. In this case, "height"
     * is ambiguous; it could mean either the height of the
     * frame as a whole, or of the field. The former would make
     * more sense for compatibility with legacy decoders,
     * but this matches the convention used in NDI, which is
     * the primary user of this trick.
     */
    if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 0, 4, buf_size, 1)) < 0)
        return ret;
} else {
    if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 0, 4, second_field_offset, 2)) < 0)
        return ret;
    if ((ret = decode_speedhq_field(s, buf, buf_size, frame, 1, second_field_offset, buf_size, 2)) < 0)
        return ret;
}

*got_frame = 1;
return buf_size;