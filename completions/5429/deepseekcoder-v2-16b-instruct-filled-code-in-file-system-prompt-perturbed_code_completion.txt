const unsigned int depth,ExceptionInfo *exception)
{
  register ssize_t
    y;

  register Quantum
    *magick_restrict q;

  register ssize_t
    x;

  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      DoublePixelPacket
        pixel;

      register ssize_t
        i;

      size_t
        index;

      AssociateAlphaPixel(image,cube_info,q,&pixel);
      if (x > 0)
        {
          pixel.red+=7*current[x-1].red/16;
          pixel.green+=7*current[x-1].green/16;
          pixel.blue+=7*current[x-1].blue/16;
          if (cube_info->associate_alpha != MagickFalse)
            pixel.alpha+=7*current[x-1].alpha/16;
        }
      if (y > 0)
        {
          if (x < (ssize_t) (image->columns-1))
            {
              pixel.red+=previous[x+1].red/16;
              pixel.green+=previous[x+1].green/16;
              pixel.blue+=previous[x+1].blue/16;
              if (cube_info->associate_alpha != MagickFalse)
                pixel.alpha+=previous[x+1].alpha/16;
            }
          pixel.red+=previous[x].red/16;
          pixel.green+=previous[x].green/16;
          pixel.blue+=previous[x].blue/16;
          if (cube_info->associate_alpha != MagickFalse)
            pixel.alpha+=previous[x].alpha/16;
          if (x > 0)
            {
              pixel.red+=previous[x-1].red/16;
              pixel.green+=previous[x-1].green/16;
              pixel.blue+=previous[x-1].blue/16;
              if (cube_info->associate_alpha != MagickFalse)
                pixel.alpha+=previous[x-1].alpha/16;
            }
        }
      pixel.red=(double) ClampPixel(pixel.red);
      pixel.green=(double) ClampPixel(pixel.green);
      pixel.blue=(double) ClampPixel(pixel.blue);
      if (cube_info->associate_alpha != MagickFalse)
        pixel.alpha=(double) ClampPixel(pixel.alpha);
      i=CacheOffset(cube_info,&pixel);
      if (cube_info->cache[i] < 0)
        {
          register NodeInfo
            *node_info;

          register size_t
            node_id;

          /*
            Identify the deepest node containing the pixel's color.
          */
          node_info=cube_info->root;
          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)
          {
            node_id=ColorToNodeId(cube_info,&pixel,index);
            if (node_info->child[node_id] == (NodeInfo *) NULL)
              break;
            node_info=node_info->child[node_id];
          }
          /*
            Find closest color among siblings and their children.
          */
          cube_info->target=pixel;
          cube_info->distance=(double) (4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+
            1.0);
          ClosestColor(image,cube_info,node_info->parent);
          cube_info->cache[i]=(ssize_t) cube_info->color_number;
        }
      /*
        Assign pixel to closest colormap entry.
      */
      index=(size_t) cube_info->cache[i];
      if (image->storage_class == PseudoClass)
        SetPixelIndex(image,(Quantum) index,q);
      if (cube_info->quantize_info->measure_error == MagickFalse)
        {
          SetPixelRed(image,ClampToQuantum(image->colormap[index].red),q);
          SetPixelGreen(image,ClampToQuantum(image->colormap[index].green),q);
          SetPixelBlue(image,ClampToQuantum(image->colormap[index].blue),q);
          if (cube_info->associate_alpha != MagickFalse)
            SetPixelAlpha(image,ClampToQuantum(image->colormap[index].alpha),q);
        }
      q+=GetPixelChannels(image);
      /*
        Store the error.
      */
      AssociateAlphaPixelInfo(cube_info,image->colormap+index,&color);
      current[x].red=pixel.red-color.red;
      current[x].green=pixel.green-color.green;
      current[x].blue=pixel.blue-color.blue;
      if (cube_info->associate_alpha != MagickFalse)
        current[x].alpha=pixel.alpha-color.alpha;
    }
  }
}

static MagickBooleanType RiemersmaDither(Image *image,CacheView *image_view,
  CubeInfo *cube_info,const unsigned int depth,ExceptionInfo *exception)
{
  register ssize_t
    y;

  register Quantum
    *magick_restrict q;

  register ssize_t
    x;

  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      DoublePixelPacket
        pixel;

      register ssize_t
        i;

      size_t
        index;

      AssociateAlphaPixel(image,cube_info,q,&pixel);
      if (x > 0)
        {
          pixel.red+=7*current[x-1].red/16;
          pixel.green+=7*current[x-1].green/16;
          pixel.blue+=7*current[x-1].blue/16;
          if (cube_info->associate_alpha != MagickFalse)
            pixel.alpha+=7*current[x-1].alpha/16;
        }
      if (y > 0)
        {
          if (x < (ssize_t) (image->columns-1))
            {
              pixel.red+=previous[x+1].red/16;
              pixel.green+=previous[x+1].green/16;
              pixel.blue+=previous[x+1].blue/16;
              if (cube_info->associate_alpha != MagickFalse)
                pixel.alpha+=previous[x+1].alpha/16;
            }
          pixel.red+=previous[x].red/16;
          pixel.green+=previous[x].green/16;
          pixel.blue+=previous[x].blue/16;
          if (cube_info->associate_alpha != MagickFalse)
            pixel.alpha+=previous[x].alpha/16;
          if (x > 0)
            {
              pixel.red+=previous[x-1].red/16;
              pixel.green+=previous[x-1].green/16;
              pixel.blue+=previous[x-1].blue/16;
              if (cube_info->associate_alpha != MagickFalse)
                pixel.alpha+=previous[x-1].alpha/16;
            }
        }
      pixel.red=(double) ClampPixel(pixel.red);
      pixel.green=(double) ClampPixel(pixel.green);
      pixel.blue=(double) ClampPixel(pixel.blue);
      if (cube_info->associate_alpha != MagickFalse)
        pixel.alpha=(double) ClampPixel(pixel.alpha);
      i=CacheOffset(cube_info,&pixel);
      if (cube_info->cache[i] < 0)
        {
          register NodeInfo
            *node_info;

          register size_t
            node_id;

          /*
            Identify the deepest node containing the pixel's color.
          */
          node_info=cube_info->root;
          for (index=MaxTreeDepth-1; (ssize_t) index > 0; index--)
          {
            node_id=ColorToNodeId(cube_info,&pixel,index);
            if (node_info->child[node_id] == (NodeInfo *) NULL)
              break;
            node_info=node_info->child[node_id];
          }
          /*
            Find closest color among siblings and their children.
          */
          cube_info->target=pixel;
          cube_info->distance=(double) (4.0*(QuantumRange+1.0)*(QuantumRange+1.0)+
            1.0);
          ClosestColor(image,cube_info,node_info->parent);
          cube_info->cache[i]=(ssize_t) cube_info->color_number;
        }
      /*
        Assign pixel to closest colormap entry.
      */
      index=(size_t) cube_info->cache[i];
      if (image->storage_class == PseudoClass)
        SetPixelIndex(image,(Quantum) index,q);
      if (cube_info->quantize_info->measure_error == MagickFalse)
        {
          SetPixelRed(image,ClampToQuantum(image->colormap[index].red),q);
          SetPixelGreen(image,ClampToQuantum(image->colormap[index].green),q);
          SetPixelBlue(image,ClampToQuantum(image->colormap[index].blue),q);
          if (cube_info->associate_alpha != MagickFalse)
            SetPixelAlpha(image,ClampToQuantum(image->colormap[index].alpha),q);
        }
      q+=GetPixelChannels(image);
      /*
        Store the error.
      */
      AssociateAlphaPixelInfo(cube_info,image->colormap+index,&color);
      current[x].red=pixel.red-color.red;
      current[x].green=pixel.green-color.green;
      current[x].blue=pixel.blue-color.blue;
      if (cube_info->associate_alpha != MagickFalse)
        current[x].alpha=pixel.alpha-color.alpha;
    }
  }
  return(MagickTrue);
}

static MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,
  ExceptionInfo *exception)
{
#define DitherImageTag  "Dither/Image"

  CacheView
    *image_view;

  MagickBooleanType
    status;

  ssize_t
    y;

  status=MagickTrue;
  image_view=AcquireAuthenticCacheView(image,exception);
  if (image->storage_class == PseudoClass)
    {
      if (FloydSteinbergDither(image,cube_info,exception) == MagickFalse)
        status=MagickFalse;
    }
  else
    {
      if (RiemersmaDither(image,image_view,cube_info,MaxTreeDepth,exception) ==
          MagickFalse)
        status=MagickFalse;
    }
  image_view=DestroyCacheView(image_view);
  return(status);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   G e t C u b e I n f o                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GetCubeInfo() allocates the CubeInfo structure.
%
%  The format of the GetCubeInfo method is:
%
%      CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,
%        const size_t colors,const size_t maximum_colors)
%
%  A description of each parameter follows:
%
%    o quantize_info: the quantize info.
%
%    o colors: the number of colors.
%
%    o maximum_colors: the maximum number of colors.
%
*/
static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize