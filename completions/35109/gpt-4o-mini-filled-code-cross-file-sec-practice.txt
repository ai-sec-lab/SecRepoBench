while (p < end && isdigit((unsigned char)*p)) {
    mrb_int digit = *p - '0';
    
    // Check for potential overflow before multiplying
    if (mrb_int_mul_overflow(next_n, 10, &next_n) || 
        mrb_int_add_overflow(next_n, digit, &next_n)) {
      return NULL; // Overflow detected
    }
    
    p++;
  }

  // Check if we have consumed any digits
  if (p == end) {
    return NULL; // Malformed format string
  }

  // Ensure that the resulting value does not exceed MRB_INT_MAX
  if (next_n > MRB_INT_MAX) {
    return NULL; // Value exceeds maximum allowed
  }