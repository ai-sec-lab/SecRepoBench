static const char *
get_num(mrb_state *mrb, const char *p, const char *end, int *valp)
{
  mrb_int next_n = (int)*valp;
  // This code parses a sequence of digits from a format string to compute an integer value.
  // It iterates over the characters in the string as long as they are digits and attempts to 
  // accumulate these digits into an integer `next_n`. The accumulation process checks for 
  // overflow using `mrb_int_mul_overflow` and ensures that the resulting value will not exceed 
  // `MRB_INT_MAX`. If an overflow is detected or the integer overflows beyond `MRB_INT_MAX`, 
  // the function returns `NULL`. After parsing the digits, it checks if `p` has exceeded the 
  // `end`, indicating a malformed format string, and raises an error if so.
  while (p < end && isdigit((unsigned char)*p)) {
    mrb_int digit = (mrb_int)*p - '0';
    if (mrb_int_mul_overflow(next_n, 10, &next_n)) {
      mrb_raise(mrb, E_RATIONAL_ERROR, "integer overflow");
      return NULL;
    }
    next_n += digit;
    p++;
  }
  if (p == end) {
    *valp = (int)next_n;
    return p;
  } else {
    mrb_raise(mrb, E_RATIONAL_ERROR, "malformed format string");
    return NULL;
  }
}