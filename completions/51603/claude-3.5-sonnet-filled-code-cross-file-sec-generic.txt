private int
parse_strength(struct magic_set *ms, struct magic_entry *me, const char *line,
    size_t len __attribute__((__unused__)))
{
    struct magic *m;
    char *p;
    int factor_op;
    float factor;

    if (me->cont_count == 0) {
        file_error(ms, 0, "No current entry for strength");
        return -1;
    }

    m = &me->mp[me->cont_count - 1];

    if (m->factor_op != FILE_FACTOR_OP_NONE) {
        file_error(ms, 0, "Strength already defined");
        return -1;
    }

    if (m->type == FILE_NAME) {
        if (ms->flags & MAGIC_CHECK)
            file_magwarn(ms, "Strength setting is not supported for \"name\" type");
        return -1;
    }

    p = strchr(line, '*');
    if (p == NULL) {
        p = strchr(line, '/');
        if (p == NULL) {
            if (ms->flags & MAGIC_CHECK)
                file_magwarn(ms, "Bad factor op");
            return -1;
        }
        factor_op = FILE_FACTOR_OP_DIV;
    } else {
        factor_op = FILE_FACTOR_OP_TIMES;
    }
    *p++ = '\0';

    factor = strtof(line, NULL);
    if (factor == 0.0f) {
        if (ms->flags & MAGIC_CHECK)
            file_magwarn(ms, "Factor cannot be zero");
        goto out;
    }

    if (factor_op == FILE_FACTOR_OP_DIV && factor > 1.0f) {
        if (ms->flags & MAGIC_CHECK)
            file_magwarn(ms, "Factor for division must be less than 1");
        goto out;
    }

    if (factor < 0.0f || factor > 1000.0f) {
        if (ms->flags & MAGIC_CHECK)
            file_magwarn(ms, "Factor out of range");
        goto out;
    }

    m->factor_op = factor_op;
    m->factor = factor;
    return 0;

out:
    m->factor_op = FILE_FACTOR_OP_NONE;
    m->factor = 0.0f;
    return -1;
}