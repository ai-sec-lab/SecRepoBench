private int
parse_strength(struct magic_set *ms, struct magic_entry *me, const char *line,
    size_t len __attribute__((__unused__)))
{
	// This function parses a strength annotation line from a magic file
	// and sets the corresponding factor operation and value in the magic
	// entry. It begins by setting up variables and checking if a strength
	// type is already defined. If the entry is of type FILE_NAME, it warns
	// that strength settings are not supported. It reads the operation type
	// and factor value, verifying that the factor is within valid limits
	// and not combined with a division operation when zero. If errors are
	// detected, it resets the factor operation and value to defaults.
	// <MASK>
	if (me->mp->type == FILE_NAME) {
		file_magwarn(ms, "strength settings are not supported for `name' entries");
		return -1;
	}
	if (me->mp->factor_op!= FILE_FACTOR_OP_NONE) {
		file_magwarn(ms, "strength settings are not supported for entries with a factor");
		return -1;
	}
	if (sscanf(line, "%s", me->mp->factor_str)!= 1) {
		file_magwarn(ms, "invalid strength type `%s'", line);
		return -1;
	}
	switch (me->mp->factor_str[0]) {
	case '+':
		me->mp->factor_op = FILE_FACTOR_OP_PLUS;
		break;
	case '-':
		me->mp->factor_op = FILE_FACTOR_OP_MINUS;
		break;
	case '*':
		me->mp->factor_op = FILE_FACTOR_OP_TIMES;
		break;
	case '/':
		me->mp->factor_op = FILE_FACTOR_OP_DIV;
		break;
	default:
		file_magwarn(ms, "invalid strength operation `%s'", line);
		return -1;
	}
	if (sscanf(line + 1, "%u", &me->mp->factor)!= 1) {
		file_magwarn(ms, "invalid strength factor `%s'", line);
		return -1;
	}
	if (me->mp->factor == 0 && me->mp->factor_op == FILE_FACTOR_OP_DIV) {
		file_magwarn(ms, "strength factor cannot be zero when using division");
		return -1;
	}
	if (me->mp->factor < 1 || me->mp->factor > 100) {
		file_magwarn(ms, "strength factor must be between 1 and 100");
		return -1;
	}
	return 0;
}