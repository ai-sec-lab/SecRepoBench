private int
parse_strength(struct magic_set *ms, struct magic_entry *me, const char *line,
    size_t len __attribute__((__unused__)))
{
    struct magic *m = &me->mp[me->cont_count == 0 ? 0 : me->cont_count - 1];

    // Check if a strength type is already defined
    if (m->factor_op != FILE_FACTOR_OP_NONE) {
        file_magwarn(ms, "Strength already defined for this entry");
        return -1;
    }

    // If the entry is of type FILE_NAME, warn that strength settings are not supported
    if (m->type == FILE_NAME) {
        file_magwarn(ms, "Strength settings are not supported for NAME entries");
        return -1;
    }

    // Read the operation type and factor value
    const char *l = line;
    EATAB;
    int op = get_op(*l++);
    if (op == -1) {
        file_magwarn(ms, "Invalid strength operation");
        return -1;
    }
    m->factor_op = op;
    m->factor = CAST(int32_t, strtol(l, CAST(char **, &l), 0));

    // Verify that the factor is within valid limits and not combined with a division operation when zero
    if (m->factor < -100 || m->factor > 100) {
        file_magwarn(ms, "Strength factor must be between -100 and 100");
        m->factor_op = FILE_FACTOR_OP_NONE;
        m->factor = 0;
        return -1;
    }
    if (m->factor == 0 && (op == FILE_OPDIVIDE || op == FILE_OPMODULO)) {
        file_magwarn(ms, "Strength factor cannot be zero with division or modulo operations");
        m->factor_op = FILE_FACTOR_OP_NONE;
        m->factor = 0;
        return -1;
    }

    return 0;
}