/* Re-check Ethernet type if required (e.g. after VLAN/MPLS/PPPoE tag
   * stripping)                                                         */
  if(recheck_type) {
    recheck_type = 0;
    goto ether_type_check;
  }

  /* Update statistics for VLAN tagged traffic */
  if(vlan_packet)
    workflow->stats.vlan_count++;

  /* *************************************************************** */
  /*               Start of the IP header handling code              */
  /* *************************************************************** */
iph_check:

  /* Some capture engines (e.g. DLT_RAW) do not set an EtherType.     */
  if(cprototype == 0)
    cprototype = ETH_P_IP;

  /* We only handle IPv4 and IPv6 packets from this point on          */
  if((cprototype != ETH_P_IP) && (cprototype != ETH_P_IPV6))
    goto v4_warning;

  /* Make sure that we have at least the size of an IPv4 header       */
  if((ip_offset + sizeof(struct ndpi_iphdr)) > header->caplen) {
    workflow->stats.total_discarded_bytes +=  header->len;
    return(nproto);
  }

  /* Set IPv4 header pointer (may be overwritten later in case of IPv6) */
  iph = (struct ndpi_iphdr *)&packet[ip_offset];

  /* Extract a few fields that will be used later                     */
  frag_off = ntohs(iph->frag_off);
  proto    = iph->protocol;

  /* Warn once if packets are truncated in the capture                */
  if(header->caplen < header->len) {
    static u_int8_t truncated_packet_warning_used = 0;

    if(truncated_packet_warning_used == 0) {
      if(!workflow->prefs.quiet_mode)
        NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
		 "\n\nWARNING: captured packet size (%u) is smaller than original size (%u)\n",
		 header->caplen, header->len);
      truncated_packet_warning_used = 1;
    }
  }