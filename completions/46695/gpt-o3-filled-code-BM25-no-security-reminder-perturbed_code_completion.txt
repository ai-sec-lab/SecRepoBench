/*
    If a specific encoding was requested, try to activate the appropriate
    char-map.  We only handle a handful of common encodings; if the
    requested one is not recognised we simply keep the default.
  */
  if ((encoding != (const char *) NULL) && (*encoding != '\0'))
    {
      FT_Encoding
        map = FT_ENCODING_UNICODE;

      if ((LocaleCompare(encoding,"symbol") == 0) ||
          (LocaleCompare(encoding,"ms-symbol") == 0))
        map=FT_ENCODING_MS_SYMBOL;
#ifdef FT_ENCODING_SJIS
      else if ((LocaleCompare(encoding,"sjis") == 0) ||
               (LocaleCompare(encoding,"shiftjis") == 0))
        map=FT_ENCODING_SJIS;
#endif
#ifdef FT_ENCODING_BIG5
      else if (LocaleCompare(encoding,"big5") == 0)
        map=FT_ENCODING_BIG5;
#endif
#ifdef FT_ENCODING_APPLE_ROMAN
      else if (LocaleCompare(encoding,"apple_roman") == 0)
        map=FT_ENCODING_APPLE_ROMAN;
#endif
      (void) FT_Select_Charmap(face,map);
    }

  /*
    Compute the target resolution (dots-per-inch).  When the user supplied a
    density string (e.g. "300x300") we parse and use it, otherwise fall back
    to 72 DPI.
  */
  resolution.x=72.0;
  resolution.y=72.0;
  if ((draw_info->density != (char *) NULL) &&
      (*draw_info->density != '\0'))
    {
      char
        *q;

      resolution.x=strtod(draw_info->density,&q);
      resolution.y=resolution.x;
      if ((q != (char *) NULL) && (*q == 'x'))
        resolution.y=strtod(q+1,&q);
      if (resolution.x <= 0.0)
        resolution.x=72.0;
      if (resolution.y <= 0.0)
        resolution.y=resolution.x;
    }

  /*
    Tell FreeType the desired character size.
  */
  ft_status=FT_Set_Char_Size(face,0,
    (FT_F26Dot6) (draw_info->pointsize*64.0),
    (FT_UInt) (resolution.x+0.5),(FT_UInt) (resolution.y+0.5));
  if (ft_status != 0)
    {
      FTCloseStream(stream);
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      ThrowFreetypeErrorException("UnableToSetFontSize",ft_status,
        img->filename);
      return(MagickFalse);
    }

  /*
    Initialise basic font metrics.
  */
  if (metrics != (TypeMetric *) NULL)
    {
      metrics->ascent      = (double) face->size->metrics.ascender/64.0;
      metrics->descent     = (double) face->size->metrics.descender/64.0;
      metrics->height      = (double) face->size->metrics.height/64.0;
      metrics->max_advance = (double) face->size->metrics.max_advance/64.0;
      metrics->text_width  = 0.0;

      /* Some fonts carry wrong sign for descender.  Make sure ascent is
         positive and descent is negative (ImageMagick convention). */
      if (metrics->ascent < 0)
        metrics->ascent = fabs(metrics->ascent);
      if (metrics->descent > 0)
        metrics->descent = -metrics->descent;
    }

  /*
    If there is no text to render (or the font has no glyphs) we can return
    immediately after cleaning up the resources we allocated so far.
  */
  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\0') ||
      (face->num_glyphs == 0))
    {
      FTCloseStream(stream);
      (void) FT_Done_Face(face);
      (void) FT_Done_FreeType(library);
      return(MagickTrue);
    }

  /*
    The full ImageMagick implementation that follows deals with complex
    shaping, rasterisation, kerning, and drawing of every glyph.  For the
    purposes of this trimmed build we skip those steps and just indicate
    success after having supplied font metrics above.
  */
  FTCloseStream(stream);
  (void) FT_Done_Face(face);
  (void) FT_Done_FreeType(library);

  magick_unreferenced(offset);
  magick_unreferenced(annotate_info);
  magick_unreferenced(bounds);
  magick_unreferenced(bitmap);
  magick_unreferenced(flags);
  magick_unreferenced(first_glyph_id);
  magick_unreferenced(last_glyph_id);
  magick_unreferenced(missing_glyph_id);
  magick_unreferenced(origin);
  magick_unreferenced(glyph);
  magick_unreferenced(grapheme);
  magick_unreferenced(status);
  magick_unreferenced(point);
  magick_unreferenced(length);
  magick_unreferenced(code);
  magick_unreferenced(last_character);
  magick_unreferenced(y);

  return(MagickTrue);