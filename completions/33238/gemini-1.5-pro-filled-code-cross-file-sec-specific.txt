if (in.empty()) {
            return;
        }

        // Remove leading spaces or new lines from the path
        char last = 0;
        std::string::iterator it = in.begin();
        while (IsSpaceOrNewLine(*it)) {
            ++it;
        }
        if (it != in.begin()) {
            in.erase(in.begin(), it);
        }


        const char separator = getOsSeparator();
        std::string result;
        result.reserve(in.size()); // Reserve enough space to prevent reallocations

        for (it = in.begin(); it != in.end(); ++it) {
            int remaining = std::distance(it, in.end());
            // Exclude :// and \\, which remain untouched.
            // https://sourceforge.net/tracker/?func=detail&aid=3031725&group_id=226462&atid=1067632
            if (remaining >= 3 && !strncmp(&*it, "://", 3)) {
                result.append(it, it + 3);
                it += 2;
                continue;
            }
            if (it == in.begin() && remaining >= 2 && !strncmp(&*it, "\\\\", 2)) {
                result.append(it, it + 2);
                it += 1;
                continue;
            }

            // Cleanup path delimiters
            if (*it == '/' || *it == '\\') {
                if (last != separator) {
                    result += separator;
                    last = separator;
                }
            } else if (*it == '%' && remaining > 2) {
                // Hex sequence in URIs
                if (IsHex((&*it)[1]) && IsHex((&*it)[2])) {
                    char hex[3] = {(*it)[1], (*it)[2], '\0'};
                    char decoded = static_cast<char>(strtol(hex, nullptr, 16));
                    if (decoded != 0) { // Check for valid decoding
                        result += decoded;
                        it += 2;
                    } else {
                        result += *it; // Append original character if decoding fails
                    }

                } else {
                    result += *it;
                }
            } else {
                result += *it;
                last = *it;
            }
        }
        in = result;