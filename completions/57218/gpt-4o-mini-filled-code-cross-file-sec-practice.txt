unsigned int iBone = 0;
    if (!ParseUnsignedInt(szCurrent, &szCurrent, iBone)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone index");
        SMDI_PARSE_RETURN;
    }

    // Validate the bone index to ensure it is within a reasonable range
    if (iBone == UINT_MAX) {
        LogErrorNoThrow("Invalid bone number while parsing bone index");
        SMDI_PARSE_RETURN;
    }

    // Add our bone to the list
    if (iBone >= asBones.size()) {
        asBones.resize(iBone + 1);
    }
    SMD::Bone& bone = asBones[iBone];

    bool bQuota = true;
    if ('\"' != *szCurrent) {
        LogWarning("Bone name is expected to be enclosed in double quotation marks.");
        bQuota = false;
    } else {
        ++szCurrent;
    }

    const char* szEnd = szCurrent;
    for (;;) {
        if (bQuota && '\"' == *szEnd) {
            iBone = (unsigned int)(szEnd - szCurrent);
            ++szEnd;
            break;
        } else if (!bQuota && IsSpaceOrNewLine(*szEnd)) {
            iBone = (unsigned int)(szEnd - szCurrent);
            break;
        } else if (!(*szEnd)) {
            LogErrorNoThrow("Unexpected EOF/EOL while parsing bone name");
            SMDI_PARSE_RETURN;
        }
        ++szEnd;
    }

    // Ensure the bone name is properly encoded to prevent XSS
    std::string boneName(szCurrent, iBone);
    bone.mName = boneName; // Store the bone name

    szCurrent = szEnd;

    // Parse the bone parent index, ensuring it is a signed integer
    if (!ParseSignedInt(szCurrent, &szCurrent, (int&)bone.iParent)) {
        LogErrorNoThrow("Unexpected EOF/EOL while parsing bone parent index. Assuming -1");
        bone.iParent = -1; // Default to -1 if parsing fails
    }

    // Go to the beginning of the next line
    SMDI_PARSE_RETURN;