/* ------------- numeric value ------------- */
        /* We already parsed the (signed) decimal integer part so that
           – endp now points right after it.
           Decide whether we have an integer (no '.' / 'e/E' follows) or a
           floating-point number.                                                     */
        int is_float = 0;
        if ((endp < str_end) && (*endp == '.' || *endp == 'e' || *endp == 'E')) {
            is_float = 1;
        }

        /* Make a NUL-terminated copy of the complete numeric token so that the
           standard C library helpers (strtoll / strtod) can be used safely.        */
        char *numbuf = (char*)malloc(str_len + 1);
        if (!numbuf) {
            PLIST_JSON_ERR("%s: Out of memory while parsing numeric value\n", __func__);
            return NULL;
        }
        memcpy(numbuf, str_val, str_len);
        numbuf[str_len] = '\0';

        if (!is_float) {
            /* -------------------- integer -------------------- */
            errno = 0;
            char *ep = NULL;
            int64_t ival = strtoll(numbuf, &ep, 10);
            if (errno || *ep != '\0') {
                PLIST_JSON_ERR("%s: invalid integer '%s'\n", __func__, numbuf);
                free(numbuf);
                return NULL;
            }

            if (ival < 0) {
                /* negative integer – create signed integer node if supported */
#ifdef plist_new_int
                primitivevalue = plist_new_int(ival);
#else
                /* fall back to unsigned by casting */
                primitivevalue = plist_new_uint((uint64_t)ival);
#endif
            } else {
                primitivevalue = plist_new_uint((uint64_t)ival);
            }
        } else {
            /* -------------------- floating point -------------------- */
            errno = 0;
            char *ep = NULL;
            double dval = strtod(numbuf, &ep);
            if (errno || *ep != '\0' || !isfinite(dval)) {
                PLIST_JSON_ERR("%s: invalid real '%s'\n", __func__, numbuf);
                free(numbuf);
                return NULL;
            }
            primitivevalue = plist_new_real(dval);
        }
        free(numbuf);