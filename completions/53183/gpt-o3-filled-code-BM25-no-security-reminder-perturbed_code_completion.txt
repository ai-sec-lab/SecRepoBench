const char *e = p;             /* pointer that will be returned */

  /* handle the '*' qualifier (unlimited length) */
  if (e < end && *e == '*') {
    if (value_pointer) *value_pointer = -1;      /* use -1 as “all” sentinel */
    e++;                                         /* consume '*'               */
    return e;
  }

  /* at least one digit must follow, otherwise this is an error */
  if (e >= end || !ISDIGIT((unsigned char)*e)) {
    return NULL;                                 /* parsing failed            */
  }

  /* accumulate decimal digits, checking for overflow */
  {
    int val = 0;
    while (e < end && ISDIGIT((unsigned char)*e)) {
      int d = *e - '0';
      if (val > (INT_MAX - d) / 10) {            /* overflow check            */
        mrb_raise(mrb, E_RANGE_ERROR, "too large number in directive");
      }
      val = val * 10 + d;
      e++;
    }
    if (value_pointer) *value_pointer = val;
  }