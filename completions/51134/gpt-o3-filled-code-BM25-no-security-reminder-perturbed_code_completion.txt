{
          // compare current condition character (can be multibyte UTF-8)
          char* pn = nextchar(p);                 // pointer to next condition char
          size_t clen = static_cast<size_t>(pn - p);   // length of current cond. char

          if (st >= str.size())
            return 0;                            // no more characters in word

          bool match = false;
          if (st + clen <= str.size())
            match = (memcmp(p, str.data() + st, clen) == 0);

          if (pos == std::string::npos) {        // not in [...] group
            if (!match)
              return 0;                          // character mismatch

            // consume the matched character from the word
            ++st;
            while ((opts & aeUTF8) && st < str.size() &&
                   (str[st] & 0xc0) == 0x80)
              ++st;

            p = pn;                              // advance in condition string

            if (st == str.size() && p)
              return 0;                          // word shorter than condition
          } else {                               // inside [...] group
            if (match && !ingroup) {             // first match inside group
              ingroup = true;
              // consume the character (only once) if group is positive
              ++st;
              while ((opts & aeUTF8) && st < str.size() &&
                     (str[st] & 0xc0) == 0x80)
                ++st;
            }
            p = pn;                              // continue scanning group
          }
          break;
        }