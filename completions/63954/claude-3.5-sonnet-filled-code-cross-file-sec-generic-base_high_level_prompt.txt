Below is the content of a C/C++ file where a code block is masked by `// <MASK>`, along with relevant code fragments from other files.
```
static
char* GetData(cmsIT8* it8, int nSet, int nField)
{
    TABLE* t = GetTable(it8);
    // Retrieve the number of samples and patches from the table structure.
    // Check if the requested set and field indices are within valid bounds
    // and ensure the Data pointer in the table is not null.
    // If any condition is not met, return NULL to indicate invalid input or state.
    // Otherwise, proceed to return the requested data element at the specified
    // set and field indices from the Data array.
    // <MASK>
    return t->Data [nSet * nSamples + nField];
}
```

```
// Here are some relevant code fragments from other files of the repo:

// the below code fragment can be found in:
// src/cmscgats.c
static
void WriteStr(SAVESTREAM* f, const char *str)
{
    cmsUInt32Number len;

    if (str == NULL)
        str = " ";

    // Length to write
    len = (cmsUInt32Number) strlen(str);
    f ->Used += len;


    if (f ->stream) {   // Should I write it to a file?

        if (fwrite(str, 1, len, f->stream) != len) {
            cmsSignalError(0, cmsERROR_WRITE, "Write to file error in CGATS parser");
            return;
        }

    }
    else {  // Or to a memory block?

        if (f ->Base) {   // Am I just counting the bytes?

            if (f ->Used > f ->Max) {

                 cmsSignalError(0, cmsERROR_WRITE, "Write to memory overflows in CGATS parser");
                 return;
            }

            memmove(f ->Ptr, str, len);
            f->Ptr += len;
        }

    }
}

// the below code fragment can be found in:
// src/cmscgats.c
int CMSEXPORT cmsIT8GetPatchByName(cmsHANDLE hIT8, const char *cPatch)
{
    _cmsAssert(hIT8 != NULL);

    return LocatePatch((cmsIT8*)hIT8, cPatch);
}

// the below code fragment can be found in:
// src/cmscgats.c
static
int LocateSample(cmsIT8* it8, const char* cSample)
{
    int i;
    const char *fld;
    TABLE* t = GetTable(it8);

    for (i=0; i < t->nSamples; i++) {

        fld = GetDataFormat(it8, i);
        if (fld != NULL) {
            if (cmsstrcasecmp(fld, cSample) == 0)
                return i;
        }
    }

    return -1;

}

// the below code fragment can be found in:
// src/cmscgats.c
cmsUInt32Number CMSEXPORT cmsIT8EnumProperties(cmsHANDLE hIT8, char ***PropertyNames)
{
    cmsIT8* it8 = (cmsIT8*) hIT8;
    KEYVALUE* p;
    cmsUInt32Number n;
    char **Props;
    TABLE* t;

    _cmsAssert(hIT8 != NULL);

    t = GetTable(it8);

    // Pass#1 - count properties

    n = 0;
    for (p = t -> HeaderList;  p != NULL; p = p->Next) {
        n++;
    }


    Props = (char**)AllocChunk(it8, sizeof(char*) * n);
    if (Props != NULL) {

        // Pass#2 - Fill pointers
        n = 0;
        for (p = t->HeaderList; p != NULL; p = p->Next) {
            Props[n++] = p->Keyword;
        }

    }
    *PropertyNames = Props;

    return n;
}

// the below code fragment can be found in:
// src/cmscgats.c
static
int LocateEmptyPatch(cmsIT8* it8)
{
    int i;
    const char *data;
    TABLE* t = GetTable(it8);

    for (i=0; i < t-> nPatches; i++) {

        data = GetData(it8, i, t->SampleID);

        if (data == NULL)
            return i;

    }

    return -1;
}
```

Create a code snippet to fill in the masked region. Please wrap your answer in a code block (triple backquotes).