(
        child->type == RE_NODE_RANGE_ANY &&   // Range over "any" byte
        child->next_sibling != NULL)          // Something must exist after it
    {
      RE_NODE* remainder_head = child->next_sibling;

      // Store gap limits.
      *min_gap     = (int32_t) child->start;
      *maximumgap  = (int32_t) child->end;

      // Detach the left part (everything before the current node)
      if (child->prev_sibling != NULL)
      {
        child->prev_sibling->next_sibling = NULL;
        re_ast->root_node->children_tail  = child->prev_sibling;
      }
      else
      {
        // Splitting at the very beginning, left part becomes empty.
        re_ast->root_node->children_head = NULL;
        re_ast->root_node->children_tail = NULL;
      }

      // Detach the right part from the current node
      remainder_head->prev_sibling = NULL;

      // Destroy the gap node â€“ it should not belong to either side
      yr_re_node_destroy(child);

      // Build the remainder AST
      RE_AST* rem_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
      if (rem_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;

      memset(rem_ast, 0, sizeof(RE_AST));
      rem_ast->root_node = remainder_head;

      *remainder_re_ast = rem_ast;

      return ERROR_SUCCESS;
    }