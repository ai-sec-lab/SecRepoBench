/* Basic sanity check */
  if(payload_len < sizeof(u_int32_t))
    return 1;

  /* Retrieve the number of tuples contained in this packet */
  tuple_count = ntohl(*((u_int32_t*)payload));
  payload     += sizeof(u_int32_t);
  payload_len -= sizeof(u_int32_t);

  /* Arbitrary upper-bound to avoid DoS with huge values            */
  /* SoftEther hand-shake generally contains < 50 tuples, 256 is ok */
  if((tuple_count == 0) || (tuple_count > 256))
    return 1;

  /* Flags telling whether we have found something worth storing */
  int found_host = 0, found_fqdn = 0;

  while(tuple_count && payload_len >= sizeof(u_int32_t)) {
    /* ---------------------------------------------------------- *
     * 1) Extract the key (field name)                            *
     * ---------------------------------------------------------- */
    if(payload_len < sizeof(u_int32_t))
      return 1;

    u_int32_t key_len = ntohl(*((u_int32_t*)payload));
    payload     += sizeof(u_int32_t);
    payload_len -= sizeof(u_int32_t);

    if((key_len == 0) || (key_len > payload_len))
      return 1;

    char key_buf[64];
    u_int32_t copy_key_len = (key_len < sizeof(key_buf)) ? key_len : sizeof(key_buf)-1;
    memcpy(key_buf, payload, copy_key_len);
    key_buf[copy_key_len] = '\0';

    payload     += key_len;
    payload_len -= key_len;

    /* ---------------------------------------------------------- *
     * 2) Extract the value length                                *
     * ---------------------------------------------------------- */
    if(payload_len < sizeof(u_int32_t))
      return 1;

    u_int32_t val_len = ntohl(*((u_int32_t*)payload));
    payload     += sizeof(u_int32_t);
    payload_len -= sizeof(u_int32_t);

    if(val_len > payload_len) /* malformed */
      return 1;

    /* ---------------------------------------------------------- *
     * 3) Handle the value for the keys we are interested in      *
     * ---------------------------------------------------------- */
    if(strcmp(key_buf, "host_name") == 0) {
      size_t dst_sz = sizeof(ndpiflow->protos.softether.hostname);
      size_t cpy    = (val_len < dst_sz) ? val_len : dst_sz - 1;
      memcpy(ndpiflow->protos.softether.hostname, payload, cpy);
      ndpiflow->protos.softether.hostname[cpy] = '\0';
      found_host = 1;
    } else if(strcmp(key_buf, "ddns_fqdn") == 0) {
      size_t dst_sz = sizeof(ndpiflow->protos.softether.fqdn);
      size_t cpy    = (val_len < dst_sz) ? val_len : dst_sz - 1;
      memcpy(ndpiflow->protos.softether.fqdn, payload, cpy);
      ndpiflow->protos.softether.fqdn[cpy] = '\0';
      found_fqdn = 1;
    }

    /* Skip the value bytes that we have just processed */
    payload     += val_len;
    payload_len -= val_len;

    tuple_count--;
  }

  /* If we could not consume all tuples or payload, consider it a failure */
  if(tuple_count != 0)
    return 1;

  if(found_host || found_fqdn)
    return 0;            /* Success â€“ at least one useful item found */

  return 1;              /* Nothing interesting for us in this packet */