/* Simple fallback implementation: a straightforward, yet efficient
     search that relies on memchr()/memcmp().  Although the original
     version used bit-trickery for speed, this approach is perfectly
     adequate for typical mruby string sizes and keeps the code small. */

  /* empty pattern matches at the beginning */
  if (m <= 0) {
    return 0;
  }
  /* pattern longer than the text cannot match */
  if (m > lengthy) {
    return -1;
  }

  /* single-byte pattern â€“ just use memchr() */
  if (m == 1) {
    const unsigned char *p = (const unsigned char *)memchr(ys, xs[0], (size_t)lengthy);
    if (p) {
      return (mrb_int)(p - ys);
    }
    return -1;
  }

  /* general case */
  for (long i = 0; i <= lengthy - m; ++i) {
    if (ys[i] == xs[0] && memcmp(ys + i, xs, (size_t)m) == 0) {
      return (mrb_int)i;
    }
  }