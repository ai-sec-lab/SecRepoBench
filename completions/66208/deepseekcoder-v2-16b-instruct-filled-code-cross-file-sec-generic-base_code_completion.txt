bitint x = 0, y = 0;
  long i;

  // Calculate initial masks for the first and last characters of xs
  bitint first_char_mask = MASK1 << (xs[0] * 8);
  bitint last_char_mask = MASK1 << (xs[m - 1] * 8);

  // Calculate the number of iterations needed
  long iterations = n - m + 1;

  // Iterate through ys in chunks of machine word size
  for (i = 0; i < iterations; i += sizeof(bitint)) {
    // Load the current chunk from ys into a bitint variable
    if (MRB_ENDIAN_BIG) {
      x = *(bitint*)(ys + i);
    } else {
      x = *(bitint*)(ys + i + (m - 1) * sizeof(bitint));
    }

    // Check if the first and last characters match
    if ((x & first_char_mask) == first_char_mask && (x & last_char_mask) == last_char_mask) {
      // Compare the rest of the substring xs with the current chunk in ys
      for (long j = 1; j < m - 1; j++) {
        if (xs[j] != ys[i + j]) {
          break;
        }
        if (j == m - 2) {
          // Found a match, return the starting index
          return i;
        }
      }
    }
  }

  // No match found, return -1
  return -1;