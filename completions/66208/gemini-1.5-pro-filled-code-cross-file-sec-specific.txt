bitint mask1 = (bitint)xs[0] * MASK1;
  bitint mask2 = (bitint)xs[m - 1] * MASK1;
  const unsigned char *yp = ys;
  const unsigned char *ye = ys + n;

  if (n < m) return -1;

  if (m == 0) return 0;

  if (m == 1) {
    for (const unsigned char *p = ys; p < ye; ++p) {
      if (*p == *xs) return (mrb_int)(p - ys);
    }
    return -1;
  }

  ye -= (m - 1);

  while (yp < ye) {
    bitint c = *(bitint *)yp;
    bitint x = c ^ mask1;
    bitint y = (c + MASK2) | MASK3;
    bitint z = x & y;

    if (z) {
      z = z ^ MASK4;
      const unsigned char *p = (const unsigned char *)&z;
      long k = 0;
#ifdef MRB_ENDIAN_BIG
      while (!p[k] && k < sizeof(bitint)) k++;
#else
      while (!p[sizeof(bitint) - k - 1] && k < sizeof(bitint)) k++;
#endif
      yp += k;
      if (yp >= ye) break;
      continue;
    }

    if (xs[m - 1] == yp[m - 1]) {
      if (memcmp(xs + 1, yp + 1, m - 2) == 0)
        return (mrb_int)(yp - ys);
    }
    yp++;
  }