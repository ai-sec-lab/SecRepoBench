bitint mask = 0;
  bitint first_char_mask = 0;
  bitint last_char_mask = 0;
  bitint first_char = xs[0];
  bitint last_char = xs[m - 1];

  // Create masks for the first and last characters
  first_char_mask = (first_char << (8 * (sizeof(bitint) - 1))) | (first_char << (8 * (sizeof(bitint) - 2))) | 
                    (first_char << (8 * (sizeof(bitint) - 3))) | (first_char << (8 * (sizeof(bitint) - 4))) |
                    (first_char << (8 * (sizeof(bitint) - 5))) | (first_char << (8 * (sizeof(bitint) - 6))) |
                    (first_char << (8 * (sizeof(bitint) - 7))) | (first_char << (8 * (sizeof(bitint) - 8)));

  last_char_mask = (last_char << (8 * (sizeof(bitint) - 1))) | (last_char << (8 * (sizeof(bitint) - 2))) | 
                   (last_char << (8 * (sizeof(bitint) - 3))) | (last_char << (8 * (sizeof(bitint) - 4))) |
                   (last_char << (8 * (sizeof(bitint) - 5))) | (last_char << (8 * (sizeof(bitint) - 6))) |
                   (last_char << (8 * (sizeof(bitint) - 7))) | (last_char << (8 * (sizeof(bitint) - 8)));

  for (long i = 0; i <= n - m; i += sizeof(bitint)) {
    // Load the next chunk of the search string
    bitint chunk = *((bitint *)(ys + i));

    // Calculate the mask for matching positions
    mask = (chunk ^ first_char_mask) & (chunk ^ last_char_mask);
    
    // Check if any bits are set in the mask
    if (mask != 0) {
      // Check for the first and last character matches
      if ((chunk & first_char_mask) == first_char_mask && (chunk & last_char_mask) == last_char_mask) {
        return i; // Found the substring
      }
    }
  }