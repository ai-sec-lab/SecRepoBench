)
{
  struct RString *s = mrb_str_ptr(str);
  const char *p = RSTRING_PTR(s);
  mrb_int len = RSTRING_LEN(s);
  char *buf;
  mrb_value result;

  if (len == 0) return mrb_nil_value();

  buf = (char*)mrb_malloc(mrb, len + 1);
  if (buf == NULL) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "failed to allocate memory");
  }
  if (ISLOWER(p[0])) {
    buf[0] = toupper(p[0]);
  }
  else {
    buf[0] = p[0];
  }
  for (int i = 1; i < len; i++) {
    if (ISUPPER(p[i])) {
      buf[i] = tolower(p[i]);
    }
    else {
      buf[i] = p[i];
    }
  }
  buf[len] = '\0';

  result = mrb_str_new(mrb, buf, len);
  mrb_free(mrb, buf);

  if (str_eql(mrb, str, result)) {
    return mrb_nil_value();
  }
  return str_replace(mrb, s, result);
}

/* 15.2.10.5.9  */
/*
 *  call-seq:
 *     str.capitalize   => new_str
 *
 *  Returns a copy of <i>str</i> with the first character converted to
 *  uppercase and the remainder to lowercase.
 *
 *     "hello".capitalize   #=> "Hello"
 *     "HELLO".capitalize   #=> "Hello"
 *     "123ABC".capitalize  #=> "123abc"
 */
static mrb_value
mrb_str_capitalize(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  const char *p = RSTRING_PTR(s);
  mrb_int len = RSTRING_LEN(s);
  char *buf;
  mrb_value result;

  if (len == 0) return mrb_str_new(mrb, "", 0);

  buf = (char*)mrb_malloc(mrb, len + 1);
  if (buf == NULL) {
    mrb_raise(mrb, E_RUNTIME_ERROR, "failed to allocate memory");
  }
  if (ISLOWER(p[0])) {
    buf[0] = toupper(p[0]);
  }
  else {
    buf[0] = p[0];
  }
  for (int i = 1; i < len; i++) {
    if (ISUPPER(p[i])) {
      buf[i] = tolower(p[i]);
    }
    else {
      buf[i] = p[i];
    }
  }
  buf[len] = '\0';

  result = mrb_str_new(mrb, buf, len);
  mrb_free(mrb, buf);

  return result;
}

/* 15.2.10.5.10 */
/*
 *  call-seq:
 *     str.casecmp(other_str)   => -1, 0, 1
 *
 *  Case-insensitive comparison of <i>str</i> with <i>other_str</i>.
 *
 *  If <i>str</i> <code><=></code> <i>other_str</i> is less than, equal to,
 *  or greater than 0, then so is the value returned by <code>casecmp</code>.
 *  This method is locale insensitive, so "ǅ" == "D" and "İ" == "i" may be true
 *  in some locales.
 *
 *     "abcdef".casecmp("abcde")     #=> 1
 *     "aBcDeF".casecmp("abcdef")    #=> 0
 *     "abcdef".casecmp("abcdefg")   #=> -1
 *     "abcdef".casecmp("ABCDEF")    #=> 0
 */
static mrb_value
mrb_str_casecmp(mrb_state *mrb, mrb_value str1)
{
  mrb_value str2 = mrb_get_arg1(mrb);
  int result;

  if (!mrb_string_p(str2)) {
    return mrb_nil_value();
  }
  else {
    result = strcasecmp(RSTRING_PTR(str1), RSTRING_PTR(str2));
  }
  if (result < 0) return mrb_int_value(mrb, -1);
  if (result > 0) return mrb_int_value(mrb, 1);
  return mrb_int_value(mrb, 0);
}

/* 15.2.10.5.11 */
/*
 *  call-seq:
 *     str.center(integer, padstr)   => new_str
 *
 *  If <i>integer</i> is greater than the length of <i>str</i>, returns a new
 *  <code>String</code>, padding with <i>padstr</i> to the width <i>integer</i>.
 *  Padding is done using the <i>padstr</i> string unless <i>padstr</i> is nil.
 *  If <i>integer</i> is less than or equal to the length of <i>str</i>, returns
 *  <i>str</i> itself.
 *
 *     "hello".center(4)         #=> "hello"
 *     "hello".center(20)        #=> "       hello        "
 *     "hello".center(20, '123') #=> "1231231hello12312312"
 */
static mrb_value
mrb_str_center(mrb_state *mrb, mrb_value str, mrb_value len, mrb_value padstr)
{
  mrb_int width, padlen;
  const char *pad;
  struct RString *s = mrb_str_ptr(str);
  mrb_int slen = RSTRING_LEN(s);
  mrb_value result;

  width = mrb_as_int(mrb, len);
  if (width <= slen) {
    return mrb_str_dup(mrb, str);
  }

  if (mrb_nil_p(padstr)) {
    pad = " ";
    padlen = 1;
  }
  else {
    pad = RSTRING_PTR(padstr);
    padlen = RSTRING_LEN(padstr);
  }

  result = mrb_str_new(mrb, 0, width);
  {
    char *p = RSTR_PTR(result);
    mrb_int pad_half = (width - slen) / 2;
    mrb_int pad_extra = (width - slen) % 2;
    mrb_int i;

    for (i = 0; i < pad_half; i++) {
      *p++ = *pad;
    }
    for (i = 0; i < slen; i++) {
      *p++ = RSTR_PTR(s)[i];
    }
    for (i = 0; i < pad_half + pad_extra; i++) {
      *p++ = *pad;
    }
    RSTR_SET_LEN(result, width);
    RSTR_PTR(result)[width] = '\0';
  }

  return result;
}

/* 15.2.10.5.12 */
/*
 *  call-seq:
 *     str.chars   => array
 *
 *  Returns an array of the characters in <i>str</i>.
 *
 *     "hello".chars   #=> ["h", "e", "l", "l", "o"]
 */
static mrb_value
mrb_str_chars(mrb_state *mrb, mrb_value str)
{
  struct RString *s = mrb_str_ptr(str);
  mrb_int len = RSTRING_LEN(s);
  mrb_value ary = mrb_ary_new(mrb);
  const char *p = RSTRING_PTR(s);
  mrb_int i;

  for (i = 0; i < len; i++) {
    mrb_str_cat_cstr(mrb, ary, p++);
  }

  return ary;
}

/* 15.2.10.5.13 */
/*
 *  call-seq:
 *     str.chomp([separator=$/])   => new_str
 *
 *  Returns a new <code>String</code> with the given record separator removed
 *  from the end of <i>str</i> (if present). If <code>$/</code> has not been
 *  changed from the default, then it removes carriage return followed by
 *  newline (`\r\n`) from the end of the string.
 *
 *     "hello".chomp         #=> "hello"
 *     "hello\n".chomp       #=> "hello"
 *     "hello\r\n".chomp     #=> "hello"
 *     "hello\n\r".chomp     #=> "hello\n"
 *     "hello\r".chomp       #=> "hello"
 *     "hello \n".chomp      #=> "hello "
 *     "hello \r\n".chomp    #=> "hello "
 *
 *  If <i>separator</i> is given and is not a newline character, then
 *  <code>chomp</code> removes that <i>separator</i> from the end of the string.
 *
 *     "hello".chomp("llo")   #=> "he"
 */
static mrb_value
mrb_str_chomp(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  struct RString *s = mrb_str_ptr(str);
  const char *sepstr = sep == mrb_nil_value() ? mrb_default_rs : RSTRING_PTR(sep);
  mrb_int seplen = sep == mrb_nil_value() ? mrb_strlen(mrb, sepstr) : RSTRING_LEN(sep);
  mrb_int len = RSTRING_LEN(s);
  const char *p = RSTRING_PTR(s) + len - seplen;

  if (len < seplen) {
    return mrb_str_dup(mrb, str);
  }

  if (memcmp(p, sepstr, seplen) == 0) {
    return mrb_str_new(mrb, RSTRING_PTR(s), len - seplen);
  }

  return mrb_str_dup(mrb, str);
}

/* 15.2.10.5.14 */
/*
 *  call-seq:
 *     str.chomp!([separator=$/])   => str or nil
 *
 *  Modifies <i>str</i> in place as described for <code>String#chomp</code>,
 *  returning <i>str</i>, or <code>nil</code> if no modifications were made.
 */
static mrb_value
mrb_str_chomp_bang(mrb_state *mrb, mrb_value str, mrb_value sep)
{
  struct RString *s = mrb_str_ptr(str);
  const char *sepstr = sep == mrb_nil_value() ? mrb_default_rs : RSTRING_PTR(sep);
  mrb_int seplen = sep == mrb_nil_value() ? mrb_strlen(mrb, sepstr) : RSTRING_LEN(sep);
  mrb_int len = RSTRING_LEN(s);
  const char *p = RSTRING_PTR(s) + len - seplen;

  if (len < seplen) {
    return mrb_nil_value();
  }

  if (memcmp(p, sepstr, seplen) == 0) {
    RSTR_SET_LEN(s, len - seplen);
    RSTR_PTR(s)[len - seplen] = '\0';
    return str;
  }

  return mrb