// Validate inputs
  if (xs == NULL || ys == NULL || m <= 0 || n <= 0 || m > n) {
    return -1; // Invalid parameters
  }

  // Initialize variables for the search
  const bitint *x = (const bitint *)xs;
  const bitint *y = (const bitint *)ys;
  long i = 0;

  // Calculate the number of complete bitint blocks we can process
  long block_count = n / sizeof(bitint);
  long pattern_count = m / sizeof(bitint);

  // Search for the pattern using SWAR technique
  for (i = 0; i <= block_count - pattern_count; i++) {
    bitint text_block = y[i];
    bitint pattern_block = x[0];

    // Create masks to find matches
    bitint cmp = (text_block ^ pattern_block) & MASK2;
    if ((cmp - MASK1) & ~cmp & MASK3) {
      // Check for a match
      if (memcmp((const char *)&y[i], xs, m) == 0) {
        return (mrb_int)(i * sizeof(bitint)); // Return the index of the match
      }
    }
  }

  // Handle remaining bytes
  const char *remaining = ys + (block_count * sizeof(bitint));
  for (i = 0; i <= n - (block_count * sizeof(bitint)); i++) {
    if (memcmp(remaining + i, xs, m) == 0) {
      return (mrb_int)((block_count * sizeof(bitint)) + i); // Return the index of the match
    }
  }

  return -1; // Pattern not found