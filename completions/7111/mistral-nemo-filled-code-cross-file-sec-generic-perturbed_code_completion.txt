switch (method)
{
  case ReadSingleSampleMethod:
  {
    quantum_type=IndexQuantum;
    if (tiff_image->alpha_trait != UndefinedPixelTrait)
      quantum_type=IndexAlphaQuantum;
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelIndex(tiff_image,GetNextPixelInCache(tiff_pixels),q);
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadRGBAMethod:
  {
    quantum_type=RGBQuantum;
    if (tiff_image->alpha_trait != UndefinedPixelTrait)
      quantum_type=RGBAQuantum;
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelRed(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetR(*p)),q);
        SetPixelGreen(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetG(*p)),q);
        SetPixelBlue(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetB(*p)),q);
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char)
            TIFFGetA(*p)),q);
        p++;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadCMYKAMethod:
  {
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelCyan(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetR(*p)),q);
        SetPixelMagenta(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetG(*p)),q);
        SetPixelYellow(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetB(*p)),q);
        SetPixelBlack(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetA(*p)),q);
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char)
            TIFFGetB(*(p+1))),q);
        p+=2;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadYCCKMethod:
  {
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      register ssize_t
        i;

      unsigned char
        *p;

      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      p=tiff_pixels;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelCyan(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p+
          (1.402*(double) *(p+2))-179.456)),q);
        SetPixelMagenta(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p-
          (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
          135.45984)),q);
        SetPixelYellow(tiff_image,ScaleCharToQuantum(ClampYCC((double) *p+
          (1.772*(double) *(p+1))-226.816)),q);
        SetPixelBlack(tiff_image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char)
            TIFFGetA(*(p+4))),q);
        p+=5;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadStripMethod:
  {
    register uint32
      *p;

    /*
      Convert stripped TIFF image to DirectClass MIFF image.
    */
    i=0;
    p=(uint32 *) NULL;
    for (y=0; y < (ssize_t) tiff_image->rows; y++)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      q=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,1,exception);
      if (q == (Quantum *) NULL)
        break;
      if (i == 0)
        {
          if (TIFFReadRGBAStrip(tiff,(uint32) x,(uint32) y,(uint32 *)
            tiff_pixels) == 0)
            break;
          i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)
            tiff_image->rows-y);
        }
      i--;
      p=((uint32 *) tiff_pixels)+tiff_image->columns*i;
      for (x=0; x < (ssize_t) tiff_image->columns; x++)
      {
        SetPixelRed(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetR(*p)),q);
        SetPixelGreen(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetG(*p)),q);
        SetPixelBlue(tiff_image,ScaleCharToQuantum((unsigned char)
          TIFFGetB(*p)),q);
        if (tiff_image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char)
            TIFFGetA(*p)),q);
        p++;
        q+=GetPixelChannels(tiff_image);
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    break;
  }
  case ReadTileMethod:
  {
    register uint32
      *p;

    uint32
      *tile_pixels,
      columns,
      rows;

    /*
      Convert tiled TIFF image to DirectClass MIFF image.
    */
    if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
        (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
      ThrowTIFFException(CoderError,"ImageIsNotTiled");
    if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
        (AcquireMagickResource(HeightResource,rows) == MagickFalse))
      ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
    (void) SetImageStorageClass(tiff_image,DirectClass,exception);
    number_pixels=(MagickSizeType) columns*rows;
    if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*
      sizeof(*tile_pixels));
    if (tile_pixels == (uint32 *) NULL)
      ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
    for (y=0; y < (ssize_t) tiff_image->rows; y+=rows)
    {
      register ssize_t
        x;

      register Quantum
        *magick_restrict q;

      size_t
        columns_remaining,
        rows_remaining;

      rows_remaining=tiff_image->rows-y;
      if ((ssize_t) (y+rows) < (ssize_t) tiff_image->rows)
        rows_remaining=rows;
      tile=QueueAuthenticPixels(tiff_image,0,y,tiff_image->columns,rows_remaining,
        exception);
      if (tile == (Quantum *) NULL)
        break;
      for (x=0; x < (ssize_t) tiff_image->columns; x+=columns)
      {
        size_t
          column,
          row;

        if (TIFFReadRGBAStrip(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)
          break;
        columns_remaining=tiff_image->columns-x;
        if ((ssize_t) (x+columns) < (ssize_t) tiff_image->columns)
          columns_remaining=columns;
        p=tile_pixels+(rows-rows_remaining)*columns;
        q=tile+GetPixelChannels(tiff_image)*(tiff_image->columns*(rows_remaining-1)+
          x);
        for (row=rows_remaining; row > 0; row--)
        {
          if (tiff_image->alpha_trait != UndefinedPixelTrait)
            for (column=columns_remaining; column > 0; column--)
            {
              SetPixelRed(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetR(*p)),q);
              SetPixelGreen(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetG(*p)),q);
              SetPixelBlue(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetB(*p)),q);
              SetPixelAlpha(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetA(*p)),q);
              p++;
              q+=GetPixelChannels(tiff_image);
            }
          else
            for (column=columns_remaining; column > 0; column--)
            {
              SetPixelRed(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetR(*p)),q);
              SetPixelGreen(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetG(*p)),q);
              SetPixelBlue(tiff_image,ScaleCharToQuantum((unsigned char)
                TIFFGetB(*p)),q);
              p++;
              q+=GetPixelChannels(tiff_image);
            }
          p+=columns-columns_remaining;
          q-=GetPixelChannels(tiff_image)*(tiff_image->columns+columns_remaining);
        }
      }
      if (SyncAuthenticPixels(tiff_image,exception) == MagickFalse)
        break;
      if (tiff_image->previous == (Image *) NULL)
        {
          status=SetImageProgress(tiff_image,LoadImageTag,(MagickOffsetType) y,
            tiff_image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);
    break;
  }
  case ReadGenericMethod:
  default:
  {
    MemoryInfo
      *pixel_info;

    register uint32
      *p;

    uint32
      *pixels;

    /*
      Convert TIFF image to DirectClass MIFF image.