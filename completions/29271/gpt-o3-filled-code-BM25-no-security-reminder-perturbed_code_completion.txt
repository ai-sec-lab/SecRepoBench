zval *pstorage, *pmembers;
	zval *zobj, *zinf;

	/* Fetch the serialized string passed from userland */
	if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &serialized_data_buffer, &buf_len) == FAILURE) {
		RETURN_THROWS();
	}

	if (buf_len == 0) {
		return;
	}

	/* Initialise unserialisation helpers */
	s = p = (const unsigned char *) serialized_data_buffer;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	/* --- storage -------------------------------------------------------- */
	if (*p != 'x' || *++p != ':') {
		goto outexcept;
	}
	++p;

	pstorage = var_tmp_var(&var_hash);
	if (!php_var_unserialize(pstorage, &p, s + buf_len, &var_hash) || Z_TYPE_P(pstorage) != IS_ARRAY) {
		goto outexcept;
	}

	/* Clean any previous content */
	zend_hash_clean(&intern->storage);

	/* Iterate through the (object, info) pairs */
	{
		HashTable *ht = Z_ARRVAL_P(pstorage);
		zend_long num = zend_hash_num_elements(ht);

		/* We expect an even number of elements: object / info pairs */
		if (num % 2 != 0) {
			goto outexcept;
		}

		for (zend_long idx = 0; idx < num; idx += 2) {
			zobj = zend_hash_index_find(ht, idx);
			zinf = zend_hash_index_find(ht, idx + 1);

			if (!zobj || Z_TYPE_P(zobj) != IS_OBJECT || !zinf) {
				goto outexcept;
			}

			/* Attach to internal storage */
			spl_object_storage_attach(intern, zobj, zinf);
		}
	}