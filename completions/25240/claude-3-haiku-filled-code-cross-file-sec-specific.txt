case 'k':
{
    // Parse material properties
    std::string propertyName;
    while (m_DataIt != m_DataItEnd && *m_DataIt != ' ') {
        propertyName += *m_DataIt;
        ++m_DataIt;
    }

    if (propertyName == "Ka") {
        // Parse ambient color
        getColorRGBA(m_pModel->m_pCurrentMaterial->ambient);
    } else if (propertyName == "Kd") {
        // Parse diffuse color
        getColorRGBA(m_pModel->m_pCurrentMaterial->diffuse);
    } else if (propertyName == "Ks") {
        // Parse specular color
        getColorRGBA(m_pModel->m_pCurrentMaterial->specular);
    } else if (propertyName == "Ke") {
        // Parse emissive color
        getColorRGBA(m_pModel->m_pCurrentMaterial->emissive);
    } else if (propertyName == "Kt") {
        // Parse transmission color
        getColorRGBA(m_pModel->m_pCurrentMaterial->transparent);
    } else if (propertyName == "d" || propertyName == "Tr") {
        // Parse transparency/alpha value
        getFloat(m_pModel->m_pCurrentMaterial->alpha);
    } else if (propertyName == "Ns") {
        // Parse specular exponent
        getFloat(m_pModel->m_pCurrentMaterial->shininess);
    } else if (propertyName == "Ni") {
        // Parse index of refraction
        getFloat(m_pModel->m_pCurrentMaterial->ior);
    } else if (propertyName == "newmtl") {
        // Create a new material
        m_pModel->m_pCurrentMaterial = new ObjFile::Material;
        m_pModel->m_MaterialLib.push_back(m_pModel->m_pCurrentMaterial->MaterialName.data);
    } else if (propertyName == "map_Kd") {
        // Parse diffuse texture
        parseDiffuseTexture();
    } else if (propertyName == "map_Ks") {
        // Parse specular texture
        parseSpecularTexture();
    } else if (propertyName == "map_Bump" || propertyName == "bump") {
        // Parse bump texture
        parseBumpTexture();
    } else if (propertyName == "illum") {
        // Parse illumination model
        getInteger(m_pModel->m_pCurrentMaterial->illumination_model);
    } else if (propertyName == "aniso") {
        // Parse anisotropy
        getFloat(m_pModel->m_pCurrentMaterial->anisotropy);
    } else {
        // Unsupported property, skip line
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
}
break;