case 'k':
{
    // Parse material properties
    std::string propertyName;
    getNextToken(m_DataIt, m_DataItEnd, propertyName);

    if (propertyName == "Ka") {
        // Parse ambient color
        getColorRGBA(m_pModel->m_pCurrentMaterial->ambient);
    } else if (propertyName == "Kd") {
        // Parse diffuse color
        getColorRGBA(m_pModel->m_pCurrentMaterial->diffuse);
    } else if (propertyName == "Ks") {
        // Parse specular color
        getColorRGBA(m_pModel->m_pCurrentMaterial->specular);
    } else if (propertyName == "Ke") {
        // Parse emissive color
        getColorRGBA(m_pModel->m_pCurrentMaterial->emissive);
    } else if (propertyName == "Kt") {
        // Parse transmission color
        getColorRGBA(m_pModel->m_pCurrentMaterial->transparent);
    } else if (propertyName == "d" || propertyName == "Tr") {
        // Parse transparency/alpha value
        float value;
        getValue(m_DataIt, m_DataItEnd, value);
        m_pModel->m_pCurrentMaterial->alpha = value;
    } else if (propertyName == "Ns") {
        // Parse specular exponent
        float value;
        getValue(m_DataIt, m_DataItEnd, value);
        m_pModel->m_pCurrentMaterial->shininess = value;
    } else if (propertyName == "Ni") {
        // Parse index of refraction
        float value;
        getValue(m_DataIt, m_DataItEnd, value);
        m_pModel->m_pCurrentMaterial->ior = value;
    } else if (propertyName == "newmtl") {
        // Create a new material
        std::string materialName;
        getNextToken(m_DataIt, m_DataItEnd, materialName);
        m_pModel->m_pCurrentMaterial = new ObjFile::Material;
        m_pModel->m_pCurrentMaterial->MaterialName = materialName;
        m_pModel->m_MaterialLib.push_back(materialName);
    } else if (propertyName == "map_Kd") {
        // Parse diffuse texture
        std::string textureName;
        getNextToken(m_DataIt, m_DataItEnd, textureName);
        m_pModel->m_pCurrentMaterial->texture = textureName;
    } else if (propertyName == "map_Ks") {
        // Parse specular texture
        std::string textureName;
        getNextToken(m_DataIt, m_DataItEnd, textureName);
        m_pModel->m_pCurrentMaterial->specularTexture = textureName;
    } else if (propertyName == "map_Bump" || propertyName == "bump") {
        // Parse bump/normal texture
        std::string textureName;
        getNextToken(m_DataIt, m_DataItEnd, textureName);
        m_pModel->m_pCurrentMaterial->bumpTexture = textureName;
    } else if (propertyName == "illum") {
        // Parse illumination model
        int value;
        getValue(m_DataIt, m_DataItEnd, value);
        m_pModel->m_pCurrentMaterial->illumination = value;
    } else if (propertyName == "aniso") {
        // Parse anisotropy
        float value;
        getValue(m_DataIt, m_DataItEnd, value);
        m_pModel->m_pCurrentMaterial->anisotropy = value;
    } else {
        // Unsupported property, skip the line
        m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
    }
}
break;