else {
          regs[a+1] = mrb_ary_subseq(mrb, regs[a+1], 1, RARRAY_LEN(regs[a+1]) - 1);
        }
        ci->stack[a+1] = regs[a+1];
        ci->stack[a+2] = blk;
        ci->argc = -1;
        regs[a] = recv;
        goto L_RAISE;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);
        mrb_int nregs = p->body.irep->nregs;

        if (nregs < argc + 2) {
          mrb_stack_extend(mrb, argc + 2);
        }
        regs[a] = recv;
        regs[a+argc+1] = blk;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        ci->mid = mid;
        ci->u.target_class = cls;
        ci->acc = CI_ACC_SKIP;
        pc = irep->iseq + p->body.irep->iseq;
        JUMP;
      }
      regs[a] = recv;
      ci->stack[0] = recv;
      if (argc >= 0) {
        stack_copy(ci->stack+1, regs+a+1, argc);
      }
      ci->stack[argc+1] = blk;
      ci->mid = mid;
      ci->u.target_class = cls;
      ci->acc = CI_ACC_SKIP;
      pc = irep->iseq + MRB_METHOD_PROC(m)->body.irep->iseq;
      JUMP;
    }

    CASE(OP_SENDB_SYM, BB) {
      mid = b;
      goto L_SEND_SYM;
    }

    CASE(OP_CALL, BBB) {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, ci->mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, ci->mid, recv, args);
        }
        if (ci->mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, c, regs+a+1);
          regs[a+2] = blk;
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_subseq(mrb, regs[a+1], 1, RARRAY_LEN(regs[a+1]) - 1);
        }
        ci->stack[a+1] = regs[a+1];
        ci->stack[a+2] = blk;
        ci->argc = -1;
        regs[a] = recv;
        goto L_RAISE;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);
        mrb_int nregs = p->body.irep->nregs;

        if (nregs < argc + 2) {
          mrb_stack_extend(mrb, argc + 2);
        }
        regs[a] = recv;
        regs[a+argc+1] = blk;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        ci->mid = ci->mid;
        ci->u.target_class = cls;
        ci->acc = CI_ACC_SKIP;
        pc = irep->iseq + p->body.irep->iseq;
        JUMP;
      }
      regs[a] = recv;
      ci->stack[0] = recv;
      if (argc >= 0) {
        stack_copy(ci->stack+1, regs+a+1, argc);
      }
      ci->stack[argc+1] = blk;
      ci->mid = ci->mid;
      ci->u.target_class = cls;
      ci->acc = CI_ACC_SKIP;
      pc = irep->iseq + MRB_METHOD_PROC(m)->body.irep->iseq;
      JUMP;
    }

    CASE(OP_CALL_KW, BBB) {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, ci->mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, ci->mid, recv, args);
        }
        if (ci->mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing; /* just in case */
        if (argc >= 0) {
          if (a+2 >= irep->nregs) {
            mrb_stack_extend(mrb, a+3);
          }
          regs[a+1] = mrb_ary_new_from_values(mrb, c, regs+a+1);
          regs[a+2] = blk;
          argc = -1;
        }
        else {
          regs[a+1] = mrb_ary_subseq(mrb, regs[a+1], 1, RARRAY_LEN(regs[a+1]) - 1);
        }
        ci->stack[a+1] = regs[a+1];
        ci->stack[a+2] = blk;
        ci->argc = -1;
        regs[a] = recv;
        goto L_RAISE;
      }
      if (MRB_METHOD_PROC_P(m)) {
        struct RProc *p = MRB_METHOD_PROC(m);
        mrb_int nregs = p->body.irep->nregs;

        if (nregs < argc + 2) {
          mrb_stack_extend(mrb, argc + 2);
        }
        regs[a] = recv;
        regs[a+argc+1] = blk;
        ci->stack[0] = recv;
        if (argc >= 0) {
          stack_copy(ci->stack+1, regs+a+1, argc);
        }
        ci->stack[argc+1] = blk;
        ci->mid = ci->mid;
        ci->u.target_class = cls;
        ci->acc = CI_ACC_SKIP;
        pc = irep->iseq + p->body.irep->iseq;
        JUMP;
      }
      regs[a] = recv;
      ci->stack[0] = recv;
      if (argc >= 0) {
        stack_copy(ci->stack+1, regs+a+1, argc);
      }
      ci->stack[argc+1] = blk;
      ci->mid = ci->mid;
      ci->u.target_class = cls;
      ci->acc = CI_ACC_SKIP;
      pc = irep->iseq + MRB_METHOD_PROC(m)->body.irep->iseq;
      JUMP;
    }

    CASE(OP_CALL_KW_SYM, B) {
      mid = b;
      goto L_SEND_SYM;
    }

    CASE(OP_CALL_ARG, BB) {
      mrb_int argc = (c == CALL_MAXARGS) ? -1 : c;
      mrb_int bidx = (argc < 0) ? a+2 : a+c+1;
      mrb_method_t m;
      struct RClass *cls;
      mrb_callinfo *ci = mrb->c->ci;
      mrb_value recv, blk;

      recv = regs[a];
      blk = regs[bidx];
      if (!mrb_nil_p(blk) && !mrb_proc_p(blk)) {
        blk = mrb_type_convert(mrb, blk, MRB_TT_PROC, MRB_SYM(to_proc));
        /* The stack might have been reallocated during mrb_type_convert(),
           see #3622 */
        regs[bidx] = blk;
      }
      cls = mrb_class(mrb, recv);
      m = mrb_method_search_vm(mrb, &cls, ci->mid);
      if (MRB_METHOD_UNDEF_P(m)) {
        mrb_sym missing = MRB_SYM(method_missing);
        mrb_value args;

        if (mrb_func_basic_p(mrb, recv, missing, mrb_obj_missing)) {
        method_missing:
          args = get_send_args(mrb, argc, regs+a+1);
          mrb_method_missing(mrb, ci->mid, recv, args);
        }
        if (ci->mid != missing) {
          cls = mrb_class(mrb, recv);
        }
        m = mrb_method_search_vm(mrb, &cls, missing);
        if (MRB_METHOD_UNDEF_P(m)) goto method_missing