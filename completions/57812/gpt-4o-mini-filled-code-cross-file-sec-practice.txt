pps->num_ref_loc_offsets = get_ue_golomb_long(gb);
    if (pps->num_ref_loc_offsets > MAX_REF_LOC_OFFSETS) {
        av_log(avctx, AV_LOG_ERROR, "num_ref_loc_offsets exceeds maximum allowed value.\n");
        return AVERROR_INVALIDDATA;
    }

    for (int i = 0; i < pps->num_ref_loc_offsets; i++) {
        pps->ref_loc_layer_id[i] = get_bits(gb, 6); // Assuming layer ID is 6 bits
        if (pps->ref_loc_layer_id[i] >= MAX_LAYER_ID) {
            av_log(avctx, AV_LOG_ERROR, "Invalid layer ID encountered: %d\n", pps->ref_loc_layer_id[i]);
            return AVERROR_INVALIDDATA;
        }

        // Process flags for scaled reference layer offsets
        pps->scaled_ref_layer_offset_flag[i] = get_bits1(gb);
        if (pps->scaled_ref_layer_offset_flag[i]) {
            pps->scaled_ref_layer_offset[i] = get_se_golomb_long(gb);
            // Validate the offset value
            if (pps->scaled_ref_layer_offset[i] < MIN_OFFSET_VALUE || pps->scaled_ref_layer_offset[i] > MAX_OFFSET_VALUE) {
                av_log(avctx, AV_LOG_ERROR, "Invalid scaled reference layer offset: %d\n", pps->scaled_ref_layer_offset[i]);
                return AVERROR_INVALIDDATA;
            }
        }

        // Handle resample phases for luma and chroma components if specified
        if (get_bits1(gb)) { // Check if resample phase is present
            pps->luma_resample_phase[i] = get_se_golomb_long(gb);
            pps->chroma_resample_phase[i] = get_se_golomb_long(gb);
        }
    }