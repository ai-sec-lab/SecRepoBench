/*
    Handle parenthesis, unary operators, a subset of mathematical functions
    and well-known constants.  Anything that is not recognised here is
    handled later in the generic “number / symbol” section that follows.
  */
  while (isspace((int) ((unsigned char) *expression)) != 0)
    expression++;

  /* expressions enclosed in parenthesis */
  if (*expression == '(')
    {
      ssize_t
        level = 1;

      const char
        *r = expression+1;

      while ((*r != '\0') && (level > 0))
        {
          if (*r == '(')
            level++;
          else
            if (*r == ')')
              level--;
          if (level > 0)
            r++;
        }
      if (*r == '\0')
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            "UnableToParseExpression","`%s'",expression);
          FxReturn(0.0);
        }
      (void) CopyMagickString(subexpression,expression+1,(size_t) (r-expression));
      subexpression[r-expression-1]='\0'; /* strip trailing ')' */
      result=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,
        depth+1,beta,exception);
      *beta=result;
      FxReturn(result);
    }

  /* unary plus / minus */
  if ((*expression == '+') || (*expression == '-'))
    {
      int sign = (*expression == '-') ? -1 : 1;
      result=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,
        depth+1,beta,exception);
      *beta=result*sign;
      FxReturn(*beta);
    }

  /* function call or constant */
  {
    const char *p = expression;
    if (isalpha((int) ((unsigned char) *p)) != 0)
      {
        char name[MagickPathExtent];
        size_t n = 0;

        while (isalpha((int) ((unsigned char) *p)) != 0)
          {
            if (n < (MagickPathExtent-1))
              name[n++]=(char) LocaleTolower((int) *p);
            p++;
          }
        name[n]='\0';

        /* Mathematical constants. */
        if ((LocaleCompare(name,"pi") == 0) && (*p == '\0'))
          {
            result=(double) MagickPI;
            *beta=result;
            FxReturn(result);
          }
        if ((LocaleCompare(name,"e") == 0) && (*p == '\0'))
          {
            result=exp(1.0);
            *beta=result;
            FxReturn(result);
          }

        /* function( … ) */
        if (*p == '(')
          {
            /* isolate sub-expression inside the parenthesis              */
            ssize_t level = 1;
            const char *q = ++p;   /* skip '(' */
            while ((*q != '\0') && (level > 0))
              {
                if (*q == '(')
                  level++;
                else if (*q == ')')
                  level--;
                if (level > 0)
                  q++;
              }
            if (*q == '\0')
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,"UnableToParseExpression","`%s'",expression);
                FxReturn(0.0);
              }
            (void) CopyMagickString(subexpression,p,(size_t) (q-p+1));
            subexpression[q-p]='\0';

            /* split possible second argument (arg1 , arg2)               */
            char *comma_ptr = (char *) NULL;
            {
              ssize_t nest = 0;
              for (char *t=subexpression; *t!='\0'; t++)
                {
                  if (*t == '(') nest++;
                  else if (*t == ')') nest--;
                  else if ((*t == ',') && (nest == 0))
                    { comma_ptr=t; break; }
                }
            }

            double arg1=0.0,arg2=0.0;
            if (comma_ptr != (char *) NULL)
              {
                *comma_ptr='\0';
                arg1=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,
                  depth+1,beta,exception);
                arg2=FxEvaluateSubexpression(fx_info,channel,x,y,comma_ptr+1,
                  depth+1,beta,exception);
              }
            else
              {
                arg1=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,
                  depth+1,beta,exception);
              }

            /* evaluate the recognised function                           */
            if (LocaleCompare(name,"abs") == 0)
              result=fabs(arg1);
            else if (LocaleCompare(name,"sin") == 0)
              result=sin(arg1);
            else if (LocaleCompare(name,"cos") == 0)
              result=cos(arg1);
            else if (LocaleCompare(name,"tan") == 0)
              result=tan(arg1);
            else if (LocaleCompare(name,"asin") == 0)
              result=asin(arg1);
            else if (LocaleCompare(name,"acos") == 0)
              result=acos(arg1);
            else if (LocaleCompare(name,"atan") == 0)
              result=atan(arg1);
            else if (LocaleCompare(name,"atan2") == 0)
              result=atan2(arg1,arg2);
            else if (LocaleCompare(name,"exp") == 0)
              result=exp(arg1);
            else if (LocaleCompare(name,"log") == 0)
              result=log(arg1);
            else if (LocaleCompare(name,"log10") == 0)
              result=log10(arg1);
            else if (LocaleCompare(name,"sqrt") == 0)
              result=sqrt(arg1);
            else if (LocaleCompare(name,"ceil") == 0)
              result=ceil(arg1);
            else if (LocaleCompare(name,"floor") == 0)
              result=floor(arg1);
            else if (LocaleCompare(name,"pow") == 0)
              result=pow(arg1,arg2);
            else if (LocaleCompare(name,"min") == 0)
              result=(arg1 < arg2) ? arg1 : arg2;
            else if (LocaleCompare(name,"max") == 0)
              result=(arg1 > arg2) ? arg1 : arg2;
            else
              goto fallback_label; /* unknown function */

            *beta=result;
            FxReturn(result);
          }
      }
  }

fallback_label: ;