const StringInfo
    *profile;

  /*
    Only handle requests that start with "icc:" or "icm:".
  */
  if ((image == (const Image *) NULL) || (key == (const char *) NULL))
    return((const char *) NULL);
  if ((LocaleNCompare(key,"icc:",4) != 0) &&
      (LocaleNCompare(key,"icm:",4) != 0))
    return((const char *) NULL);

  /*
    Locate an ICC/ICM profile in the image.
  */
  profile=GetImageProfile(image,"icc");
  if (profile == (const StringInfo *) NULL)
    profile=GetImageProfile(image,"icm");
  if (profile == (const StringInfo *) NULL)
    return((const char *) NULL);

  /*
    Special handling for a few simple sub-properties.
  */
  if (LocaleCompare(key+4,"length") == 0)  /* "icc:length" */
    {
      char
        value[MagickPathExtent];

      (void) FormatLocaleString(value,MagickPathExtent,"%.20g",
        (double) GetStringInfoLength(profile));
      (void) SetImageProperty((Image *) image,key,value,exception_info);
      return(GetImageProperty((Image *) image,key,exception_info));
    }

  /*
    Return the complete profile as a hex encoded string for
    requests such as "icc:profile" or "icm:profile".
  */
  if ((LocaleCompare(key+4,"profile") == 0) ||
      (LocaleCompare(key+4,"blob") == 0))
    {
      const unsigned char
        *p;

      char
        *hex_text;

      size_t
        length,
        i;

      length=GetStringInfoLength(profile);
      p=GetStringInfoDatum(profile);
      /* allocate space for two hex digits per byte plus the terminator */
      hex_text=(char *) AcquireQuantumMemory(length*2+1,sizeof(*hex_text));
      if (hex_text == (char *) NULL)
        return((const char *) NULL);
      for (i=0; i < length; i++)
        (void) FormatLocaleString(hex_text+i*2,3,"%02X",(unsigned int) p[i]);
      (void) SetImageProperty((Image *) image,key,hex_text,exception_info);
      hex_text=DestroyString(hex_text);
      return(GetImageProperty((Image *) image,key,exception_info));
    }

  /*
    Unknown sub-property requested.
  */
  return((const char *) NULL);