/* total packet length */
    packetlength = packet->payload_packet_len;

    /* If the packet length is exactly the size of the IAX header (12 bytes),
     * we can immediately flag the flow as IAX. */
    if(packetlength == 12) {
      NDPI_LOG_INFO(ndpi_struct, "IAX detected (header only)\n");
      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
      return;
    }

    /* Otherwise walk through the list of Information Elements (IEs)
     * that follow the fixed 12-byte header.  Each IE consists of:
     *   1 byte  : type
     *   1 byte  : length of the value field
     *   N bytes : value (N == length)
     */
    i = 0;
    while((u_int16_t)(12 + i + 1) < packetlength) {
      u_int8_t ie_len = packet->payload[12 + i + 1];

      /* Advance to the next IE: current position + type(1) + len(1) + value */
      i += (u_int8_t)2 + ie_len;

      /* If we land exactly at the end of the payload, the structure is sane:
       * declare the protocol as IAX.                                    */
      if((u_int16_t)(12 + i) == packetlength) {
        NDPI_LOG_INFO(ndpi_struct, "IAX detected (header + IEs)\n");
        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_IAX, NDPI_PROTOCOL_UNKNOWN);
        return;
      }

      /* If we overrun the payload, the packet is malformed â€“ stop parsing. */
      if((u_int16_t)(12 + i) > packetlength)
        break;
    }