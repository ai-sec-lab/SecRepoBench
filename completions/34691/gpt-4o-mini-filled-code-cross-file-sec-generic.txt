mrb_get_args(mrb, "|i", &n);
  if (n < 0) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, "negative array size");
  }
  
  if (n == 0 || len == 0) {
    return mrb_nil_value(); // Return nil if no elements to shift
  }

  if (n > len) {
    n = len; // Adjust n to not exceed the length of the array
  }

  val = ARY_PTR(a)[0]; // Get the first element to return
  ary_modify(mrb, a); // Ensure the array is modifiable

  if (ARY_SHARED_P(a) && a->as.heap.aux.shared->refcnt == 1) {
    // If the array is shared and only referenced by this array
    // we can safely shift elements without reallocating
    mrb_value *ptr = ARY_PTR(a);
    for (mrb_int i = 0; i < len - n; i++) {
      ptr[i] = ptr[i + n]; // Shift elements left
    }
    ARY_SET_LEN(a, len - n); // Update the length
  } else {
    // If the array is not shared or has multiple references
    // we need to create a new array or modify it safely
    mrb_value *ptr = ARY_PTR(a);
    for (mrb_int i = 0; i < len - n; i++) {
      ptr[i] = ptr[i + n]; // Shift elements left
    }
    ARY_SET_LEN(a, len - n); // Update the length
  }

  return val; // Return the shifted value