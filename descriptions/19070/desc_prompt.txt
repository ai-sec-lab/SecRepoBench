Below is the content of a code file where a code block is masked by `// <MASK>`.
```
case IEEE_1722_61883_4:
            if (db_size != 6)
            {
                expert_add_info(pinfo, ti_cip_dbs, &ei_1722_61883_4_incorrect_cip_dbs);
            }
            if (cip_fn != 8)
            {
                expert_add_info(pinfo, ti_cip_fn, &ei_1722_61883_4_incorrect_cip_fn);
            }
            if (cip_sph != 4)
            {
                expert_add_info(pinfo, ti_cip_sph, &ei_1722_61883_4_incorrect_cip_sph);
            }
            /* Make the video tree. */
            ti = proto_tree_add_item(ti_61883_tree, hf_1722_61883_video_data, tvb, offset, datalen, ENC_NA);
            ti_video_tree = proto_item_add_subtree(ti, ett_1722_61883_video);
            if ((datalen % IEEE_1722_61883_4_LEN_SOURCE_PACKET) != 0)
            {
                expert_add_info(pinfo, ti, &ei_1722_61883_incorrect_datalen);
                expert_add_info(pinfo, ti_datalen, &ei_1722_61883_incorrect_datalen);
            }
            numSourcePackets = datalen / IEEE_1722_61883_4_LEN_SOURCE_PACKET;

            if (ti_video_tree) {
                /* Loop through all packets and add them to the video tree. */
                for (j = 0; j < numSourcePackets; j++) {
                    proto_tree_add_item(ti_video_tree, hf_1722_61883_source_packet_header_timestamp, tvb, offset, IEEE_1722_61883_4_LEN_SP_TIMESTAMP, ENC_BIG_ENDIAN);
                    offset += IEEE_1722_61883_4_LEN_SP_TIMESTAMP;
                    proto_tree_add_item(ti_video_tree, hf_1722_61883_video_data, tvb, offset, (IEEE_1722_61883_4_LEN_SOURCE_PACKET - IEEE_1722_61883_4_LEN_SP_TIMESTAMP), ENC_NA);
                    offset += (IEEE_1722_61883_4_LEN_SOURCE_PACKET - IEEE_1722_61883_4_LEN_SP_TIMESTAMP);
                }
            }
            break;
        default:
            expert_add_info(pinfo, ti_cip_fmt, &ei_1722_61883_unknown_format);
            break;
        }
        break;
    default:
        break;
    }
    return tvb_captured_length(tvb);
}

void proto_register_1722_61883(void)
{
    static hf_register_info hf[] = {
        { &hf_1722_61883_mrfield,
            { "Media Clock Restart", "iec61883.mrfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_MR_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_gvfield,
            { "Gateway Info Valid", "iec61883.gvfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_GV_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_tvfield,
            { "Timestamp Valid", "iec61883.tvfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TV_MASK, NULL, HFILL }
            },
        { &hf_1722_61883_seqnum,
            { "Sequence Number", "iec61883.seqnum",
              FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_tufield,
            { "Timestamp Uncertain", "iec61883.tufield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TU_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_stream_id,
            { "Stream ID", "iec61883.stream_id",
              FT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_avtp_timestamp,
            { "AVTP Timestamp", "iec61883.avtp_timestamp",
              FT_UINT32, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_gateway_info,
            { "Gateway Info", "iec61883.gateway_info",
              FT_UINT32, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_stream_data_length,
            { "1394 Stream Data Length", "iec61883.stream_data_len",
              FT_UINT16, BASE_DEC|BASE_UNIT_STRING, &units_byte_bytes, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_tag,
            { "1394 Packet Format Tag", "iec61883.tag",
              FT_UINT8, BASE_HEX, VALS(tag_vals), IEEE_1722_TAG_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_channel,
            { "1394 Packet Channel", "iec61883.channel",
                FT_UINT8, BASE_DEC, NULL, IEEE_1722_CHANNEL_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_tcode,
            { "1394 Packet Tcode", "iec61883.tcode",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_TCODE_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_sy,
            { "1394 App-specific Control", "iec61883.sy",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_SY_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_qi1,
            { "CIP Quadlet Indicator 1", "iec61883.qi1",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_QI1_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_sid,
            { "CIP Source ID", "iec61883.sid",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_SID_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_dbs,
            { "CIP Data Block Size", "iec61883.dbs",
              FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_cip_fn,
            { "CIP Fraction Number", "iec61883.fn",
              FT_UINT8, BASE_HEX, VALS(fraction_number_vals), IEEE_1722_FN_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_qpc,
            { "CIP Quadlet Padding Count", "iec61883.qpc",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_QPC_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_sph,
            { "CIP Source Packet Header", "iec61883.sph",
              FT_BOOLEAN, 8, NULL, IEEE_1722_SPH_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_dbc,
            { "CIP Data Block Continuity", "iec61883.dbc",
              FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_cip_qi2,
            { "CIP Quadlet Indicator 2", "iec61883.qi2",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_QI2_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_fmt,
            { "CIP Format ID", "iec61883.fmt",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(format_rvals), IEEE_1722_FMT_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_fdf_no_syt,
            { "CIP Format Dependent Field", "iec61883.fdf_no_syt",
              FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_cip_fdf_tsf,
            { "Time shift flag", "iec61883.fdf_tsf",
              FT_BOOLEAN, 8, NULL, IEEE_1722_FDF_TSF_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_fdf,
            { "CIP Format Dependent Field", "iec61883.fdf",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(fdf_rvals), IEEE_1722_FDF_MASK, NULL, HFILL }
        },
        { &hf_1722_61883_cip_syt,
            { "CIP SYT", "iec61883.syt",
              FT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(syt_rvals), 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_audio_data,
            { "Audio Data", "iec61883.audiodata",
              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_label,
            { "Label", "iec61883.audiodata.sample.label",
              FT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_sample,
            { "Sample", "iec61883.audiodata.sample.sampledata",
              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_video_data,
            { "Video Data", "iec61883.videodata",
              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_61883_source_packet_header_timestamp,
            { "Source Packet Header Timestamp", "iec61883.spht",
              FT_UINT32, BASE_HEX, NULL, 0x00, NULL, HFILL }
        }
    };

    static gint *ett[] = {
        &ett_1722_61883,
        &ett_1722_61883_audio,
        &ett_1722_61883_sample,
        &ett_1722_61883_video
    };

    static ei_register_info ei[] = {
        { &ei_1722_61883_incorrect_tag,         { "iec61883.incorrect_tag", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect tag field, only 0x00 and 0x01 supported for AVTP", EXPFILL }},
        { &ei_1722_61883_incorrect_tcode,       { "iec61883.incorrect_tcode", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect tcode, talker shall set this field to 0x0A", EXPFILL }},
        { &ei_1722_61883_incorrect_qi1,         { "iec61883.incorrect_qi1", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect quadlet indicator 1 field, talker shall set this field to 0x00", EXPFILL }},
        { &ei_1722_61883_incorrect_qpc,         { "iec61883.incorrect_qpc", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect quadlet padding count field, shall be set to 0", EXPFILL }},
        { &ei_1722_61883_incorrect_qi2,         { "iec61883.incorrect_qi2", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect quadlet indicator 2 field, talker shall set this field to 0x02", EXPFILL }},
        { &ei_1722_61883_unknown_format,        { "iec61883.unknown_format", PI_PROTOCOL, PI_NOTE,
                                                  "IEC 61883 format not dissected yet", EXPFILL }},
        { &ei_1722_61883_incorrect_channel_sid, { "iec61883.incorrect_channel_sid", PI_PROTOCOL, PI_WARN,
                                                  "1394 Packet Channel and Source ID don`t match", EXPFILL }},
        { &ei_1722_61883_incorrect_datalen,     { "iec61883.incorrect_datalen", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect stream data length field, must be multiple of 192 plus 8 bytes CIP header", EXPFILL }},
        { &ei_1722_61883_4_incorrect_cip_fn,    { "iec61883.4_incorrect_cip_fn", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect fraction number, shall be 8 for IEC 61883-4", EXPFILL }},
        { &ei_1722_61883_4_incorrect_cip_dbs,   { "iec61883.4_incorrect_cip_dbs", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect data block size, shall be 6 for IEC 61883-4", EXPFILL }},
        { &ei_1722_61883_4_incorrect_cip_sph,   { "iec61883.4_incorrect_cip_sph", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect source packet header value, shall be 1 for IEC 61883-4", EXPFILL }},
        { &ei_1722_61883_6_incorrect_cip_fn,    { "iec61883.6_incorrect_cip_fn", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect fraction number, shall be 0 for IEC 61883-6", EXPFILL }},
        { &ei_1722_61883_6_incorrect_cip_sph,   { "iec61883.6_incorrect_cip_sph", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect source packet header value, shall be 0 for IEC 61883-6", EXPFILL }},
        { &ei_1722_61883_incorrect_cip_fdf,     { "iec61883.6_incorrect_cip_fdf", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect frame dependent field value, shall be 0", EXPFILL }}
    };

    expert_module_t* expert_1722_61883;

    /* Register the protocol name and description */
    proto_1722_61883 = proto_register_protocol(
                "IEC 61883 Protocol",   /* name */
                "IEC 61883",            /* short name */
                "iec61883");            /* abbrev */

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_61883, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    expert_1722_61883 = expert_register_protocol(proto_1722_61883);
    expert_register_field_array(expert_1722_61883, ei, array_length(ei));
}

void proto_reg_handoff_1722_61883(void)
{
    dissector_handle_t avb1722_61883_handle;

    avb1722_61883_handle = create_dissector_handle(dissect_1722_61883, proto_1722_61883);
    dissector_add_uint("ieee1722.subtype", IEEE_1722_SUBTYPE_61883, avb1722_61883_handle);
}

/**************************************************************************************************/
/* 1722 AAF dissector implementation                                                              */
/*                                                                                                */
/**************************************************************************************************/
static int dissect_1722_aaf (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    proto_item *ti;
    proto_tree *ti_aaf_tree;
    proto_tree *ti_channels_per_frame;
    proto_tree *ti_format;
    proto_tree *ti_audio_tree;
    proto_tree *ti_sample_tree;
    gint        offset = 1;
    guint       datalen = 0;
    guint       channels_per_frame = 0;
    guint       bit_depth = 0;
    guint       sample_width = 0;
    guint       format = 0;
    guint       i = 0;
    guint       j = 0;
    const gint *fields[] = {
        &hf_1722_aaf_mrfield,
        &hf_1722_aaf_tvfield,
        NULL
    };
    const gint *fields_pcm[] = {
        &hf_1722_aaf_sparse_timestamp,
        &hf_1722_aaf_evtfield,
        NULL
    };

    ti = proto_tree_add_item(tree, proto_1722_aaf, tvb, 0, -1, ENC_NA);
    ti_aaf_tree = proto_item_add_subtree(ti, ett_1722_aaf);

    proto_tree_add_bitmask_list(ti_aaf_tree, tvb, offset, 1, fields, ENC_NA);
    offset += 1;
    proto_tree_add_item(ti_aaf_tree, hf_1722_aaf_seqnum, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(ti_aaf_tree, hf_1722_aaf_tufield, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(ti_aaf_tree, hf_1722_aaf_stream_id, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;
    proto_tree_add_item(ti_aaf_tree, hf_1722_aaf_avtp_timestamp, tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    ti_format = proto_tree_add_item_ret_uint(ti_aaf_tree, hf_1722_aaf_format, tvb, offset, 1, ENC_BIG_ENDIAN, &format);
    offset += 1;
    switch (format)
    {
    case IEEE_1722_AAF_FORMAT_USER:
        break;
    case IEEE_1722_AAF_FORMAT_FLOAT_32_BIT:
        sample_width = 32;
        break;
    case IEEE_1722_AAF_FORMAT_INT_32_BIT:
        sample_width = 32;
        break;
    case IEEE_1722_AAF_FORMAT_INT_24_BIT:
        sample_width = 24;
        break;
    case IEEE_1722_AAF_FORMAT_INT_16_BIT:
        sample_width = 16;
        break;
    case IEEE_1722_AAF_FORMAT_AES3_32_BIT:
        sample_width = 32;
        break;
    default:
        break;
    }

    if (format < IEEE_1722_AAF_FORMAT_AES3_32_BIT)
    {
        proto_tree_add_item(ti_aaf_tree, hf_1722_aaf_nominal_sample_rate, tvb, offset, 2, ENC_BIG_ENDIAN);
        ti_channels_per_frame = proto_tree_add_item_ret_uint(ti_aaf_tree, hf_1722_aaf_channels_per_frame, tvb, offset, 2, ENC_BIG_ENDIAN, &channels_per_frame);
        if (channels_per_frame == 0)
        {
            expert_add_info(pinfo, ti_channels_per_frame, &ei_aaf_channels_per_frame);
        }
        else
        {
            offset += 2;
            ti = proto_tree_add_item_ret_uint(ti_aaf_tree, hf_1722_aaf_bit_depth, tvb, offset, 1, ENC_BIG_ENDIAN, &bit_depth);
            if ((bit_depth == 0) || (bit_depth > sample_width))
            {
                expert_add_info(pinfo, ti, &ei_aaf_incorrect_bit_depth);
            }
            offset += 1;
            proto_tree_add_item_ret_uint(ti_aaf_tree, hf_1722_aaf_stream_data_length, tvb, offset, 2, ENC_BIG_ENDIAN, &datalen);
            offset += 2;

            proto_tree_add_bitmask_list(ti_aaf_tree, tvb, offset, 1, fields_pcm, ENC_BIG_ENDIAN);
            offset += 2;

            /* Make the Audio sample tree. */
            ti            = proto_tree_add_item(ti_aaf_tree, hf_1722_aaf_data, tvb, offset, datalen, ENC_NA);
            ti_audio_tree = proto_item_add_subtree(ti, ett_1722_aaf_audio);

            if (sample_width == 0)
            {
                expert_add_info(pinfo, ti, &ei_aaf_sample_width);
            }
            else
            {
                /* Loop through all samples and add them to the audio tree. */
                for (j = 0; j < ((datalen * 8) / (channels_per_frame * sample_width)); j++)
                {
                    ti_sample_tree = proto_tree_add_subtree_format(ti_audio_tree, tvb, offset, 1,
                                         ett_1722_aaf_sample, NULL, "Sample Chunk %d", j);
                    for (i = 0; i < channels_per_frame; i++)
                    {
                        ti = proto_tree_add_item(ti_sample_tree, hf_1722_aaf_sample, tvb, offset, sample_width / 8, ENC_NA);
                        proto_item_prepend_text(ti, "Channel: %d ", i);
                        offset += (sample_width / 8);
                    }
                }
            }
        }
    }
    else if (format == IEEE_1722_AAF_FORMAT_AES3_32_BIT)
    {
        expert_add_info(pinfo, ti_format, &ei_aaf_aes3_format);
    }
    else
    {
        expert_add_info(pinfo, ti_format, &ei_aaf_reserved_format);
    }
    return tvb_captured_length(tvb);
}

void proto_register_1722_aaf (void)
{
    static hf_register_info hf[] =
    {
        { &hf_1722_aaf_mrfield,
            { "Media Clock Restart", "aaf.mrfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_MR_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_tvfield,
            { "Source Timestamp Valid", "aaf.tvfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TV_MASK, NULL, HFILL }
            },
        { &hf_1722_aaf_seqnum,
            { "Sequence Number", "aaf.seqnum",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_SEQ_NUM_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_tufield,
            { "Timestamp Uncertain", "aaf.tufield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TU_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_stream_id,
            { "Stream ID", "aaf.stream_id",
              FT_UINT64, BASE_HEX, NULL, IEEE_1722_STREAM_ID_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_avtp_timestamp,
            { "AVTP Timestamp", "aaf.avtp_timestamp",
              FT_UINT32, BASE_DEC, NULL, IEEE_1722_TIMESTAMP_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_format,
            { "Format", "aaf.format_info",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(aaf_format_range_rvals), IEEE_1722_FORMAT_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_nominal_sample_rate,
            { "Nominal Sample Rate", "aaf.nominal_sample_rate",
              FT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(aaf_nominal_sample_rate_range_rvals), IEEE_1722_NOM_SAMPLE_RATE_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_channels_per_frame,
            { "Channels per Frame", "aaf.channels_per_frame",
              FT_UINT16, BASE_DEC, NULL, IEEE_1722_CHANNEL_PER_FRAME_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_bit_depth,
            { "Bit Depth", "aaf.bit_depth",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_BIT_DEPTH_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_stream_data_length,
            { "Stream Data Length", "aaf.stream_data_len",
              FT_UINT16, BASE_DEC|BASE_UNIT_STRING, &units_byte_bytes, IEEE_1722_STREAM_DATA_LENGTH_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_sparse_timestamp,
            { "Sparse Timestamp Mode", "aaf.sparse_timestamp",
              FT_UINT8, BASE_DEC, VALS(aaf_sparse_timestamp_vals), IEEE_1722_SP_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_evtfield,
            { "EVT", "aaf.evtfield",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_EVT_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_data,
            { "Audio Data", "aaf.data",
              FT_BYTES, BASE_NONE, NULL, IEEE_1722_DATA_MASK, NULL, HFILL }
        },
        { &hf_1722_aaf_sample,
            { "Sample Data", "aaf.data.sample",
              FT_BYTES, BASE_NONE, NULL, IEEE_1722_SAMPLE_MASK, NULL, HFILL }
        }
    };

    static ei_register_info ei[] = {
        { &ei_aaf_sample_width,          { "aaf.expert.sample_width_zero", PI_PROTOCOL, PI_WARN, "Sample_width of 0 can`t be dissected", EXPFILL }},
        { &ei_aaf_reserved_format,       { "aaf.expert.reserved_format", PI_PROTOCOL, PI_WARN, "Incorrect format, can`t be dissected", EXPFILL }},
        { &ei_aaf_aes3_format,           { "aaf.expert.aes3_format", PI_PROTOCOL, PI_WARN, "AES3 format is currently not supported", EXPFILL }},
        { &ei_aaf_channels_per_frame,    { "aaf.expert.channels_per_frame_zero", PI_PROTOCOL, PI_WARN, "Channels_per_frame value shall not be 0", EXPFILL }},
        { &ei_aaf_incorrect_bit_depth,   { "aaf.expert.incorrect_bit_depth", PI_PROTOCOL, PI_WARN, "Incorrect bit_depth value", EXPFILL }}
    };

    static gint *ett[] =
    {
        &ett_1722_aaf,
        &ett_1722_aaf_audio,
        &ett_1722_aaf_sample,
    };

    expert_module_t *expert_1722_aaf;

    /* Register the protocol name and description */
    proto_1722_aaf = proto_register_protocol("AVTP Audio Format", "AAF", "aaf");

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_aaf, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    expert_1722_aaf = expert_register_protocol(proto_1722_aaf);
    expert_register_field_array(expert_1722_aaf, ei, array_length(ei));
}

void proto_reg_handoff_1722_aaf(void)
{
    dissector_handle_t avb1722_aaf_handle;

    avb1722_aaf_handle = create_dissector_handle(dissect_1722_aaf, proto_1722_aaf);
    dissector_add_uint("ieee1722.subtype", IEEE_1722_SUBTYPE_AAF, avb1722_aaf_handle);
}

/**************************************************************************************************/
/* 1722 CVF dissector implementation                                                              */
/*                                                                                                */
/**************************************************************************************************/
static int dissect_1722_cvf (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    proto_item *ti;
    proto_tree *ti_cvf_tree;
    gint        offset = 1;
    guint       format_subtype = 0;
    proto_tree *ti_format;

    const gint *fields[] = {
        &hf_1722_cvf_mrfield,
        &hf_1722_cvf_tvfield,
        NULL
    };
    const gint *fields_cvf[] = {
        &hf_1722_cvf_marker_bit,
        &hf_1722_cvf_evtfield,
        NULL
    };

    const gint *fields_h264[] = {
        &hf_1722_cvf_h264_forbidden_bit,
        &hf_1722_cvf_h264_nri,
        &hf_1722_cvf_h264_nal_type,
        NULL
    };

    ti = proto_tree_add_item(tree, proto_1722_cvf, tvb, 0, -1, ENC_NA);
    ti_cvf_tree = proto_item_add_subtree(ti, ett_1722_cvf);

    proto_tree_add_bitmask_list(ti_cvf_tree, tvb, offset, 1, fields, ENC_NA);
    offset += 1;
    proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_seqnum, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_tufield, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_stream_id, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;
    proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_avtp_timestamp, tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_format, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    ti_format = proto_tree_add_item_ret_uint(ti_cvf_tree, hf_1722_cvf_format_subtype, tvb, offset, 1, ENC_BIG_ENDIAN, &format_subtype);
    offset += 3;
    proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_stream_data_length, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;
    proto_tree_add_bitmask_list(ti_cvf_tree, tvb, offset, 1, fields_cvf, ENC_BIG_ENDIAN);
    offset += 2;

    switch(format_subtype) {
    case IEEE_1722_CVF_FORMAT_SUBTYPE_MJPEG:
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_mjpeg_ts, tvb, offset, 1, ENC_BIG_ENDIAN);
        offset += 1;
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_mjpeg_fragment_offset, tvb, offset, 3, ENC_BIG_ENDIAN);
        offset += 3;
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_mjpeg_type, tvb, offset, 1, ENC_BIG_ENDIAN);
        offset += 1;
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_mjpeg_q, tvb, offset, 1, ENC_BIG_ENDIAN);
        offset += 1;
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_mjpeg_width, tvb, offset, 1, ENC_BIG_ENDIAN);
        offset += 1;
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_mjpeg_height, tvb, offset, 1, ENC_BIG_ENDIAN);
        break;

    case IEEE_1722_CVF_FORMAT_SUBTYPE_H264:
        proto_tree_add_item(ti_cvf_tree, hf_1722_cvf_h264_timestamp, tvb, offset, 4, ENC_BIG_ENDIAN);
        offset += 4;
        proto_tree_add_bitmask_list(ti_cvf_tree, tvb, offset, 1, fields_h264, ENC_BIG_ENDIAN);
        break;

    case IEEE_1722_CVF_FORMAT_SUBTYPE_JPEG2000:
        expert_add_info(pinfo, ti_format, &ei_cvf_jpeg2000_format);
        break;

    default:
        expert_add_info(pinfo, ti_format, &ei_cvf_reserved_format);
        break;
    }
    return tvb_captured_length(tvb);
}

void proto_register_1722_cvf (void)
{
    static hf_register_info hf[] =
    {
        { &hf_1722_cvf_mrfield,
            { "Media Clock Restart", "cvf.mrfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_MR_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_tvfield,
            { "Source Timestamp Valid", "cvf.tvfield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TV_MASK, NULL, HFILL }
            },
        { &hf_1722_cvf_seqnum,
            { "Sequence Number", "cvf.seqnum",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_SEQ_NUM_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_tufield,
            { "Timestamp Uncertain", "cvf.tufield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TU_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_stream_id,
            { "Stream ID", "cvf.stream_id",
              FT_UINT64, BASE_HEX, NULL, IEEE_1722_STREAM_ID_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_avtp_timestamp,
            { "AVTP Timestamp", "cvf.avtp_timestamp",
              FT_UINT32, BASE_DEC, NULL, IEEE_1722_TIMESTAMP_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_format,
            { "Format", "cvf.format",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(cvf_format_range_rvals), IEEE_1722_FORMAT_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_format_subtype,
            { "CVF Format Subtype", "cvf.format_subtype",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(cvf_format_subtype_range_rvals), IEEE_1722_FORMAT_SUBTYPE_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_stream_data_length,
            { "Stream Data Length", "cvf.stream_data_len",
              FT_UINT16, BASE_DEC | BASE_UNIT_STRING, &units_byte_bytes, IEEE_1722_STREAM_DATA_LENGTH_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_marker_bit,
            { "Marker Bit", "cvf.marker_bit",
              FT_BOOLEAN, 8, TFS(&tfs_marker_bit_set_not_set), IEEE_1722_MARKER_BIT_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_evtfield,
            { "EVT", "cvf.evtfield",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_EVT_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_h264_timestamp,
            { "H264 Timestamp", "cvf.h264_timestamp",
              FT_UINT32, BASE_DEC, NULL, IEEE_1722_CVF_H264_TIMESTAMP_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_h264_forbidden_bit,
            { "H264 Forbidden Bit", "cvf.h264_f_bit",
              FT_BOOLEAN, 8, NULL, IEEE_1722_CVF_H264_FORBIDDEN_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_h264_nri,
            { "H264 NRI", "cvf.h264_nri",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_CVF_H264_NRI_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_h264_nal_type,
            { "H264 NAL Type", "cvf.h264_nal_type",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(cvf_h264_nal_type_range_rvals), IEEE_1722_CVF_H264_NAL_TYPE_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_mjpeg_ts,
            { "MJPEG Type Specific", "cvf.mjpeg_type_specific",
              FT_UINT8, BASE_DEC | BASE_RANGE_STRING, RVALS(cvf_mjpeg_ts_range_rvals), IEEE_1722_CVF_MJPEG_TS_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_mjpeg_fragment_offset,
            { "MJPEG Fragment Offset", "cvf.mjpeg_fragment_offset",
              FT_UINT24, BASE_DEC, NULL, IEEE_1722_CVF_MJPEG_FRAGMENT_OFFSET_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_mjpeg_type,
            { "MJPEG Type", "cvf.mjpeg_type",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_CVF_MJPEG_TYPE_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_mjpeg_q,
            { "MJPEG Q", "cvf.mjpeg_q",
               FT_UINT8, BASE_DEC, NULL, IEEE_1722_CVF_MJPEG_Q_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_mjpeg_width,
            { "MJPEG Width", "cvf.mjpeg_width",
               FT_UINT8, BASE_DEC, NULL, IEEE_1722_CVF_MJPEG_WIDTH_MASK, NULL, HFILL }
        },
        { &hf_1722_cvf_mjpeg_height,
            { "MJPEG Height", "cvf.mjpeg_height",
               FT_UINT8, BASE_DEC, NULL, IEEE_1722_CVF_MJPEG_HEIGHT_MASK, NULL, HFILL }
        },

    };

    static ei_register_info ei[] = {
        { &ei_cvf_jpeg2000_format,          { "cvf.expert.jpeg2000_video", PI_PROTOCOL, PI_WARN, "JPEG2000 format is currently not supported", EXPFILL }},
        { &ei_cvf_reserved_format,          { "cvf.expert.reserved_format", PI_PROTOCOL, PI_WARN, "Incorrect format, can`t be dissected", EXPFILL }}
    };

    static gint *ett[] =
    {
        &ett_1722_cvf,
    };

    expert_module_t *expert_1722_cvf;

    /* Register the protocol name and description */
    proto_1722_cvf = proto_register_protocol("AVTP Compressed Video Format", "CVF", "cvf");

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_cvf, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    expert_1722_cvf = expert_register_protocol(proto_1722_cvf);
    expert_register_field_array(expert_1722_cvf, ei, array_length(ei));

}

void proto_reg_handoff_1722_cvf(void)
{
    dissector_handle_t avb1722_cvf_handle;

    avb1722_cvf_handle = create_dissector_handle(dissect_1722_cvf, proto_1722_cvf);
    dissector_add_uint("ieee1722.subtype", IEEE_1722_SUBTYPE_CVF, avb1722_cvf_handle);
}

/**************************************************************************************************/
/* 1722 CRF dissector implementation                                                              */
/*                                                                                                */
/**************************************************************************************************/
static int dissect_1722_crf (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    proto_item *ti;
    proto_tree *ti_crf_tree;
    proto_tree *timestamp_tree;
    gint        offset = 1;
    guint       datalen = 0;
    guint       j = 0;
    const gint *fields[] = {
        &hf_1722_crf_mrfield,
        &hf_1722_crf_fsfield,
        &hf_1722_crf_tufield,
        NULL
    };
    const gint *pull_frequency[] = {
        &hf_1722_crf_pull,
        &hf_1722_crf_base_frequency,
        NULL
    };

    ti = proto_tree_add_item(tree, proto_1722_crf, tvb, 0, -1, ENC_NA);
    ti_crf_tree = proto_item_add_subtree(ti, ett_1722_crf);

    proto_tree_add_bitmask_list(ti_crf_tree, tvb, offset, 1, fields, ENC_NA);
    offset += 1;
    proto_tree_add_item(ti_crf_tree, hf_1722_crf_seqnum, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(ti_crf_tree, hf_1722_crf_type, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(ti_crf_tree, hf_1722_crf_stream_id, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;
    proto_tree_add_bitmask_list(ti_crf_tree, tvb, offset, 4, pull_frequency, ENC_NA);
    offset += 4;
    proto_tree_add_item_ret_uint(ti_crf_tree, hf_1722_crf_data_length, tvb, offset, 2, ENC_BIG_ENDIAN, &datalen);
    offset += 2;
    proto_tree_add_item(ti_crf_tree, hf_1722_crf_timestamp_interval, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;

    /* Make the Timestamp tree. */
    ti = proto_tree_add_item(ti_crf_tree, hf_1722_crf_timestamp_data, tvb, offset, datalen, ENC_NA);
    timestamp_tree = proto_item_add_subtree(ti, ett_1722_crf_timestamp);

    if (datalen%8)
    {
        expert_add_info(pinfo, ti, &ei_crf_datalen);
    }
    else
    {
        /* Loop through all timestamps and add them to the timestamp tree. */
        for (j = 0; j < (datalen / IEEE_1722_CRF_TIMESTAMP_SIZE); j++)
        {
            ti = proto_tree_add_item(timestamp_tree, hf_1722_crf_timestamp, tvb, offset, IEEE_1722_CRF_TIMESTAMP_SIZE, ENC_BIG_ENDIAN);
            proto_item_prepend_text(ti, "Timestamp %d ", j);
            offset += IEEE_1722_CRF_TIMESTAMP_SIZE;
        }
    }

    return tvb_captured_length(tvb);
}

void proto_register_1722_crf(void)
{
    static hf_register_info hf[] =
    {
        { &hf_1722_crf_mrfield,
          { "Media Clock Restart", "crf.mrfield",
            FT_BOOLEAN, 8, NULL, IEEE_1722_MR_MASK, NULL, HFILL }
        },
        { &hf_1722_crf_fsfield,
          { "Frame Sync", "crf.fsfield",
            FT_BOOLEAN, 8, NULL, IEEE_1722_FS_MASK, NULL, HFILL }
        },
        { &hf_1722_crf_tufield,
            { "Timestamp Uncertain", "crf.tufield",
              FT_BOOLEAN, 8, NULL, IEEE_1722_TU_MASK, NULL, HFILL }
        },
        { &hf_1722_crf_seqnum,
            { "Sequence Number", "crf.seqnum",
              FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_crf_type,
            { "Type", "crf.type",
              FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(crf_type_range_rvals), 0x00, NULL, HFILL }
        },
        { &hf_1722_crf_stream_id,
            { "Stream ID", "crf.stream_id",
              FT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_crf_pull,
            { "Pull", "crf.pull",
              FT_UINT32, BASE_HEX | BASE_RANGE_STRING, RVALS(crf_pull_range_rvals), IEEE_1722_PULL_MASK, NULL, HFILL }
        },
        { &hf_1722_crf_base_frequency,
            { "Base Frequency", "crf.base_frequency",
              FT_UINT32, BASE_DEC, NULL, IEEE_1722_BASE_FREQUENCY_MASK, NULL, HFILL }
        },
        { &hf_1722_crf_data_length,
            { "Data Length", "crf.data_len",
              FT_UINT16, BASE_DEC|BASE_UNIT_STRING, &units_byte_bytes, 0x00, NULL, HFILL }
        },
        { &hf_1722_crf_timestamp_interval,
            { "Timestamp Interval", "crf.timestamp_interval",
              FT_UINT16, BASE_DEC, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_crf_timestamp_data,
            { "Timestamp Data", "crf.timestamp_data",
              FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_crf_timestamp,
            { "Data", "crf.timestamp",
              FT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }
        }
    };

    static ei_register_info ei[] = {
        { &ei_crf_datalen,              { "crf.expert.crf_datalen", PI_PROTOCOL, PI_WARN, "The CRF data length must be multiple of 8", EXPFILL }}
    };

    static gint *ett[] =
    {
        &ett_1722_crf,
        &ett_1722_crf_timestamp
    };

    expert_module_t *expert_1722_crf;

    /* Register the protocol name and description */
    proto_1722_crf = proto_register_protocol("Clock Reference Format", "CRF", "crf");

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_crf, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    expert_1722_crf = expert_register_protocol(proto_1722_crf);
    expert_register_field_array(expert_1722_crf, ei, array_length(ei));
}

void proto_reg_handoff_1722_crf(void)
{
    dissector_handle_t avb1722_crf_handle;

    avb1722_crf_handle = create_dissector_handle(dissect_1722_crf, proto_1722_crf);
    dissector_add_uint("ieee1722.subtype", IEEE_1722_SUBTYPE_CRF, avb1722_crf_handle);
}

/**************************************************************************************************/
/* 1722 NTSCF dissector implementation                                                            */
/*                                                                                                */
/**************************************************************************************************/
static int dissect_1722_ntscf (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    proto_item *ti_ntscf;
    proto_item *ti_data_length;
    proto_tree *tree_ntscf;
    gint        offset = 1;
    guint32     datalen = 0;
    guint       captured_length = tvb_captured_length(tvb);
    gint        captured_payload_length;

    const gint *fields[] = {
        &hf_1722_ntscf_rfield,
        NULL,
    };

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "NTSCF");
    col_set_str(pinfo->cinfo, COL_INFO, "AVTP Non-Time-Syncronous Control Format");

    ti_ntscf = proto_tree_add_item(tree, proto_1722_ntscf, tvb, 0, -1, ENC_NA);
    tree_ntscf = proto_item_add_subtree(ti_ntscf, ett_1722_ntscf);

    if (captured_length < IEEE_1722_NTSCF_HEADER_SIZE) {
        expert_add_info(pinfo, ti_ntscf, &ei_1722_ntscf_no_space_for_header);
        return captured_length;
    }

    proto_tree_add_bitmask_list(tree_ntscf, tvb, offset, 2, fields, ENC_BIG_ENDIAN);
    ti_data_length = proto_tree_add_item_ret_uint(tree_ntscf, hf_1722_ntscf_data_length, tvb, offset, 2, ENC_BIG_ENDIAN, &datalen);
    offset += 2;
    proto_tree_add_item(tree_ntscf, hf_1722_ntscf_seqnum, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree_ntscf, hf_1722_ntscf_stream_id, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;

    captured_payload_length = tvb_captured_length_remaining(tvb, offset);
    if (captured_payload_length < 0 || (gint)datalen > captured_payload_length) {
        expert_add_info(pinfo, ti_data_length, &ei_1722_ntscf_invalid_data_length);
    }

    if ((gint)datalen > captured_payload_length) {
        datalen = captured_payload_length > 0
                ? captured_payload_length
                : 0;
    }

    while(datalen > 0) {
        guint       processed_bytes;
        tvbuff_t*   next_tvb;

        next_tvb = tvb_new_subset_length(tvb, offset, datalen);
        if (call_dissector(avb1722_acf_handle, next_tvb, pinfo, tree) <= 0) {
            break;
        }

        processed_bytes = tvb_reported_length(next_tvb);

        offset += processed_bytes;
        if (processed_bytes < datalen) {
            datalen -= processed_bytes;
        } else {
            datalen = 0;
        }
    }

    set_actual_length(tvb, offset);
    proto_item_set_len(ti_ntscf, offset);

    return tvb_captured_length(tvb);
}

void proto_register_1722_ntscf(void)
{
    static hf_register_info hf[] =
    {
        { &hf_1722_ntscf_rfield,
            { "Reserved bits", "ntscf.rfield",
              FT_UINT16, BASE_HEX, NULL, IEEE_1722_NTSCF_R_MASK, NULL, HFILL }
        },
        { &hf_1722_ntscf_data_length,
            { "Data Length", "ntscf.data_len",
              FT_UINT16, BASE_DEC, NULL, IEEE_1722_NTSCF_DATA_LENGTH_MASK, NULL, HFILL }
        },
        { &hf_1722_ntscf_seqnum,
            { "Sequence Number", "ntscf.seqnum",
              FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }
        },
        { &hf_1722_ntscf_stream_id,
            { "Stream ID", "ntscf.stream_id",
              FT_UINT64, BASE_HEX, NULL, 0x00, NULL, HFILL }
        }
    };

    static gint *ett[] =
    {
        &ett_1722_ntscf
    };

    static ei_register_info ei[] = {
        { &ei_1722_ntscf_no_space_for_header, { "ntscf.expert.no_space_for_header", PI_PROTOCOL, PI_WARN, "Frame is cropped: NTSCF header won't fit into captured data.", EXPFILL}},
        { &ei_1722_ntscf_invalid_data_length, { "ntscf.expert.data_len", PI_PROTOCOL, PI_WARN, "data_length is too large or frame is incomplete", EXPFILL }}
    };

    expert_module_t *expert_1722_ntscf;

    /* Register the protocol name and description */
    proto_1722_ntscf = proto_register_protocol("Non-Time-Synchronous Control Format", "NTSCF", "ntscf");

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_ntscf, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    expert_1722_ntscf = expert_register_protocol(proto_1722_ntscf);
    expert_register_field_array(expert_1722_ntscf, ei, array_length(ei));
}

void proto_reg_handoff_1722_ntscf(void)
{
    dissector_handle_t avb1722_ntscf_handle;

    avb1722_ntscf_handle = create_dissector_handle(dissect_1722_ntscf, proto_1722_ntscf);
    dissector_add_uint("ieee1722.subtype", IEEE_1722_SUBTYPE_NTSCF, avb1722_ntscf_handle);
}


/**************************************************************************************************/
/* 1722 TSCF dissector implementation                                                            */
/*                                                                                                */
/**************************************************************************************************/
static int dissect_1722_tscf (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    proto_item *ti;
    proto_item *ti_tscf;
    proto_tree *tree_tscf;
    proto_tree *tree_flags;
    proto_tree *tree_tu;
    gint        offset = 1;
    guint32     mr;
    guint32     tv;
    guint32     tu;
    guint32     datalen = 0;
    guint       captured_length = tvb_captured_length(tvb);
    gint        captured_payload_length;

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "TSCF");
    col_set_str(pinfo->cinfo, COL_INFO, "AVTP Time-Syncronous Control Format");

    ti_tscf = proto_tree_add_item(tree, proto_1722_tscf, tvb, 0, -1, ENC_NA);
    tree_tscf = proto_item_add_subtree(ti_tscf, ett_1722_tscf);

    if (captured_length < IEEE_1722_TSCF_HEADER_SIZE) {
        expert_add_info(pinfo, ti_tscf, &ei_1722_tscf_no_space_for_header);
        return captured_length;
    }

    tree_flags = proto_tree_add_subtree(tree_tscf, tvb, offset, 1, ett_1722_tscf_flags, &ti, "Flags");
    proto_tree_add_item_ret_uint(tree_flags, hf_1722_tscf_mr, tvb, offset, 1, ENC_BIG_ENDIAN, &mr);
    proto_tree_add_item(tree_flags, hf_1722_tscf_rsv1, tvb, offset, 1, ENC_BIG_ENDIAN);
    proto_tree_add_item_ret_uint(tree_flags, hf_1722_tscf_tv, tvb, offset, 1, ENC_BIG_ENDIAN, &tv);
    proto_item_append_text(ti, ": mr=%d, tv=%d", mr, tv);
    offset += 1;

    proto_tree_add_item(tree_tscf, hf_1722_tscf_seqnum, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;

    tree_tu = proto_tree_add_subtree(tree_tscf, tvb, offset, 1, ett_1722_tscf_tu, &ti, "Timestamp Uncertain");
    proto_tree_add_item(tree_tu, hf_1722_tscf_rsv2, tvb, offset, 1, ENC_BIG_ENDIAN);
    proto_tree_add_item_ret_uint(tree_tu, hf_1722_tscf_tu, tvb, offset, 1, ENC_BIG_ENDIAN, &tu);
    proto_item_append_text(ti, ": %d", tu);
    offset += 1;

    proto_tree_add_item(tree_tscf, hf_1722_tscf_stream_id, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;

    proto_tree_add_item(tree_tscf, hf_1722_tscf_avtp_timestamp, tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    proto_tree_add_item(tree_tscf, hf_1722_tscf_rsv3, tvb, offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    ti = proto_tree_add_item_ret_uint(tree_tscf, hf_1722_tscf_data_length, tvb, offset, 2, ENC_BIG_ENDIAN, &datalen);
    captured_payload_length = tvb_captured_length_remaining(tvb, offset);
    if (captured_payload_length < 0 || (gint)datalen > captured_payload_length) {
        expert_add_info(pinfo, ti, &ei_1722_tscf_invalid_data_length);
    }
    offset += 2;

    proto_tree_add_item(tree_tscf, hf_1722_tscf_rsv4, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;

    if ((gint)datalen > captured_payload_length) {
        datalen = captured_payload_length > 0
                ? captured_payload_length
                : 0;
    }

    while(datalen > 0) {
        guint       processed_bytes;
        tvbuff_t*   next_tvb = tvb_new_subset_length(tvb, offset, datalen);
        if (call_dissector(avb1722_acf_handle, next_tvb, pinfo, tree) <= 0) {
            break;
        }
        processed_bytes = tvb_reported_length(next_tvb);

        offset += processed_bytes;
        if (processed_bytes < datalen) {
            datalen -= processed_bytes;
        } else {
            datalen = 0;
        }
    }

    set_actual_length(tvb, offset);
    proto_item_set_len(ti_tscf, offset);

    return captured_length;
}

void proto_register_1722_tscf(void)
{
    static hf_register_info hf[] =
    {
        { &hf_1722_tscf_mr,
            { "Media Clock Restart", "tscf.flags.mr",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_TSCF_MR_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_rsv1,
            { "Reserved bits", "tscf.flags.rsv1",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_TSCF_RSV1_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_tv,
            { "Avtp Timestamp Valid", "tscf.flags.tv",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_TSCF_TV_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_seqnum,
            { "Sequence Number", "tscf.seqnum",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_TSCF_SEQNUM_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_rsv2,
            { "Reserved Bits", "tscf.rsv2",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_TSCF_RSV2_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_tu,
            { "Timestamp Uncertain", "tscf.flags.tu",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_TSCF_TU_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_stream_id,
            { "Stream ID", "tscf.stream_id",
              FT_UINT64, BASE_HEX, NULL, IEEE_1722_TSCF_STREAM_ID_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_avtp_timestamp,
            { "AVTP Timestamp", "tscf.avtp_timestamp",
              FT_UINT32, BASE_HEX, NULL, IEEE_1722_TSCF_AVTP_TIMESTAMP_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_rsv3,
            { "Reserved Bits", "tscf.rsv3",
              FT_UINT32, BASE_HEX, NULL, IEEE_1722_TSCF_RSV3_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_data_length,
            { "Data Length", "tscf.data_len",
              FT_UINT16, BASE_DEC, NULL, IEEE_1722_TSCF_DATA_LENGTH_MASK, NULL, HFILL }
        },

        { &hf_1722_tscf_rsv4,
            { "Reserved Bits", "tscf.rsv4",
              FT_UINT16, BASE_HEX, NULL, IEEE_1722_TSCF_RSV4_MASK, NULL, HFILL }
        },
    };

    static gint *ett[] =
    {
        &ett_1722_tscf,
        &ett_1722_tscf_flags,
        &ett_1722_tscf_tu,
    };

    static ei_register_info ei[] = {
        { &ei_1722_tscf_no_space_for_header, { "tscf.expert.no_space_for_header", PI_PROTOCOL, PI_WARN, "Frame is cropped: TSCF header won't fit into captured data.", EXPFILL}},
        { &ei_1722_tscf_invalid_data_length, { "tscf.expert.data_len", PI_PROTOCOL, PI_WARN, "data_length is too large or frame is incomplete", EXPFILL }}
    };

    expert_module_t *expert_1722_tscf;

    /* Register the protocol name and description */
    proto_1722_tscf = proto_register_protocol("Time-Synchronous Control Format", "TSCF", "tscf");

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_tscf, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    expert_1722_tscf = expert_register_protocol(proto_1722_tscf);
    expert_register_field_array(expert_1722_tscf, ei, array_length(ei));
}

void proto_reg_handoff_1722_tscf(void)
{
    dissector_handle_t avb1722_tscf_handle;

    avb1722_tscf_handle = create_dissector_handle(dissect_1722_tscf, proto_1722_tscf);
    dissector_add_uint("ieee1722.subtype", IEEE_1722_SUBTYPE_TSCF, avb1722_tscf_handle);
}

/**************************************************************************************************/
/* AVTP Control Format (ACF) Message dissector implementation                                     */
/*                                                                                                */
/**************************************************************************************************/
static int dissect_1722_acf (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    proto_item     *ti;
    proto_item     *ti_acf;
    proto_item     *ti_header;
    proto_tree     *tree_acf;
    proto_tree     *tree_header;
    guint32         msg_type;
    guint32         msg_length;
    guint32         payload_length;
    guint           captured_length = tvb_captured_length(tvb);
    const gchar    *msg_type_str;
    tvbuff_t       *next_tvb;

    if (captured_length < IEEE_1722_ACF_HEADER_SIZE) {
        return captured_length;
    }

    ti_acf = proto_tree_add_item(tree, proto_1722_acf, tvb, 0, -1, ENC_NA);
    tree_acf = proto_item_add_subtree(ti_acf, ett_1722_acf);

    tree_header = proto_tree_add_subtree(tree_acf, tvb, 0, 2, ett_1722_acf_header, &ti_header, "ACF Header");
    proto_tree_add_item_ret_uint(tree_header, hf_1722_acf_msg_type, tvb, 0, 2, ENC_BIG_ENDIAN, &msg_type);
    ti = proto_tree_add_item_ret_uint(tree_header, hf_1722_acf_msg_length, tvb, 0, 2, ENC_BIG_ENDIAN, &msg_length);
    msg_length = msg_length * 4; /* msg_length is stored as number of quadlets */

    if (msg_length < IEEE_1722_ACF_HEADER_SIZE) {
        expert_add_info(pinfo, ti, &ei_1722_acf_invalid_msg_length);
        return captured_length;
    }

    if (captured_length < msg_length) {
        expert_add_info_format(pinfo, ti, &ei_1722_acf_message_is_cropped,
                               "expected: %u bytes, available: %u bytes",
                               msg_length, tvb_captured_length(tvb));
        return captured_length;
    }

    set_actual_length(tvb, msg_length);
    proto_item_set_len(ti_acf, msg_length);
    msg_type_str = rval_to_str(msg_type, acf_msg_type_range_rvals, "%s");
    proto_item_append_text(ti_header, ": %s (0x%02X), %d bytes with header",
                           msg_type_str, msg_type, msg_length);
    proto_item_append_text(ti_acf, ": %s (0x%02X)", msg_type_str, msg_type);
    payload_length = msg_length - IEEE_1722_ACF_HEADER_SIZE;

    /* call any registered message dissectors */
    next_tvb = tvb_new_subset_length(tvb, IEEE_1722_ACF_HEADER_SIZE, payload_length);

    if (!dissector_try_uint(avb1722_acf_dissector_table, msg_type, next_tvb, pinfo, tree_acf)) {
        call_data_dissector(next_tvb, pinfo, tree_acf);
    }

    return captured_length;
}

void proto_register_1722_acf(void)
{
    static hf_register_info hf[] = {
        { &hf_1722_acf_msg_type,
            { "Message Type", "acf.msg_type",
              FT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(acf_msg_type_range_rvals), IEEE_1722_ACF_MSG_TYPE_MASK, NULL, HFILL }
        },
        { &hf_1722_acf_msg_length,
            { "Message Length (Quadlets)", "acf.msg_length",
              FT_UINT16, BASE_DEC, NULL, IEEE_1722_ACF_MSG_LENGTH_MASK, NULL, HFILL }
        },
    };

    static gint *ett[] =
    {
        &ett_1722_acf,
        &ett_1722_acf_header,
    };


    static ei_register_info ei[] = {
        { &ei_1722_acf_invalid_msg_length, { "acf.expert.msg_length", PI_PROTOCOL, PI_WARN, "msg_length shall be at least 1 quadlet", EXPFILL }},
        { &ei_1722_acf_message_is_cropped, { "acf.expert.msg_cropped", PI_PROTOCOL, PI_WARN, "Message is cropped or msg_length is invalid", EXPFILL }},
    };

    expert_module_t *expert_1722_acf;

    /* Register the protocol name and description */
    proto_1722_acf = proto_register_protocol("ACF Message", "ACF", "acf");
    avb1722_acf_handle = register_dissector("acf", dissect_1722_acf, proto_1722_acf);

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_acf, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    /* Sub-dissector for ACF messages */
    avb1722_acf_dissector_table = register_dissector_table("acf.msg_type",
                          "IEEE1722 AVTP Control Message Type", proto_1722_acf,
                          FT_UINT8, BASE_HEX);

    expert_1722_acf = expert_register_protocol(proto_1722_acf);
    expert_register_field_array(expert_1722_acf, ei, array_length(ei));
}

void proto_reg_handoff_1722_acf(void)
{
    register_depend_dissector("ntscf", "acf");
    register_depend_dissector("tscf", "acf");
}

/**************************************************************************************************/
/* ACF CAN Message dissector implementation                                                       */
/*                                                                                                */
/**************************************************************************************************/
static void describe_can_message(proto_item* dst, guint bus_id, guint32 can_id, guint8 flags)
{
    /* Add text describing the CAN message to the parent item.
     * Example: ": bus_id=2, id=0x100, rtr=1, brs=1, esi=1" */
    const char* format_str = (flags & IEEE_1722_ACF_CAN_EFF_MASK) != 0
                           ? ": bus_id=%u, id=0x%08X"
                           : ": bus_id=%u, id=0x%03X";

    proto_item_append_text (dst, format_str, bus_id, can_id);
}

static void describe_can_flags(proto_item* dst, guint8 pad, guint8 flags)
{
    proto_item_append_text(dst, ": pad=%u, mtv=%d, rtr=%d, eff=%d, brs=%d, fdf=%d, esi=%d",
                           pad,
                           (flags & IEEE_1722_ACF_CAN_MTV_MASK) != 0,
                           (flags & IEEE_1722_ACF_CAN_RTR_MASK) != 0,
                           (flags & IEEE_1722_ACF_CAN_EFF_MASK) != 0,
                           (flags & IEEE_1722_ACF_CAN_BRS_MASK) != 0,
                           (flags & IEEE_1722_ACF_CAN_FDF_MASK) != 0,
                           (flags & IEEE_1722_ACF_CAN_ESI_MASK) != 0
    );
}

static int is_valid_can_payload_length(int len)
{
    return len >= 0 && len <= 8;
}

static int is_valid_canfd_payload_length(int len)
{
    return is_valid_can_payload_length(len) ||
           len == 12 ||
           len == 16 ||
           len == 20 ||
           len == 24 ||
           len == 32 ||
           len == 48 ||
           len == 64;
}

static int dissect_1722_acf_can_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_, const gboolean is_brief)
{
    acf_can_t           parsed;
    guint32             pad_length;
    gint                payload_length;
    guint8              flags;
    proto_item         *ti;

    proto_item         *ti_acf_can;
    proto_tree         *tree_acf_can;
    proto_tree         *tree_acf_can_flags;
    proto_tree         *tree_acf_can_bus_id;

    proto_item         *ti_can;
    proto_tree         *tree_can;
    proto_tree         *tree_can_id;
    gint                can_protocol;
    const int         **can_flags;
    struct can_info     can_info;

    tvbuff_t*           next_tvb;
    gint                offset = 0;
    guint               captured_length = tvb_captured_length(tvb);
    guint               header_size = is_brief
                                    ? IEEE_1722_ACF_CAN_BRIEF_HEADER_SIZE
                                    : IEEE_1722_ACF_CAN_HEADER_SIZE;


    const gint *fields[] = {
        &hf_1722_can_mtvfield,
        &hf_1722_can_fdffield,
        NULL,
    };

    const gint *can_std_flags[] = {
        &hf_1722_can_rtrfield,
        &hf_1722_can_efffield,
        NULL
    };

    const gint *can_fd_flags[] = {
        &hf_1722_can_efffield,
        &hf_1722_can_brsfield,
        &hf_1722_can_esifield,
        NULL
    };

    memset(&parsed, 0, sizeof(parsed));

    /* create tree for ACF-CAN-specific fields */
    ti_acf_can = proto_tree_add_item(tree, proto_1722_acf_can, tvb, offset, -1, ENC_NA);
    tree_acf_can = proto_item_add_subtree(ti_acf_can, ett_1722_can);
    if (is_brief) {
        proto_item_append_text(ti_acf_can, " Brief");
    }

    /* parse flags */
    flags = tvb_get_guint8(tvb, offset);
    parsed.is_fd   = (flags & IEEE_1722_ACF_CAN_FDF_MASK) != 0;
    parsed.is_xtd  = (flags & IEEE_1722_ACF_CAN_EFF_MASK) != 0;
    parsed.is_rtr  = (flags & IEEE_1722_ACF_CAN_RTR_MASK) != 0;
    parsed.is_brs  = (flags & IEEE_1722_ACF_CAN_BRS_MASK) != 0;
    parsed.is_esi  = (flags & IEEE_1722_ACF_CAN_ESI_MASK) != 0;

    /* create the tree for CAN-specific fields */
    can_protocol = parsed.is_fd ? proto_canfd : proto_can;
    can_flags    = parsed.is_fd ? can_fd_flags : can_std_flags;
    ti_can = proto_tree_add_item(tree, can_protocol, tvb, offset, -1, ENC_NA);
    tree_can = proto_item_add_subtree(ti_can, ett_can);

    if (captured_length < header_size) {
        expert_add_info(pinfo, ti_acf_can, &ei_1722_can_header_cropped);
        return captured_length;
    }

    /* Add flags subtree to ACF_CAN message */
    ti = proto_tree_add_item(tree_acf_can, hf_1722_can_flags, tvb, offset, 1, ENC_NA);
    tree_acf_can_flags = proto_item_add_subtree(ti, ett_1722_can_flags);

    proto_tree_add_item_ret_uint(tree_acf_can_flags, hf_1722_can_pad, tvb, offset, 1, ENC_BIG_ENDIAN, &pad_length);
    proto_tree_add_bitmask_list(tree_acf_can_flags, tvb, offset, 1, fields, ENC_BIG_ENDIAN);
    describe_can_flags(ti, pad_length, flags);

    /* Add flags to CAN message */
    proto_tree_add_bitmask_list(tree_can, tvb, offset, 1, can_flags, ENC_BIG_ENDIAN);
    offset += 1;

    /* Add bus id subtree to ACF_CAN message */
    tree_acf_can_bus_id = proto_tree_add_subtree(tree_acf_can, tvb, offset, 1, ett_1722_can_bus_id, &ti, "Bus Identifier");
    proto_tree_add_item(tree_acf_can_bus_id, hf_1722_can_rsv1, tvb, offset, 1, ENC_BIG_ENDIAN);
    proto_tree_add_item_ret_uint(tree_acf_can_bus_id, hf_1722_can_bus_id, tvb, offset, 1, ENC_BIG_ENDIAN, &parsed.bus_id);
    proto_item_append_text(ti, ": %u", parsed.bus_id);
    offset += 1;

    /* Add message_timestamp to ACF_CAN if present */
    if (!is_brief) {
        proto_tree_add_item(tree_acf_can, hf_1722_can_message_timestamp, tvb, offset, 8, ENC_BIG_ENDIAN);
        offset += 8;
    }

    /* Add message id subtree to CAN message */
    tree_can_id = proto_tree_add_subtree(tree_can, tvb, offset, 4, ett_1722_can_msg_id, &ti, "Message Identifier");
    proto_tree_add_item(tree_can_id, hf_1722_can_rsv2, tvb, offset, 4, ENC_BIG_ENDIAN);
    proto_item *ti_id = proto_tree_add_item_ret_uint(tree_can_id, hf_1722_can_identifier, tvb, offset, 4, ENC_BIG_ENDIAN, &parsed.id);
    proto_item_append_text(ti, parsed.is_xtd ? ": 0x%08X" : ": 0x%03X", parsed.id);
    if (!parsed.is_xtd && (parsed.id & ~IEEE_1722_ACF_CAN_11BIT_ID_MASK) != 0) {
        expert_add_info(pinfo, ti_id, &ei_1722_can_invalid_message_id);
    }
    offset += 4;

    /* Add text description to tree items and info column*/
    describe_can_message(ti_acf_can, parsed.bus_id, parsed.id, flags);
    describe_can_message(proto_tree_get_parent(tree), parsed.bus_id, parsed.id, flags);

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "ACF-CAN");
    col_clear(pinfo->cinfo, COL_INFO);
    col_add_fstr(pinfo->cinfo, COL_INFO, "ACF-CAN(%u): 0x%08x   ", parsed.bus_id, parsed.id);

    payload_length = tvb_reported_length_remaining(tvb, offset) - pad_length;
    if (payload_length < 0) {
        payload_length = 0;
    }
    parsed.datalen = (guint)payload_length;
    proto_tree_add_uint(tree_acf_can, hf_1722_can_len, tvb, offset, 1, parsed.datalen);

    col_append_str(pinfo->cinfo, COL_INFO, tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, offset, payload_length, ' '));

    if (parsed.is_fd && !is_valid_canfd_payload_length(payload_length))
    {
        expert_add_info(pinfo, ti_acf_can, &ei_1722_canfd_invalid_payload_length);
    }
    else if (!parsed.is_fd && !is_valid_can_payload_length(payload_length))
    {
        expert_add_info(pinfo, ti_acf_can, &ei_1722_can_invalid_payload_length);
    }

    /* Add payload to parent tree */

    /*
    * CAN sub-dissectors expect several flags to be merged into ID that is passed
    * to dissector_try_payload_new. Add them
    */
    can_info.id = parsed.id;
    if (parsed.is_xtd)
    {
        can_info.id |= CAN_EFF_FLAG;
    }

    if (parsed.is_rtr)
    {
        can_info.id |= CAN_RTR_FLAG;
    }

    next_tvb = tvb_new_subset_length(tvb, offset, parsed.datalen);

    if(!can_heuristic_first)
    {
        if (!dissector_try_payload_new(can_subdissector_table, next_tvb, pinfo, tree, TRUE, &can_info))
        {
            if(!dissector_try_heuristic(can_heur_subdissector_table, next_tvb, pinfo, tree, &can_heur_dtbl_entry, &can_info))
            {
                call_data_dissector(next_tvb, pinfo, tree);
            }
        }
    }
    else
    {
        if (!dissector_try_heuristic(can_heur_subdissector_table, next_tvb, pinfo, tree, &can_heur_dtbl_entry, &can_info))
        {
            if(!dissector_try_payload_new(can_subdissector_table, next_tvb, pinfo, tree, FALSE, &can_info))
            {
                call_data_dissector(next_tvb, pinfo, tree);
            }
        }
    }

    /* Add padding bytes to ACF-CAN tree if any */
    if (pad_length > 0 && tvb_reported_length_remaining(tvb, offset) >= (gint)pad_length)
    {
        proto_tree_add_item(tree_acf_can, hf_1722_can_padding, tvb, offset, pad_length, ENC_NA);
    }

    return captured_length;
}

static int dissect_1722_acf_can(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    return dissect_1722_acf_can_common(tvb, pinfo, tree, data, FALSE);
}

static int dissect_1722_acf_can_brief(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    return dissect_1722_acf_can_common(tvb, pinfo, tree, data, TRUE);
}

void proto_register_1722_acf_can(void)
{
    static hf_register_info hf[] = {
        /* ACF-CAN, ACF-CAN-BRIEF and CAN fields */
        { &hf_1722_can_flags,
            { "Flags", "acf-can.flags",
              FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL },
        },
        { &hf_1722_can_pad,
            { "Padding Length", "acf-can.flags.pad",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_ACF_CAN_PAD_MASK, NULL, HFILL }
        },
        { &hf_1722_can_len,
            { "Frame-Length", "can.len",
              FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }
        },
        { &hf_1722_can_mtvfield,
            { "Message Timestamp Valid", "acf-can.flags.mtv",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_CAN_MTV_MASK, NULL, HFILL }
        },
        { &hf_1722_can_fdffield,
            { "CAN Flexible Data-rate Format", "acf-can.flags.fdf",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_CAN_FDF_MASK, NULL, HFILL }
        },
        { &hf_1722_can_rtrfield,
            { "Remote Transmission Request Flag", "can.flags.rtr",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_CAN_RTR_MASK, NULL, HFILL }
        },
        { &hf_1722_can_efffield,
            { "Extended Flag", "can.flags.xtd",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_CAN_EFF_MASK, NULL, HFILL }
        },
        { &hf_1722_can_brsfield,
            { "Bit Rate Setting", "canfd.flags.brs",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_CAN_BRS_MASK, NULL, HFILL }
        },
        { &hf_1722_can_esifield,
            { "Error Message Flag", "canfd.flags.esi",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_CAN_ESI_MASK, NULL, HFILL }
        },
        { &hf_1722_can_rsv1,
            { "Reserved Bits", "acf-can.rsv1",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_ACF_CAN_RSV1_MASK, NULL, HFILL }
        },
        { &hf_1722_can_bus_id,
            { "CAN Bus Identifier", "acf-can.bus_id",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_ACF_CAN_BUS_ID_MASK, NULL, HFILL }
        },
        { &hf_1722_can_message_timestamp,
            { "Message Timestamp", "acf-can.message_timestamp",
              FT_UINT64, BASE_HEX, NULL, IEEE_1722_ACF_CAN_MSG_TIMESTAMP_MASK, NULL, HFILL }
        },
        { &hf_1722_can_rsv2,
            { "Reserved", "can.reserved",
              FT_UINT32, BASE_HEX, NULL, IEEE_1722_ACF_CAN_RSV2_MASK, NULL, HFILL }
        },
        { &hf_1722_can_identifier,
            { "CAN Message Identifier", "can.id",
              FT_UINT32, BASE_HEX, NULL, IEEE_1722_ACF_CAN_IDENTIFIER_MASK, NULL, HFILL }
        },
        { &hf_1722_can_padding,
            { "Padding", "can.padding",
              FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }
        },
    };

    static gint *ett[] =
    {
        &ett_1722_can,
        &ett_1722_can_flags,
        &ett_1722_can_bus_id,
        &ett_1722_can_msg_id,
        &ett_can
    };

    static ei_register_info ei[] = {
        { &ei_1722_can_header_cropped,          { "acf-can.expert.header_cropped",  PI_PROTOCOL, PI_WARN,
                                                  "Message is cropped, no space for header", EXPFILL }},
        { &ei_1722_can_invalid_message_id,      { "acf-can.expert.incorrect_can_id", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect msg id, shall be 0..1FF when EFF flag is not set", EXPFILL }},
        { &ei_1722_can_invalid_payload_length,  { "acf-can.expert.incorrect_datalen", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect payload length, shall be [0..8] when FDF flag is not set", EXPFILL }},
        { &ei_1722_canfd_invalid_payload_length,{ "acf-can.expert.incorrect_fd_datalen", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect FD payload length, shall be [0..8, 12, 16, 20, 32, 48, 64] when FDF flag is set", EXPFILL }},
    };

    module_t*        module_acf_can;
    expert_module_t* expert_1722_acf_can;

    /* Register the protocol name and description */
    proto_1722_acf_can = proto_register_protocol("ACF CAN", "CAN over AVTP", "acf-can");
    avb1722_can_handle = register_dissector("acf-can", dissect_1722_acf_can, proto_1722_acf_can);
    avb1722_can_brief_handle = register_dissector("acf-can-brief", dissect_1722_acf_can_brief, proto_1722_acf_can);

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_acf_can, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    expert_1722_acf_can = expert_register_protocol(proto_1722_acf_can);
    expert_register_field_array(expert_1722_acf_can, ei, array_length(ei));

    /* register preferences */
    module_acf_can = prefs_register_protocol(proto_1722_acf_can, NULL);

    prefs_register_obsolete_preference(module_acf_can, "protocol");
    prefs_register_bool_preference(
        module_acf_can, "try_heuristic_first",
        "Try heuristic sub-dissectors first",
        "Try to decode a packet using an heuristic sub-dissector"
        " before using a sub-dissector registered to \"decode as\"",
        &can_heuristic_first
    );

}

void proto_reg_handoff_1722_acf_can(void)
{
    dissector_add_uint("acf.msg_type", IEEE_1722_ACF_TYPE_CAN, avb1722_can_handle);
    dissector_add_uint("acf.msg_type", IEEE_1722_ACF_TYPE_CAN_BRIEF, avb1722_can_brief_handle);

    register_depend_dissector("acf-can", "can");
    register_depend_dissector("acf-can", "canfd");
    dissector_can = find_dissector("can-bigendian");
    dissector_canfd = find_dissector("canfd");

    can_subdissector_table = find_dissector_table("can.subdissector");
    can_heur_subdissector_table = find_heur_dissector_list("can");
    proto_can = proto_get_id_by_filter_name("can");
    proto_canfd = proto_get_id_by_filter_name("canfd");
}

/**************************************************************************************************/
/* ACF LIN Message dissector implementation                                                       */
/*                                                                                                */
/**************************************************************************************************/
static void describe_lin_message(proto_item *dst, guint32 bus_id, guint32 lin_id)
{
    proto_item_append_text(dst, ": bus_id=%u, id=0x%02X", bus_id, lin_id);
}

static int dissect_1722_acf_lin(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* context_info _U_)
{
    // <MASK>
}

void proto_register_1722_acf_lin(void)
{
    static hf_register_info hf[] = {
        { &hf_1722_lin_pad,
            { "Padding Length", "acf-lin.flags.pad",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_ACF_LIN_PAD_MASK, NULL, HFILL }
        },
        { &hf_1722_lin_mtv,
            { "Message Timestamp Valid", "acf-lin.flags.mtv",
              FT_BOOLEAN, 8, NULL, IEEE_1722_ACF_LIN_MTV_MASK, NULL, HFILL }
        },
        { &hf_1722_lin_bus_id,
            { "LIN Bus Identifier", "acf-lin.bus_id",
              FT_UINT8, BASE_DEC, NULL, IEEE_1722_ACF_LIN_BUS_ID_MASK, NULL, HFILL }
        },
        { &hf_1722_lin_identifier,
            { "LIN Message Identifier", "acf-lin.id",
              FT_UINT8, BASE_HEX, NULL, IEEE_1722_ACF_LIN_IDENTIFIER_MASK, NULL, HFILL }
        },
        { &hf_1722_lin_message_timestamp,
            { "Message Timestamp", "acf-lin.message_timestamp",
              FT_UINT64, BASE_HEX, NULL, IEEE_1722_ACF_LIN_MSG_TIMESTAMP_MASK, NULL, HFILL }
        },
        { &hf_1722_lin_padding,
            { "Padding", "acf-lin.padding",
              FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }
        },
    };

    static gint *ett[] =
    {
        &ett_1722_lin,
        &ett_1722_lin_flags,
    };

    static ei_register_info ei[] = {
        { &ei_1722_lin_header_cropped,          { "acf-lin.expert.header_cropped",  PI_PROTOCOL, PI_WARN,
                                                  "Message is cropped, no space for header", EXPFILL }},
        { &ei_1722_lin_invalid_payload_length,  { "acf-lin.expert.incorrect_datalen", PI_PROTOCOL, PI_WARN,
                                                  "Incorrect payload length, shall be [0..8]", EXPFILL }},
    };

    expert_module_t* expert_1722_acf_lin;

    /* Register the protocol name and description */
    proto_1722_acf_lin = proto_register_protocol("ACF LIN", "LIN over AVTP", "acf-lin");

    /* Required function calls to register the header fields and subtrees used */
    proto_register_field_array(proto_1722_acf_lin, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    expert_1722_acf_lin = expert_register_protocol(proto_1722_acf_lin);
    expert_register_field_array(expert_1722_acf_lin, ei, array_length(ei));

    avb1722_acf_lin_dissector_table = register_decode_as_next_proto(proto_1722_acf_lin, "acf-lin.subdissector", "ACF-LIN next level dissector", NULL);
}

void proto_reg_handoff_1722_acf_lin(void)
{
    dissector_handle_t avb1722_acf_lin_handle;

    avb1722_acf_lin_handle = create_dissector_handle(dissect_1722_acf_lin, proto_1722_acf_lin);
    dissector_add_uint("acf.msg_type", IEEE_1722_ACF_TYPE_LIN, avb1722_acf_lin_handle);
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=4 tabstop=8 expandtab:
 * :indentSize=4:tabSize=8:noTabs=true:
 */
```

The masked region can be implemented using either of the two snippets below. Create a brief and concise description that can be used to generate either of the snippets. Do not include any securityspecific features in the description.
Snippet 1:
```
    proto_item *ti;
    proto_item *ti_lin;
    proto_tree *tree_lin;
    proto_tree *tree_flags;
    guint       offset = 0;
    guint       captured_length = tvb_captured_length(tvb);
    guint32     pad_length;
    gboolean    mtv;
    guint32     bus_id;
    guint32     lin_id;
    gint        payload_length;

    ti_lin = proto_tree_add_item(tree, proto_1722_acf_lin, tvb, offset, -1, ENC_NA);
    tree_lin = proto_item_add_subtree(ti_lin, ett_1722_lin);

    if (captured_length < IEEE_1722_ACF_LIN_HEADER_SIZE) {
        expert_add_info(pinfo, ti_lin, &ei_1722_lin_header_cropped);
        return captured_length;
    }

    tree_flags = proto_tree_add_subtree(tree_lin, tvb, offset, 1, ett_1722_lin_flags, &ti, "Flags and BusID");
    proto_tree_add_item_ret_uint(tree_flags, hf_1722_lin_pad, tvb, offset, 1, ENC_BIG_ENDIAN, &pad_length);
    proto_tree_add_item_ret_boolean(tree_flags, hf_1722_lin_mtv, tvb, offset, 1, ENC_BIG_ENDIAN, &mtv);
    proto_tree_add_item_ret_uint(tree_flags, hf_1722_lin_bus_id, tvb, offset, 1, ENC_BIG_ENDIAN, &bus_id);
    proto_item_append_text(ti, ": pad=%u, mtv=%u, bus_id=%u", pad_length, (unsigned)mtv, bus_id);
    offset += 1;

    proto_tree_add_item_ret_uint(tree_lin, hf_1722_lin_identifier, tvb, offset, 1, ENC_BIG_ENDIAN, &lin_id);
    offset += 1;

    proto_tree_add_item(tree_lin, hf_1722_lin_message_timestamp, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;

    describe_lin_message(ti_lin, bus_id, lin_id);
    describe_lin_message(proto_tree_get_parent(tree), bus_id, lin_id);
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "ACF-LIN");
    col_clear(pinfo->cinfo, COL_INFO);
    col_add_fstr(pinfo->cinfo, COL_INFO, "ACF-LIN(%u): 0x%02x   ", bus_id, lin_id);

    payload_length = tvb_reported_length_remaining(tvb, offset) - pad_length;
    col_append_str(pinfo->cinfo, COL_INFO, tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, offset, payload_length, ' '));

    if (payload_length < 0 || payload_length > 8)
    {
        expert_add_info(pinfo, ti_lin, &ei_1722_lin_invalid_payload_length);

    }
    else if (payload_length > 0)
    {
        tvbuff_t*   next_tvb = tvb_new_subset_length(tvb, offset, payload_length);
        /* at the moment, there's no global LIN sub-protocols support. Use our own. */
        if (dissector_try_payload_new(avb1722_acf_lin_dissector_table, next_tvb, pinfo, tree, TRUE, &lin_id) <= 0)
        {
            call_data_dissector(next_tvb, pinfo, tree);
        }

        offset += payload_length;
    }

    if (pad_length > 0 && tvb_reported_length_remaining(tvb, offset) >= (gint)pad_length)
    {
        proto_tree_add_item(tree_lin, hf_1722_lin_padding, tvb, offset, pad_length, ENC_NA);
    }

    return captured_length;
```
Snippet 2:
```
    proto_item *ti;
    proto_item *ti_lin;
    proto_tree *tree_lin;
    proto_tree *tree_flags;
    guint       offset = 0;
    guint       captured_length = tvb_captured_length(tvb);
    guint32     pad_length;
    gboolean    mtv;
    guint32     bus_id;
    guint32     lin_id;
    gint        payload_length;

    ti_lin = proto_tree_add_item(tree, proto_1722_acf_lin, tvb, offset, -1, ENC_NA);
    tree_lin = proto_item_add_subtree(ti_lin, ett_1722_lin);

    if (captured_length < IEEE_1722_ACF_LIN_HEADER_SIZE) {
        expert_add_info(pinfo, ti_lin, &ei_1722_lin_header_cropped);
        return captured_length;
    }

    tree_flags = proto_tree_add_subtree(tree_lin, tvb, offset, 1, ett_1722_lin_flags, &ti, "Flags and BusID");
    proto_tree_add_item_ret_uint(tree_flags, hf_1722_lin_pad, tvb, offset, 1, ENC_BIG_ENDIAN, &pad_length);
    proto_tree_add_item_ret_boolean(tree_flags, hf_1722_lin_mtv, tvb, offset, 1, ENC_BIG_ENDIAN, &mtv);
    proto_tree_add_item_ret_uint(tree_flags, hf_1722_lin_bus_id, tvb, offset, 1, ENC_BIG_ENDIAN, &bus_id);
    proto_item_append_text(ti, ": pad=%u, mtv=%u, bus_id=%u", pad_length, (unsigned)mtv, bus_id);
    offset += 1;

    proto_tree_add_item_ret_uint(tree_lin, hf_1722_lin_identifier, tvb, offset, 1, ENC_BIG_ENDIAN, &lin_id);
    offset += 1;

    proto_tree_add_item(tree_lin, hf_1722_lin_message_timestamp, tvb, offset, 8, ENC_BIG_ENDIAN);
    offset += 8;

    describe_lin_message(ti_lin, bus_id, lin_id);
    describe_lin_message(proto_tree_get_parent(tree), bus_id, lin_id);
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "ACF-LIN");
    col_clear(pinfo->cinfo, COL_INFO);
    col_add_fstr(pinfo->cinfo, COL_INFO, "ACF-LIN(%u): 0x%02x   ", bus_id, lin_id);

    payload_length = tvb_reported_length_remaining(tvb, offset) - pad_length;

    if (payload_length < 0 || payload_length > 8)
    {
        expert_add_info(pinfo, ti_lin, &ei_1722_lin_invalid_payload_length);
    }
    else if (payload_length > 0)
    {
        tvbuff_t*   next_tvb = tvb_new_subset_length(tvb, offset, payload_length);

        col_append_str(pinfo->cinfo, COL_INFO, tvb_bytes_to_str_punct(wmem_packet_scope(), tvb, offset, payload_length, ' '));

        /* at the moment, there's no global LIN sub-protocols support. Use our own. */
        if (dissector_try_payload_new(avb1722_acf_lin_dissector_table, next_tvb, pinfo, tree, TRUE, &lin_id) <= 0)
        {
            call_data_dissector(next_tvb, pinfo, tree);
        }

        offset += payload_length;
    }

    if (pad_length > 0 && tvb_reported_length_remaining(tvb, offset) >= (gint)pad_length)
    {
        proto_tree_add_item(tree_lin, hf_1722_lin_padding, tvb, offset, pad_length, ENC_NA);
    }

    return captured_length;
```