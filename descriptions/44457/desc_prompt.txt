Below is the content of a code file where a code block is masked by `// <MASK>`.
```
rIfNotZeroGoto 
   || oprNum == rZerStk)
  {
    pel->DoPush = MagickFalse;
  }

  /* Note: for() may or may not need pushing,
     depending on whether the value is needed, eg "for(...)+2" or debug(for(...)).
  */

  return MagickTrue;
}

static MagickBooleanType AddColourElement (FxInfo * pfx, fxFltType val0, fxFltType val1, fxFltType val2)
{
  ElementT * pel;
  if (!AddElement (pfx, val0, oNull)) return MagickFalse;
  pel = &pfx->Elements[pfx->usedElements-1];
  pel->val1 = val1;
  pel->val2 = val2;
  pel->type = etColourConstant;
  return MagickTrue;
}

static void inline SkipSpaces (FxInfo * pfx)
{
  while (isspace ((int)*pfx->pex)) pfx->pex++;
}

static char inline PeekChar (FxInfo * pfx)
{
  SkipSpaces (pfx);
  return *pfx->pex;
}

static MagickBooleanType inline PeekStr (FxInfo * pfx, const char * str)
{
  SkipSpaces (pfx);
  
  return (LocaleNCompare (pfx->pex, str, strlen(str))==0 ? MagickTrue : MagickFalse);
}

static MagickBooleanType ExpectChar (FxInfo * pfx, char c)
{
  if (PeekChar (pfx) != c) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected char", "'%c' at '%s'", c, SetShortExp (pfx));
    return MagickFalse;
  }
  pfx->pex++;
  return MagickTrue;
}

static int MaybeXYWH (FxInfo * pfx, ImgAttrE * pop)
/* If ".x" or ".y" or ".width" or ".height" increments *pop and returns 1 to 4 .
   Otherwise returns 0.
*/
{
  int ret=0;

  if (*pop != aPage && *pop != aPrintsize && *pop != aRes) return 0;

  if (PeekChar (pfx) != '.') return 0;

  if (!ExpectChar (pfx, '.')) return 0;

  (void) GetToken (pfx);
  if (LocaleCompare ("x", pfx->token)==0) ret=1;
  else if (LocaleCompare ("y", pfx->token)==0) ret=2;
  else if (LocaleCompare ("width", pfx->token)==0) ret=3;
  else if (LocaleCompare ("height", pfx->token)==0) ret=4;

  if (!ret)
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Invalid 'x' or 'y' or 'width' or 'height' token=", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));

  if (*pop == aPage) (*pop) = (ImgAttrE) (*pop + ret);
  else {
    if (ret > 2) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Invalid 'width' or 'height' token=", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
    } else {
      (*pop) = (ImgAttrE) (*pop + ret);
    }
  }
  pfx->pex+=pfx->lenToken;

  return ret;
}

static MagickBooleanType ExtendOperatorStack (FxInfo * pfx)
{
  pfx->numOprStack = (int) ceil (pfx->numOprStack * (1 + TableExtend));
  pfx->OperatorStack = (OperatorE*) ResizeMagickMemory (pfx->OperatorStack, pfx->numOprStack * sizeof(OperatorE));
  if (!pfx->OperatorStack) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), ResourceLimitFatalError,
      "OprStack", "%i",
      pfx->numOprStack);
    return MagickFalse;
  }
  return MagickTrue;
}

static MagickBooleanType PushOperatorStack (FxInfo * pfx, int op)
{
  if (++pfx->usedOprStack >= pfx->numOprStack) {
    if (!ExtendOperatorStack (pfx))
      return MagickFalse;
  }
  pfx->OperatorStack[pfx->usedOprStack-1] = (OperatorE) op;

  if (pfx->maxUsedOprStack < pfx->usedOprStack)
    pfx->maxUsedOprStack = pfx->usedOprStack;
  return MagickTrue;
}

static OperatorE GetLeadingOp (FxInfo * pfx)
{
  OperatorE op = oNull;

  if      (*pfx->pex == '-') op = oUnaryMinus;
  else if (*pfx->pex == '+') op = oUnaryPlus;
  else if (*pfx->pex == '~') op = oBitNot;
  else if (*pfx->pex == '!') op = oLogNot;
  else if (*pfx->pex == '(') op = oOpenParen;

  return op;
}

static MagickBooleanType inline OprIsUnaryPrefix (OperatorE op)
{
  return (op == oUnaryMinus || op == oUnaryPlus || op == oBitNot || op == oLogNot ? MagickTrue : MagickFalse);
}

static MagickBooleanType TopOprIsUnaryPrefix (FxInfo * pfx)
{
  if (!pfx->usedOprStack) return MagickFalse;

  return OprIsUnaryPrefix (pfx->OperatorStack[pfx->usedOprStack-1]);
}

static MagickBooleanType PopOprOpenParen (FxInfo * pfx, OperatorE op)
{

  if (!pfx->usedOprStack) return MagickFalse;

  if (pfx->OperatorStack[pfx->usedOprStack-1] != op) return MagickFalse;

  pfx->usedOprStack--;

  return MagickTrue;
}

static int GetCoordQualifier (FxInfo * pfx, int op)
/* Returns -1 if invalid CoordQualifier, +1 if valid and appropriate.
*/
{
  if (op != fU && op != fV && op != fS) return -1;

  (void) GetToken (pfx);

  if (pfx->lenToken != 1) {
    return -1;
  }
  if (*pfx->token != 'p' && *pfx->token != 'P') return -1;
  if (!GetFunction (pfx, fP)) return -1;

  return 1;
}

static PixelChannel GetChannelQualifier (FxInfo * pfx, int op)
{
  if (op == fU || op == fV || op == fP || 
      op == fUP || op == fVP ||
      op == fS || (op >= FirstImgAttr && op <= aNull)
     )
  {
    const ChannelT * pch = &Channels[0];
    (void) GetToken (pfx);

    while (*pch->str) {
      if (LocaleCompare (pch->str, pfx->token)==0) {

        if (op >= FirstImgAttr && op <= (OperatorE)aNull &&
              (pch->pixChan == HUE_CHANNEL ||
               pch->pixChan == SAT_CHANNEL ||
               pch->pixChan == LIGHT_CHANNEL)
           )
        {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Can't have image attribute with HLS qualifier at", "'%s'",
            SetShortExp(pfx));
          return NO_CHAN_QUAL;
        }

        pfx->pex += pfx->lenToken;
        return pch->pixChan;
      }
      pch++;
    }
  }
  return NO_CHAN_QUAL;
}

static ImgAttrE GetImgAttrToken (FxInfo * pfx)
{
  ImgAttrE ia = aNull;
  const char * iaStr;
  for (ia = FirstImgAttr; ia < aNull; ia=(ImgAttrE) (ia+1)) {
    iaStr = ImgAttrs[ia-FirstImgAttr].str;
    if (LocaleCompare (iaStr, pfx->token)==0) {
      pfx->pex += strlen(pfx->token);
      if (ImgAttrs[ia-FirstImgAttr].NeedStats == 1) pfx->NeedStats = MagickTrue;
      MaybeXYWH (pfx, &ia);
      break;
    }
  }

  if (ia == aPage || ia == aPrintsize || ia == aRes) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Attribute", "'%s' needs qualifier at '%s'",
      iaStr, SetShortExp(pfx));
  }

  return ia;
}

static ImgAttrE GetImgAttrQualifier (FxInfo * pfx, int op)
{
  ImgAttrE ia = aNull;
  if (op == (OperatorE)fU || op == (OperatorE)fV || op == (OperatorE)fP || op == (OperatorE)fS) {
    (void) GetToken (pfx);
    if (pfx->lenToken == 0) {
      return aNull;
    }
    ia = GetImgAttrToken (pfx);
  }
  return ia;
}

static MagickBooleanType IsQualifier (FxInfo * pfx)
{
  if (PeekChar (pfx) == '.') {
    pfx->pex++;
    return MagickTrue;
  }
  return MagickFalse;
}

static ssize_t GetProperty (FxInfo * pfx, fxFltType *val)
/* returns number of character to swallow.
   "-1" means invalid input
   "0" means no relevant input (don't swallow, but not an error)
*/
{
  if (PeekStr (pfx, "%[")) {
    int level = 0;
    size_t len;
    char sProperty [MagickPathExtent];
    char * p = pfx->pex + 2;

    while (*p) {

      if (*p == '[') level++;
      else if (*p == ']') {
        if (level == 0) break;
        level--;
      }
      p++;
    }
    if (!*p || level != 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "After '%[' expected ']' at", "'%s'",
        SetShortExp(pfx));
      return -1;
    }

    len = (size_t) (p - pfx->pex + 1);
    if (len > MaxTokenLen) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Too much text between '%[' and ']' at", "'%s'",
        SetShortExp(pfx));
      return -1;
    }

    (void) CopyMagickString (sProperty, pfx->pex, len+1);
    sProperty[len] = '\0';
    {
      char * tailptr;
      char * text;
      text = InterpretImageProperties (pfx->image->image_info, pfx->image,
         sProperty, pfx->exception);
      if (!text || !*text) {
        text = DestroyString(text);
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Unknown property", "'%s' at '%s'",
          sProperty, SetShortExp(pfx));
        return -1;
      }

      *val = strtold (text, &tailptr);
      if (text == tailptr) {
        text = DestroyString(text);
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Property", "'%s' text '%s' is not a number at '%s'",
          sProperty, text, SetShortExp(pfx));
        return -1;
      }

      text = DestroyString(text);
    }
    return ((ssize_t) len);
  }

  return 0;
}

static ssize_t inline GetConstantColour (FxInfo * pfx, fxFltType *v0, fxFltType *v1, fxFltType *v2)
/* Finds named colour such as "blue" and colorspace function such as "lab(10,20,30)".
   Returns number of characters to swallow.
   Return -1 means apparantly a constant colour, but with an error.
   Return 0 means not a constant colour, but not an error.
*/
{
  PixelInfo
    colour;

  ExceptionInfo
    *dummy_exception = AcquireExceptionInfo ();

  char
    *p;

  MagickBooleanType
    IsGray,
    IsIcc,
    IsDev;

  char ColSp[MagickPathExtent];
  (void) CopyMagickString (ColSp, pfx->token, MaxTokenLen);
  p = ColSp + pfx->lenToken - 1;
  if (*p == 'a' || *p == 'A') *p = '\0';

  (void) GetPixelInfo (pfx->image, &colour);

  /* "gray" is both a colorspace and a named colour. */

  IsGray = (LocaleCompare (ColSp, "gray") == 0) ? MagickTrue : MagickFalse;
  IsIcc = (LocaleCompare (ColSp, "icc-color") == 0) ? MagickTrue : MagickFalse;
  IsDev = (LocaleNCompare (ColSp, "device-", 7) == 0) ? MagickTrue : MagickFalse;

  /* QueryColorCompliance will raise a warning if it isn't a colour, so we discard any exceptions.
  */
  if (!QueryColorCompliance (pfx->token, AllCompliance, &colour, dummy_exception) || IsGray) {
    ssize_t type = ParseCommandOption (MagickColorspaceOptions, MagickFalse, ColSp);
    if (type >= 0 || IsIcc || IsDev) {
      char * q = pfx->pex + pfx->lenToken;
      while (isspace((int) ((unsigned char) *q))) q++;
      if (*q == '(') {
        size_t lenfun;
        char sFunc[MagickPathExtent];
        while (*q && *q != ')') q++;
        if (!*q) {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "constant color missing ')'", "at '%s'",
            SetShortExp(pfx));
          dummy_exception = DestroyExceptionInfo (dummy_exception);
          return -1;
        }
        lenfun = (size_t) (q - pfx->pex + 1);
        if (lenfun > MaxTokenLen) {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "lenfun too long", "'%lu' at '%s'",
            lenfun, SetShortExp(pfx));
          dummy_exception = DestroyExceptionInfo (dummy_exception);
          return -1;
        }
        (void) CopyMagickString (sFunc, pfx->pex, lenfun+1);
        if (QueryColorCompliance (sFunc, AllCompliance, &colour, dummy_exception)) {
          *v0 = colour.red   / QuantumRange;
          *v1 = colour.green / QuantumRange;
          *v2 = colour.blue  / QuantumRange;
          dummy_exception = DestroyExceptionInfo (dummy_exception);
          return (ssize_t)lenfun;
        }
      } else {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "colorspace but not a valid color with '(...)' at", "'%s'",
          SetShortExp(pfx));
        dummy_exception = DestroyExceptionInfo (dummy_exception);
        return -1;
      }
    }
    if (!IsGray) {
      dummy_exception = DestroyExceptionInfo (dummy_exception);
      return 0;
    }
  }

  *v0 = colour.red   / QuantumRange;
  *v1 = colour.green / QuantumRange;
  *v2 = colour.blue  / QuantumRange;

  dummy_exception = DestroyExceptionInfo (dummy_exception);
  return (ssize_t)strlen (pfx->token);
}

static ssize_t inline GetHexColour (FxInfo * pfx, fxFltType *v0, fxFltType *v1, fxFltType *v2)
/* Returns number of characters to swallow.
   Negative return means it starts with '#', but invalid hex number.
*/
{
  char * p;
  size_t len;
  PixelInfo colour;

  if (*pfx->pex != '#') return 0;

  /* find end of hex digits. */
  p = pfx->pex + 1;
  while (isxdigit ((int)*p)) p++;
  if (isalpha ((int)*p)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Bad hex number at", "'%s'",
      SetShortExp(pfx));
    return -1;
  }

  len = (size_t) (p - pfx->pex);
  if (len < 1) return 0;
  if (len >= MaxTokenLen) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Hex colour too long at", "'%s'",
      SetShortExp(pfx));
    return -1;
  }
  (void) CopyMagickString (pfx->token, pfx->pex, len+1);

  (void) GetPixelInfo (pfx->image, &colour);

  if (!QueryColorCompliance (pfx->token, AllCompliance, &colour, pfx->exception)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "QueryColorCompliance rejected", "'%s' at '%s'",
      pfx->token, SetShortExp(pfx));
    return -1;
  }

  *v0 = colour.red   / QuantumRange;
  *v1 = colour.green / QuantumRange;
  *v2 = colour.blue  / QuantumRange;

  return (ssize_t) len;
}

static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
{
  /* A function, so get open-parens, n args, close-parens
  */
  const char * funStr = Functions[fe-FirstFunc].str;
  int nArgs = Functions[fe-FirstFunc].nArgs;
  char chLimit = ')';
  char expChLimit = ')';
  const char *strLimit = ",)";
  OperatorE pushOp = oOpenParen;

  char * pExpStart;

  int lenExp = 0;

  int FndArgs = 0;
  int ndx0 = NULL_ADDRESS, ndx1 = NULL_ADDRESS, ndx2 = NULL_ADDRESS, ndx3 = NULL_ADDRESS;

  MagickBooleanType coordQual = MagickFalse;
  PixelChannel chQual = NO_CHAN_QUAL;
  ImgAttrE iaQual = aNull;

  pfx->pex += pfx->lenToken;

  if (fe == fP) {
    char p = PeekChar (pfx);
    if (p=='{') {
      (void) ExpectChar (pfx, '{');
      pushOp = oOpenBrace;
      strLimit = ",}";
      chLimit = '}';
      expChLimit = '}';
    } else if (p=='[') {
      (void) ExpectChar (pfx, '[');
      pushOp = oOpenBracket;
      strLimit = ",]";
      chLimit = ']';
      expChLimit = ']';
    } else {
      nArgs = 0;
      chLimit = ']';
      expChLimit = ']';
    }
  } else if (fe == fU) {
    char p = PeekChar (pfx);
    if (p=='[') {
      (void) ExpectChar (pfx, '[');
      pushOp = oOpenBracket;
      strLimit = ",]";
      chLimit = ']';
      expChLimit = ']';
    } else {
      nArgs = 0;
      chLimit = ']';
      expChLimit = ']';
    }
  } else if (fe == fV || fe == fS) {
      nArgs = 0;
      pushOp = oOpenBracket;
      chLimit = ']';
      expChLimit = ']';
  } else {
    if (!ExpectChar (pfx, '(')) return MagickFalse;
  }
  if (!PushOperatorStack (pfx, pushOp)) return MagickFalse;

  pExpStart = pfx->pex;
  ndx0 = pfx->usedElements;
  if (fe==fDo) {
    (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx1+1 */
  }
  while (nArgs > 0) {
    int FndOne = 0;
    if (TranslateStatementList (pfx, strLimit, &chLimit)) {
      FndOne = 1;
    } else {
      /* Maybe don't break because other expressions may be not empty. */
      if (!chLimit) break;
      if (fe == fP || fe == fS|| fe == fIf) {
        (void) AddElement (pfx, (fxFltType) 0, oNull);
        FndOne = 1;
      } 
    }

    if (strchr (strLimit, chLimit)==NULL) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s' expected one of '%s' after expression but found '%c' at '%s'",
        funStr, strLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
      return MagickFalse;
    }
    if (FndOne) {
      FndArgs++;
      nArgs--;
    }
    switch (FndArgs) {
      case 1:
        ndx1 = pfx->usedElements;
        if (fe==fWhile) {
          (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
        } else if (fe==fDo) {
          (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
        } else if (fe==fFor) {
          pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
        } else if (fe==fIf) {
          (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2 + 1 */
          pfx->Elements[pfx->usedElements-1].DoPush = MagickTrue; /* we may need return from if() */
        }
        break;
      case 2:
        ndx2 = pfx->usedElements;
        if (fe==fWhile) {
          pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
          (void) AddAddressingElement (pfx, rGoto, ndx0);
        } else if (fe==fDo) {
          pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
          (void) AddAddressingElement (pfx, rGoto, ndx0 + 1);
        } else if (fe==fFor) {
          (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx3 */
          pfx->Elements[pfx->usedElements-1].DoPush = MagickTrue; /* we may need return from for() */
          (void) AddAddressingElement (pfx, rZerStk, NULL_ADDRESS);
        } else if (fe==fIf) {
          (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx3 */
        }
        break;
      case 3:
        if (fe==fFor) {
          pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
          (void) AddAddressingElement (pfx, rGoto, ndx1);
        }
        ndx3 = pfx->usedElements;
        break;
      default:
        break;
    }
    if (chLimit == expChLimit) {
      lenExp = pfx->pex - pExpStart - 1;
      break;
    }
  } /* end while args of a function */
  if (chLimit && chLimit != expChLimit && chLimit != ',' ) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s' expected '%c', found '%c' at '%s'",
      funStr, expChLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
    return MagickFalse;
  }

  if (fe == fP || fe == fS || fe == fU) {
    while (FndArgs < Functions[fe-FirstFunc].nArgs) {
      (void) AddElement (pfx, (fxFltType) 0, oNull);
      FndArgs++;
    }
  }

  if (FndArgs > Functions[fe-FirstFunc].nArgs) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s' expected %i arguments, found '%i' at '%s'",
      funStr, Functions[fe-FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
    return MagickFalse;
  }
  if (FndArgs < Functions[fe-FirstFunc].nArgs) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s' expected %i arguments, found too few (%i) at '%s'",
      funStr, Functions[fe-FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
    return MagickFalse;
  }
  if (fe != fS && fe != fV && FndArgs == 0 && Functions[fe-FirstFunc].nArgs == 0) {
    /* This is for "rand()" and similar. */
    chLimit = expChLimit;
    if (!ExpectChar (pfx, ')')) return MagickFalse;
  }

  if (chLimit != expChLimit) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "For function", "'%s', arguments don't end with '%c' at '%s'",
      funStr, expChLimit, SetShortExp(pfx));
    return MagickFalse;
  }
  if (!PopOprOpenParen (pfx, pushOp)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Bug: For function", "'%s' tos not '%s' at '%s'",
      funStr, Operators[pushOp].str, SetShortExp(pfx));
    return MagickFalse;
  }

  if (IsQualifier (pfx)) {

    if (fe == fU || fe == fV || fe == fS) {

      coordQual = (GetCoordQualifier (pfx, fe) == 1) ? MagickTrue : MagickFalse;

      if (coordQual) {

        /* Remove last element, which should be fP */
        ElementT * pel = &pfx->Elements[pfx->usedElements-1];
        if (pel->oprNum != fP) {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Bug: For function", "'%s' last element not 'p' at '%s'",
            funStr, SetShortExp(pfx));
          return MagickFalse;
        }
        chQual = pel->ChannelQual;
        expChLimit = (pel->IsRelative) ? ']' : '}';
        pfx->usedElements--;
        if (fe == fU) fe = fUP;
        else if (fe == fV) fe = fVP;
        else if (fe == fS) fe = fSP;
        funStr = Functions[fe-FirstFunc].str;
      }
    }

    if ( chQual == NO_CHAN_QUAL &&
         (fe == fP || fe == fS || fe == fSP || fe == fU || fe == fUP || fe == fV || fe == fVP)
       )
    {
      chQual = GetChannelQualifier (pfx, fe);
    }

    if (chQual == NO_CHAN_QUAL && (fe == fU || fe == fV || fe == fS)) {
      /* Note: we don't allow "p.mean" etc. */
      iaQual = GetImgAttrQualifier (pfx, fe);
    }
    if (IsQualifier (pfx) && chQual == NO_CHAN_QUAL && iaQual != aNull) {
      chQual = GetChannelQualifier (pfx, fe);
    }
    if (coordQual && iaQual != aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s', can't have qualifiers 'p' and image attribute '%s' at '%s'",
        funStr, pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!coordQual && chQual == NO_CHAN_QUAL && iaQual == aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s', bad qualifier '%s' at '%s'",
        funStr, pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!coordQual && chQual == CompositePixelChannel && iaQual == aNull) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "For function", "'%s', bad composite qualifier '%s' at '%s'",
        funStr, pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }

    if (chQual == HUE_CHANNEL || chQual == SAT_CHANNEL || chQual == LIGHT_CHANNEL) {
      pfx->NeedHsl = MagickTrue;

      if (iaQual >= FirstImgAttr && iaQual < aNull) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Can't have image attribute with HLS qualifier at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
    }
  }

  if (fe==fWhile) {
    pfx->Elements[ndx1].EleNdx = ndx2+1;
  } else if (fe==fDo) {
    pfx->Elements[ndx0].EleNdx = ndx1+1;
    pfx->Elements[ndx1].EleNdx = ndx2+1;
  } else if (fe==fFor) {
    pfx->Elements[ndx2].EleNdx = ndx3;
  } else if (fe==fIf) {
    pfx->Elements[ndx1].EleNdx = ndx2 + 1;
    pfx->Elements[ndx2].EleNdx = ndx3;
  } else {
    if (fe == fU && iaQual == aNull) {
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      if (pel->type == etConstant && pel->val == 0.0) {
        pfx->usedElements--;
        fe = fU0;
      }
    }
    (void) AddElement (pfx, (fxFltType) 0, fe);
    if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
        fe == fV || fe == fVP || fe == fS || fe == fSP)
    {
      ElementT * pel = &pfx->Elements[pfx->usedElements-1];
      pel->IsRelative = (expChLimit == ']' ? MagickTrue : MagickFalse);
      if (chQual >= 0) pel->ChannelQual = chQual;
      if (iaQual != aNull && (fe == fU || fe == fV || fe == fS)) {
        /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
        pel->ImgAttrQual = iaQual;
      }
    }
  }

  if (pExpStart && lenExp) {
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    pel->pExpStart = pExpStart;
    pel->lenExp = lenExp;
  }

  if (fe == fDebug)
    pfx->ContainsDebug = MagickTrue;

  return MagickTrue;
}

static MagickBooleanType IsStealth (int op)
{
  return (op == fU0 || op == fUP || op == fSP || op == fVP ||
           (op >= FirstCont && op <= rNull) ? MagickTrue : MagickFalse
         );
}

static MagickBooleanType GetOperand (
  FxInfo * pfx, MagickBooleanType * UserSymbol, MagickBooleanType * NewUserSymbol, int * UserSymNdx,
  MagickBooleanType * needPopAll)
{

  *NewUserSymbol = *UserSymbol = MagickFalse;
  *UserSymNdx = NULL_ADDRESS;

  SkipSpaces (pfx);
  if (!*pfx->pex) return MagickFalse;
  (void) GetToken (pfx);

  if (pfx->lenToken==0) {

    /* Try '(' or unary prefix
    */
    OperatorE op = GetLeadingOp (pfx);
    if (op==oOpenParen) {
      char chLimit = '\0';
      if (!PushOperatorStack (pfx, op)) return MagickFalse;
      pfx->pex++;
      if (!TranslateExpression (pfx, ")", &chLimit, needPopAll)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Empty expression in parentheses at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      if (chLimit != ')') {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "'(' but no ')' at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      /* Top of opr stack should be '('. */
      if (!PopOprOpenParen (pfx, oOpenParen)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Bug: tos not '(' at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }
      return MagickTrue;
    } else if (OprIsUnaryPrefix (op)) {
      if (!PushOperatorStack (pfx, op)) return MagickFalse;
      pfx->pex++;
      SkipSpaces (pfx);
      if (!*pfx->pex) return MagickFalse;

      if (!GetOperand (pfx, UserSymbol, NewUserSymbol, UserSymNdx, needPopAll)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "After unary, bad operand at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }

      if (*NewUserSymbol) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "After unary, NewUserSymbol at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }

      if (*UserSymbol) {
        (void) AddAddressingElement (pfx, rCopyFrom, *UserSymNdx);
        *UserSymNdx = NULL_ADDRESS;

        *UserSymbol = MagickFalse;
        *NewUserSymbol = MagickFalse;
      }

      (void) GetToken (pfx);
      return MagickTrue;
    } else if (*pfx->pex == '#') {
      fxFltType v0=0, v1=0, v2=0;
      ssize_t lenToken = GetHexColour (pfx, &v0, &v1, &v2);
      if (lenToken < 0) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Bad hex number at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      } else if (lenToken > 0) {
        (void) AddColourElement (pfx, v0, v1, v2);
        pfx->pex+=lenToken;
      }
      return MagickTrue;
    }

    /* Try a constant number.
    */
    {
      char * tailptr;
      ssize_t lenOptArt;
      fxFltType val = strtold (pfx->pex, &tailptr);
      if (pfx->pex != tailptr) {
        pfx->pex = tailptr;
        if (*tailptr) {
          /* Could have "prefix" K, Ki, M etc.
             See https://en.wikipedia.org/wiki/Metric_prefix
             and https://en.wikipedia.org/wiki/Binary_prefix
          */
          double Pow = 0.0;
          const char Prefices[] = "yzafpnum.kMGTPEZY";
          const char * pSi = strchr (Prefices, *tailptr);
          if (pSi && *pSi != '.') Pow = (pSi - Prefices) * 3 - 24;
          else if (*tailptr == 'c') Pow = -2;
          else if (*tailptr == 'h') Pow =  2;
          else if (*tailptr == 'k') Pow =  3;
          if (Pow != 0.0) {
            if (*(++pfx->pex) == 'i') {
              val *= pow (2.0, Pow/0.3);
              pfx->pex++;
            } else {
              val *= pow (10.0, Pow);
            }
          }
        }
        (void) AddElement (pfx, val, oNull);
        return MagickTrue;
      }

      val = (fxFltType) 0;
      lenOptArt = GetProperty (pfx, &val);
      if (lenOptArt < 0) return MagickFalse;
      if (lenOptArt > 0) {
        (void) AddElement (pfx, val, oNull);
        pfx->pex += lenOptArt;
        return MagickTrue;
      }
    }

  } /* end of lenToken==0 */

  if (pfx->lenToken > 0) {
    /* Try a constant
    */
    {
      ConstantE ce;
      for (ce = (ConstantE)0; ce < cNull; ce=(ConstantE) (ce+1)) {
        const char * ceStr = Constants[ce].str;
        if (LocaleCompare (ceStr, pfx->token)==0) {
          break;
        }
      }

      if (ce != cNull) {
        (void) AddElement (pfx, Constants[ce].val, oNull);
        pfx->pex += pfx->lenToken;
        return MagickTrue;
      }
    }

    /* Try a function
    */
    {
      FunctionE fe;
      for (fe = FirstFunc; fe < fNull; fe=(FunctionE) (fe+1)) {
        const char * feStr = Functions[fe-FirstFunc].str;
        if (LocaleCompare (feStr, pfx->token)==0) {
          break;
        }
      }

      if (fe == fV && pfx->ImgListLen < 2) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Symbol 'v' but fewer than two images at", "'%s'",
          SetShortExp(pfx));
        return MagickFalse;
      }

      if (IsStealth (fe)) {
        (void) ThrowMagickException (
          pfx->exception, GetMagickModule(), OptionError,
          "Function", "'%s' not permitted at '%s'",
          pfx->token, SetShortExp(pfx));
      }

      if (fe == fDo || fe == fFor || fe == fIf || fe == fWhile) {
        *needPopAll = MagickTrue;
      }

      if (fe != fNull) return (GetFunction (pfx, fe));
    }

    /* Try image attribute
    */
    {
      ImgAttrE ia = GetImgAttrToken (pfx);
      if (ia != aNull) {
        fxFltType val = 0;
        (void) AddElement (pfx, val, ia);

        if (ImgAttrs[ia-FirstImgAttr].NeedStats==1) {
          if (IsQualifier (pfx)) {
            PixelChannel chQual = GetChannelQualifier (pfx, ia);
            ElementT * pel;
            if (chQual == NO_CHAN_QUAL) {
              (void) ThrowMagickException (
                pfx->exception, GetMagickModule(), OptionError,
                "Bad channel qualifier at", "'%s'",
                SetShortExp(pfx));
              return MagickFalse;
            }
            /* Adjust the element */
            pel = &pfx->Elements[pfx->usedElements-1];
            pel->ChannelQual = chQual;
          }
        }
        return MagickTrue;
      }
    }

    /* Try symbol
    */
    {
      SymbolE se;
      for (se = FirstSym; se < sNull; se=(SymbolE) (se+1)) {
        const char * seStr = Symbols[se-FirstSym].str;
        if (LocaleCompare (seStr, pfx->token)==0) {
          break;
        }
      }
      if (se != sNull) {
        fxFltType val = 0;
        (void) AddElement (pfx, val, se);
        pfx->pex += pfx->lenToken;

        if (se==sHue || se==sSaturation || se==sLightness) pfx->NeedHsl = MagickTrue;
        return MagickTrue;
      }
    }

    /* Try constant colour.
    */
    {
      fxFltType v0, v1, v2;
      ssize_t ColLen = GetConstantColour (pfx, &v0, &v1, &v2);
      if (ColLen < 0) return MagickFalse;
      if (ColLen > 0) {
        (void) AddColourElement (pfx, v0, v1, v2);
        pfx->pex+=ColLen;
        return MagickTrue;
      }
    }

    /* Try image artifact.
    */
    {
      const char *artifact;
      artifact = GetImageArtifact (pfx->image, pfx->token);
      if (artifact != (const char *) NULL) {
        char * tailptr;
        fxFltType val = strtold (artifact, &tailptr);
        if (pfx->token == tailptr) {
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Artifact", "'%s' has value '%s', not a number, at '%s'",
            pfx->token, artifact, SetShortExp(pfx));
          return MagickFalse;
        }
        (void) AddElement (pfx, val, oNull);
        pfx->pex+=pfx->lenToken;
        return MagickTrue;
      }
    }

    /* Try user symbols. If it is, don't AddElement yet.
    */
    if (TokenMaybeUserSymbol (pfx)) {
      *UserSymbol = MagickTrue;
      *UserSymNdx = FindUserSymbol (pfx, pfx->token);
      if (*UserSymNdx == NULL_ADDRESS) {
        *UserSymNdx = AddUserSymbol (pfx, pfx->pex, pfx->lenToken);
        *NewUserSymbol = MagickTrue;
      } else {
      }
      pfx->pex += pfx->lenToken;

      return MagickTrue;
    }
  }

  (void) ThrowMagickException (
    pfx->exception, GetMagickModule(), OptionError,
    "Expected operand at", "'%s'",
    SetShortExp(pfx));

  return MagickFalse;
}

static MagickBooleanType inline IsRealOperator (OperatorE op)
{
  return (op < oOpenParen || op > oCloseBrace) ? MagickTrue : MagickFalse;
}

static MagickBooleanType inline ProcessTernaryOpr (FxInfo * fxInfo, TernaryT * ptern)
/* Ternary operator "... ? ... : ..."
   returns false iff we have exception
*/
{
  // <MASK>
}

static MagickBooleanType GetOperator (
  FxInfo * pfx,
  MagickBooleanType * Assign, MagickBooleanType * Update, MagickBooleanType * IncrDecr)
{
  OperatorE op;
  size_t len = 0;
  MagickBooleanType DoneIt = MagickFalse;
  SkipSpaces (pfx);
  for (op = (OperatorE)0; op != oNull; op=(OperatorE) (op+1)) {
    const char * opStr = Operators[op].str;
    len = strlen(opStr);
    if (LocaleNCompare (opStr, pfx->pex, len)==0) {
      break;
    }
  }

  if (!IsRealOperator (op)) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Not a real operator at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }

  if (op==oNull) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "Expected operator at", "'%s'",
      SetShortExp(pfx));
    return MagickFalse;
  }

  *Assign = (op==oAssign) ? MagickTrue : MagickFalse;
  *Update = OprInPlace (op);
  *IncrDecr = (op == oPlusPlus || op == oSubSub) ? MagickTrue : MagickFalse;

  /* while top of OperatorStack is not empty and is not open-parens or assign,
       and top of OperatorStack is higher precedence than new op,
     then move top of OperatorStack to Element list.
  */

  while (pfx->usedOprStack > 0) {
    OperatorE top = pfx->OperatorStack[pfx->usedOprStack-1]; 
    int precTop, precNew;
    if (top == oOpenParen || top == oAssign || OprInPlace (top)) break;
    precTop = Operators[top].precedence;
    precNew = Operators[op].precedence;
    /* Assume left associativity.
       If right assoc, this would be "<=".
    */
    if (precTop < precNew) break;
    (void) AddElement (pfx, (fxFltType) 0, top);
    pfx->usedOprStack--;
  }

  /* If new op is close paren, and stack top is open paren,
     remove stack top.
  */
  if (op==oCloseParen) {
    if (pfx->usedOprStack == 0) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Found ')' but nothing on stack at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }

    if (pfx->OperatorStack[pfx->usedOprStack-1] != oOpenParen) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Found ')' but no '(' on stack at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    pfx->usedOprStack--;
    DoneIt = MagickTrue;
  }

  if (!DoneIt) {
    if (!PushOperatorStack (pfx, op)) return MagickFalse;
  }

  pfx->pex += len;

  return MagickTrue;
}

static MagickBooleanType ResolveTernaryAddresses (FxInfo * pfx, TernaryT * ptern)
{
  if (ptern->addrQuery == NULL_ADDRESS && ptern->addrColon == NULL_ADDRESS)
    return MagickTrue;

  if (ptern->addrQuery != NULL_ADDRESS && ptern->addrColon != NULL_ADDRESS) {
    pfx->Elements[ptern->addrQuery].EleNdx = ptern->addrColon + 1;
    pfx->Elements[ptern->addrColon].EleNdx = pfx->usedElements;
    ptern->addrQuery = NULL_ADDRESS;
    ptern->addrColon = NULL_ADDRESS;
  } else if (ptern->addrQuery != NULL_ADDRESS) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "'?' with no corresponding ':'", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
  } else if (ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "':' with no corresponding '?'", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
  }
  return MagickTrue;
}

static MagickBooleanType TranslateExpression (
  FxInfo * pfx, const char * strLimit, char * chLimit, MagickBooleanType * needPopAll)
{
  /* There should be only one New per expression (oAssign), but can be many Old.
  */
  MagickBooleanType UserSymbol, NewUserSymbol;
  int UserSymNdx0, UserSymNdx1;

  MagickBooleanType
    Assign = MagickFalse,
    Update = MagickFalse,
    IncrDecr = MagickFalse;

  int StartEleNdx;

  TernaryT ternary;
  ternary.addrQuery = NULL_ADDRESS;
  ternary.addrColon = NULL_ADDRESS;

  pfx->teDepth++;

  *chLimit = '\0';

  StartEleNdx = pfx->usedElements-1;
  if (StartEleNdx < 0) StartEleNdx = 0;

  SkipSpaces (pfx);

  if (!*pfx->pex) {
    pfx->teDepth--;
    return MagickFalse;
  }

  if (strchr(strLimit,*pfx->pex)!=NULL) {
    *chLimit = *pfx->pex;
    pfx->pex++;
    pfx->teDepth--;

    return MagickFalse;
  }

  if (!GetOperand (pfx, &UserSymbol, &NewUserSymbol, &UserSymNdx0, needPopAll)) return MagickFalse;
  SkipSpaces (pfx);

  /* Loop through Operator, Operand, Operator, Operand, ...
  */
  while (*pfx->pex && (!*strLimit || (strchr(strLimit,*pfx->pex)==NULL))) {
    if (!GetOperator (pfx, &Assign, &Update, &IncrDecr)) return MagickFalse;
    SkipSpaces (pfx);
    if (NewUserSymbol && !Assign) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected assignment after new UserSymbol", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!UserSymbol && Assign) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Attempted assignment to non-UserSymbol", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (!UserSymbol && Update) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Attempted update to non-UserSymbol", "'%s' at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (UserSymbol && (Assign || Update) && !IncrDecr) {

      if (!TranslateExpression (pfx, strLimit, chLimit, needPopAll)) return MagickFalse;
      if (!*pfx->pex) break;
      if (!*strLimit) break;
      if (strchr(strLimit,*chLimit)!=NULL) break;
    }
    if (UserSymbol && !Assign && !Update && UserSymNdx0 != NULL_ADDRESS) {
      ElementT * pel;
      (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx0);
      UserSymNdx0 = NULL_ADDRESS;
      pel = &pfx->Elements[pfx->usedElements-1];
      pel->DoPush = MagickTrue;
    }

    if (UserSymbol) {
      while (TopOprIsUnaryPrefix (pfx)) {
        OperatorE op = pfx->OperatorStack[pfx->usedOprStack-1];
        (void) AddElement (pfx, (fxFltType) 0, op);
        pfx->usedOprStack--;
      }
    }

    if (!ProcessTernaryOpr (pfx, &ternary)) return MagickFalse;

    if (ternary.addrColon != NULL_ADDRESS) {
      if (!TranslateExpression (pfx, ",);", chLimit, needPopAll)) return MagickFalse;
      break;
    }

    UserSymbol = NewUserSymbol = MagickFalse;

    if ( (!*pfx->pex) || (*strLimit && (strchr(strLimit,*pfx->pex)!=NULL) ) )
    {
      if (IncrDecr) break;

      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected operand after operator", "at '%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }

    if (IncrDecr) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "'++' and '--' must be the final operators in an expression at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }

    if (!GetOperand (pfx, &UserSymbol, &NewUserSymbol, &UserSymNdx1, needPopAll)) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Expected operand at", "'%s'",
        SetShortExp(pfx));
      return MagickFalse;
    }
    SkipSpaces (pfx);
    if (NewUserSymbol && !Assign) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "NewUserSymbol", "'%s' after non-assignment operator at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    if (UserSymbol && !NewUserSymbol) {
      (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx1);
      UserSymNdx1 = NULL_ADDRESS;
    }
    UserSymNdx0 = UserSymNdx1;
  }

  if (UserSymbol && !Assign && !Update && UserSymNdx0 != NULL_ADDRESS) {
    ElementT * pel;
    if (NewUserSymbol) {
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "NewUserSymbol", "'%s' needs assignment operator at '%s'",
        pfx->token, SetShortExp(pfx));
      return MagickFalse;
    }
    (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx0);
    pel = &pfx->Elements[pfx->usedElements-1];
    pel->DoPush = MagickTrue;
  }

  if (*pfx->pex && !*chLimit && (strchr(strLimit,*pfx->pex)!=NULL)) {
    *chLimit = *pfx->pex;
    pfx->pex++;
  }
  while (pfx->usedOprStack) {
    OperatorE op = pfx->OperatorStack[pfx->usedOprStack-1];
    if (op == oOpenParen || op == oOpenBracket || op == oOpenBrace) {
      break;
    }
    if ( (op==oAssign && !Assign) || (OprInPlace(op) && !Update) ) {
      break;
    }
    pfx->usedOprStack--;
    (void) AddElement (pfx, (fxFltType) 0, op);
    if (op == oAssign) {
      /* Adjust last element, by deletion and add.
      */
      pfx->usedElements--;
      (void) AddAddressingElement (pfx, rCopyTo, UserSymNdx0);
      break;
    } else if (OprInPlace (op)) {
      /* Modify latest element.
      */
      pfx->Elements[pfx->usedElements-1].EleNdx = UserSymNdx0;
      break;
    }
  }

  (void) ResolveTernaryAddresses (pfx, &ternary);

  pfx->teDepth--;

  if (!pfx->teDepth && *needPopAll) {
    (void) AddAddressingElement (pfx, rZerStk, NULL_ADDRESS);
    *needPopAll = MagickFalse;
  }

  if (pfx->exception->severity != UndefinedException)
    return MagickFalse;

  return MagickTrue;
}


static MagickBooleanType TranslateStatement (FxInfo * pfx, char * strLimit, char * chLimit)
{
  MagickBooleanType NeedPopAll = MagickFalse;

  SkipSpaces (pfx);

  if (!*pfx->pex) return MagickFalse;

  if (!TranslateExpression (pfx, strLimit, chLimit, &NeedPopAll)) {
    return MagickFalse;
  }
  if (pfx->usedElements && *chLimit==';') {
    /* FIXME: not necessarily the last element,
       but the last _executed_ element, eg "goto" in a "for()"., 
       Pending a fix, we will use rZerStk.
    */
    ElementT * pel = &pfx->Elements[pfx->usedElements-1];
    if (pel->DoPush) pel->DoPush = MagickFalse;
  }

  return MagickTrue;
}

static MagickBooleanType TranslateStatementList (FxInfo * pfx, const char * strLimit, char * chLimit)
{
#define MAX_SLIMIT 10
  char sLimits[MAX_SLIMIT];
  SkipSpaces (pfx);

  if (!*pfx->pex) return MagickFalse;
  (void) CopyMagickString (sLimits, strLimit, MAX_SLIMIT-1);

  if (strchr(strLimit,';')==NULL)
    (void) ConcatenateMagickString (sLimits, ";", MAX_SLIMIT);

  for (;;) {
    if (!TranslateStatement (pfx, sLimits, chLimit)) return MagickFalse;

    if (!*pfx->pex) break;

    if (*chLimit != ';') {
      break;
    }
  }

  if (pfx->exception->severity != UndefinedException)
    return MagickFalse;

  return MagickTrue;
}

/*--------------------------------------------------------------------
   Run-time
*/

static ChannelStatistics *CollectOneImgStats (FxInfo * pfx, Image * img)
{
  int ch;
  ChannelStatistics * cs = GetImageStatistics (img, pfx->exception);
  /* Use RelinquishMagickMemory() somewhere. */

  for (ch=0; ch <= (int) MaxPixelChannels; ch++) {
    cs[ch].mean *= QuantumScale;
    cs[ch].median *= QuantumScale;
    cs[ch].maxima *= QuantumScale;
    cs[ch].minima *= QuantumScale;
    cs[ch].standard_deviation *= QuantumScale;
    cs[ch].kurtosis *= QuantumScale;
    cs[ch].skewness *= QuantumScale;
    cs[ch].entropy *= QuantumScale;
  }

  return cs;
}

static MagickBooleanType CollectStatistics (FxInfo * pfx)
{
  Image * img = GetFirstImageInList (pfx->image);

  size_t imgNum=0;

  pfx->statistics = (ChannelStatistics**) AcquireMagickMemory (pfx->ImgListLen * sizeof (ChannelStatistics *));
  if (!pfx->statistics) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), ResourceLimitFatalError,
      "Statistics", "%lu",
      pfx->ImgListLen);
    return MagickFalse;
  }

  for (;;) {
    pfx->statistics[imgNum] = CollectOneImgStats (pfx, img);

    if (++imgNum == pfx->ImgListLen) break;
    img = GetNextImageInList (img);
    assert (img != (Image *) NULL);
  }
  pfx->GotStats = MagickTrue;

  return MagickTrue;
}

static MagickBooleanType inline PushVal (FxInfo * pfx, fxRtT * pfxrt, fxFltType val, int addr)
{
  if (pfxrt->usedValStack >=pfxrt->numValStack) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "ValStack overflow at addr=", "%i",
      addr);
    return MagickFalse;
  }

  pfxrt->ValStack[pfxrt->usedValStack++] = val;
  return MagickTrue;
}

static inline fxFltType PopVal (FxInfo * pfx, fxRtT * pfxrt, int addr)
{
  if (pfxrt->usedValStack <= 0) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "ValStack underflow at addr=", "%i",
      addr);
    return (fxFltType) 0;
  }

  return pfxrt->ValStack[--pfxrt->usedValStack];
}

static inline fxFltType ImageStat (
  FxInfo * pfx, ssize_t ImgNum, PixelChannel channel, ImgAttrE ia)
{
  ChannelStatistics * cs = NULL;
  fxFltType ret = 0;
  MagickBooleanType NeedRelinq = MagickFalse;

  assert (channel >= 0 && channel <= MaxPixelChannels);

  if (pfx->GotStats) {
    cs = pfx->statistics[ImgNum];
  } else if (pfx->NeedStats) {
    /* If we need more than one statistic per pixel, this is inefficient. */
    cs = CollectOneImgStats (pfx, pfx->Images[ImgNum]);
    NeedRelinq = MagickTrue;
  }

  switch (ia) {
    case aDepth:
      ret = (fxFltType) GetImageDepth (pfx->Images[ImgNum], pfx->exception);
      break;
    case aExtent:
      ret = (fxFltType) GetBlobSize (pfx->image);
      break;
    case aKurtosis:
      ret = cs[channel].kurtosis;
      break;
    case aMaxima:
      ret = cs[channel].maxima;
      break;
    case aMean:
      ret = cs[channel].mean;
      break;
    case aMedian:
      ret = cs[channel].median;
      break;
    case aMinima:
      ret = cs[channel].minima;
      break;
    case aPage:
      /* Do nothing */
      break;
    case aPageX:
      ret = (fxFltType) pfx->Images[ImgNum]->page.x;
      break;
    case aPageY:
      ret = (fxFltType) pfx->Images[ImgNum]->page.y;
      break;
    case aPageWid:
      ret = (fxFltType) pfx->Images[ImgNum]->page.width;
      break;
    case aPageHt:
      ret = (fxFltType) pfx->Images[ImgNum]->page.height;
      break;
    case aPrintsize:
      /* Do nothing */
      break;
    case aPrintsizeX:
      ret = (fxFltType) PerceptibleReciprocal (pfx->Images[ImgNum]->resolution.x)
                        * pfx->Images[ImgNum]->columns;
      break;
    case aPrintsizeY:
      ret = (fxFltType) PerceptibleReciprocal (pfx->Images[ImgNum]->resolution.y)
                        * pfx->Images[ImgNum]->rows;
      break;
    case aQuality:
      ret = (fxFltType) pfx->Images[ImgNum]->quality;
      break;
    case aRes:
      /* Do nothing */
      break;
    case aResX:
      ret = pfx->Images[ImgNum]->resolution.x;
      break;
    case aResY:
      ret = pfx->Images[ImgNum]->resolution.y;
      break;
    case aSkewness:
      ret = cs[channel].skewness;
      break;
    case aStdDev:
      ret = cs[channel].standard_deviation;
      break;
    case aH:
      ret = (fxFltType) pfx->Images[ImgNum]->rows;
      break;
    case aN:
      ret = (fxFltType) pfx->ImgListLen;
      break;
    case aT: /* image index in list */
      ret = (fxFltType) ImgNum;
      break;
    case aW:
      ret = (fxFltType) pfx->Images[ImgNum]->columns;
      break;
    case aZ:
      ret = (fxFltType) GetImageDepth (pfx->Images[ImgNum], pfx->exception);
      break;
    default:
      (void) ThrowMagickException (
        pfx->exception, GetMagickModule(), OptionError,
        "Unknown ia=", "%i",
        ia);
  }
  if (NeedRelinq) cs = (ChannelStatistics *)RelinquishMagickMemory (cs);

  return ret;
}

static fxFltType inline FxGcd (fxFltType x, fxFltType y, const size_t depth)
{
#define FxMaxFunctionDepth  200

  if (x < y)
    return (FxGcd (y, x, depth+1));
  if ((fabs((double) y) < 0.001) || (depth >= FxMaxFunctionDepth))
    return (x);
  return (FxGcd (y, x-y*floor((double) (x/y)), depth+1));
}

static ssize_t inline ChkImgNum (FxInfo * pfx, fxFltType f)
/* Returns -1 if f is too large. */
{
  ssize_t i = (ssize_t) floor ((double) f + 0.5);
  if (i < 0) i += pfx->ImgListLen;
  if (i < 0 || i >= (ssize_t)pfx->ImgListLen) {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "ImgNum", "%lu bad for ImgListLen %lu",
      i, pfx->ImgListLen);
    i = -1;
  }
  return i;
}

#define WHICH_ATTR_CHAN \
  (pel->ChannelQual == NO_CHAN_QUAL) ? CompositePixelChannel : \
  (pel->ChannelQual == THIS_CHANNEL) ? channel : pel->ChannelQual

#define WHICH_NON_ATTR_CHAN \
  (pel->ChannelQual == NO_CHAN_QUAL || \
   pel->ChannelQual == THIS_CHANNEL || \
   pel->ChannelQual == CompositePixelChannel \
  ) ? (channel == CompositePixelChannel ? RedPixelChannel: channel) \
    : pel->ChannelQual

static fxFltType GetHslFlt (FxInfo * pfx, ssize_t ImgNum, const fxFltType fx, const fxFltType fy,
  int channel)
{
  Image * img = pfx->Images[ImgNum];

  double red, green, blue;
  double hue=0, saturation=0, lightness=0;

  MagickBooleanType okay = MagickTrue;
  if(!InterpolatePixelChannel (img, pfx->Imgs[ImgNum].View, RedPixelChannel, img->interpolate,
    (double) fx, (double) fy, &red, pfx->exception)) okay = MagickFalse;
  if(!InterpolatePixelChannel (img, pfx->Imgs[ImgNum].View, GreenPixelChannel, img->interpolate,
    (double) fx, (double) fy, &green, pfx->exception)) okay = MagickFalse;
  if(!InterpolatePixelChannel (img, pfx->Imgs[ImgNum].View, BluePixelChannel, img->interpolate,
    (double) fx, (double) fy, &blue, pfx->exception)) okay = MagickFalse;

  if (!okay)
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "GetHslFlt failure", "%lu %Lg,%Lg %i", ImgNum, fx, fy, channel);

  ConvertRGBToHSL (
    red, green, blue,
    &hue, &saturation, &lightness);

  if (channel == HUE_CHANNEL)   return hue;
  if (channel == SAT_CHANNEL)   return saturation;
  if (channel == LIGHT_CHANNEL) return lightness;

  return 0.0;
}

static fxFltType GetHslInt (FxInfo * pfx, ssize_t ImgNum, const ssize_t imgx, const ssize_t imgy, int channel)
{
  Image * img = pfx->Images[ImgNum];

  double hue=0, saturation=0, lightness=0;

  const Quantum * p = GetCacheViewVirtualPixels (pfx->Imgs[ImgNum].View, imgx, imgy, 1, 1, pfx->exception);
  if (!p)
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "GetHslInt failure", "%lu %li,%li %i", ImgNum, imgx, imgy, channel);

  ConvertRGBToHSL (
    GetPixelRed (img, p), GetPixelGreen (img, p), GetPixelBlue (img, p),
    &hue, &saturation, &lightness);

  if (channel == HUE_CHANNEL)   return hue;
  if (channel == SAT_CHANNEL)   return saturation;
  if (channel == LIGHT_CHANNEL) return lightness;

  return 0.0;
}

static fxFltType inline GetIntensity (FxInfo * pfx, ssize_t ImgNum, const fxFltType fx, const fxFltType fy)
{
  Quantum
    quantum_pixel[MaxPixelChannels];

  PixelInfo
    pixelinf;

  Image * img = pfx->Images[ImgNum];

  (void) GetPixelInfo (img, &pixelinf);

  if (!InterpolatePixelInfo (img, pfx->Imgs[pfx->ImgNum].View, img->interpolate,
              (double) fx, (double) fy, &pixelinf, pfx->exception))
  {
    (void) ThrowMagickException (
      pfx->exception, GetMagickModule(), OptionError,
      "GetIntensity failure", "%lu %Lg,%Lg", ImgNum, fx, fy);
  }

  SetPixelViaPixelInfo (img, &pixelinf, quantum_pixel);
  return QuantumScale * GetPixelIntensity (img, quantum_pixel);
}

static MagickBooleanType ExecuteRPN (FxInfo * pfx, fxRtT * pfxrt, fxFltType *result,
  const PixelChannel channel, const ssize_t imgx, const ssize_t imgy)
{
  const Quantum * p = pfxrt->thisPixel;
  fxFltType regA=0, regB=0, regC=0, regD=0, regE=0;
  Image * img = pfx->image;
  ChannelStatistics * cs = NULL;
  MagickBooleanType NeedRelinq = MagickFalse;
  double hue=0, saturation=0, lightness=0;
  int i;

  /* For -fx, this sets p to ImgNum 0.
     for %[fx:...], this sets p to the currrent image.
     Similarly img.
  */
  if (!p) p = GetCacheViewVirtualPixels (
    pfx->Imgs[pfx->ImgNum].View, imgx, imgy, 1, 1, pfx->exception);

  if (pfx->GotStats) {
    cs = pfx->statistics[pfx->ImgNum];
  } else if (pfx->NeedStats) {
    cs = CollectOneImgStats (pfx, pfx->Images[pfx->ImgNum]);
    NeedRelinq = MagickTrue;
  }

  /*  Folllowing is only for expressions like "saturation", with no image specifier.
  */
  if (pfx->NeedHsl) {
    ConvertRGBToHSL (
      GetPixelRed (img, p), GetPixelGreen (img, p), GetPixelBlue (img, p),
      &hue, &saturation, &lightness);
  }

  for (i=0; i < pfx->usedElements; i++) {
    ElementT *pel = &pfx->Elements[i];
      switch (pel->nArgs) {
        case 0:
          break;
        case 1:
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 2:
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 3:
          regC = PopVal (pfx, pfxrt, i);
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 4:
          regD = PopVal (pfx, pfxrt, i);
          regC = PopVal (pfx, pfxrt, i);
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        case 5:
          regE = PopVal (pfx, pfxrt, i);
          regD = PopVal (pfx, pfxrt, i);
          regC = PopVal (pfx, pfxrt, i);
          regB = PopVal (pfx, pfxrt, i);
          regA = PopVal (pfx, pfxrt, i);
          break;
        default:
          (void) ThrowMagickException (
            pfx->exception, GetMagickModule(), OptionError,
            "Too many args:", "%i", pel->nArgs);
          break;
      }

      switch (pel->oprNum) {
        case oAddEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] += regA);
          break;
        case oSubtractEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] -= regA);
          break;
        case oMultiplyEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] *= regA);
          break;
        case oDivideEq:
          regA = (pfxrt->UserSymVals[pel->EleNdx] *= PerceptibleReciprocal((double)regA));
          break;
        case oPlusPlus:
          regA = pfxrt->UserSymVals[pel->EleNdx]++;
          break;
        case oSubSub:
          regA = pfxrt->UserSymVals[pel->EleNdx]--;
          break;
        case oAdd:
          regA += regB;
          break;
        case oSubtract:
          regA -= regB;
          break;
        case oMultiply:
          regA *= regB;
          break;
        case oDivide:
          regA *= PerceptibleReciprocal((double)regB);
          break;
        case oModulus:
          regA = fmod ((double) regA, fabs(floor((double) regB+0.5)));
          break;
        case oUnaryPlus:
          /* Do nothing. */
          break;
        case oUnaryMinus:
          regA = -regA;
          break;
        case oLshift:
          if ((size_t) (regB+0.5) >= (8*sizeof(size_t)))
            {
              (void) ThrowMagickException ( pfx->exception, GetMagickModule(),
                OptionError, "undefined shift", "%g", (double) regB);
              regA = (fxFltType) 0.0;
              break;
            }
          regA = (fxFltType) ((size_t)(regA+0.5) << (size_t)(regB+0.5));
          break;
        case oRshift:
          if ((size_t) (regB+0.5) >= (8*sizeof(size_t)))
            {
              (void) ThrowMagickException ( pfx->exception, GetMagickModule(),
                OptionError, "undefined shift", "%g", (double) regB);
              regA = (fxFltType) 0.0;
              break;
            }
          regA = (fxFltType) ((size_t)(regA+0.5) >> (size_t)(regB+0.5));
          break;
        case oEq:
          regA = fabs((double) (regA-regB)) < MagickEpsilon ? 1.0 : 0.0;
          break;
        case oNotEq:
          regA = fabs((double) (regA-regB)) >= MagickEpsilon ? 1.0 : 0.0;
          break;
        case oLtEq:
          regA = (regA <= regB) ? 1.0 : 0.0;
          break;
        case oGtEq:
          regA = (regA >= regB) ? 1.0 : 0.0;
          break;
        case oLt:
          regA = (regA < regB) ? 1.0 : 0.0;
          break;
        case oGt:
          regA = (regA > regB) ? 1.0 : 0.0;
          break;
        case oLogAnd:
          regA = (regA<=0) ? 0.0 : (regB > 0) ? 1.0 : 0.0;
          break;
        case oLogOr:
          regA = (regA>0) ? 1.0 : (regB > 0.0) ? 1.0 : 0.0;
          break;
        case oLogNot:
          regA = (regA==0) ? 1.0 : 0.0;
          break;
        case oBitAnd:
          regA = (fxFltType) ((size_t)(regA+0.5) & (size_t)(regB+0.5));
          break;
        case oBitOr:
          regA = (fxFltType) ((size_t)(regA+0.5) | (size_t)(regB+0.5));
          break;
        case oBitNot:
          /* Old fx doesn't add 0.5. */
          regA = (fxFltType) (~(size_t)(regA+0.5));
          break;
        case oPow:
          regA = pow ((double) regA, (double) regB);
          break;
        case oQuery:
        case oColon:
          break;
        case oOpenParen:
        case oCloseParen:
        case oOpenBracket:
        case oCloseBracket:
        case oOpenBrace:
        case oCloseBrace:
          break;
        case oAssign:
          pel->val = regA;
          break;
        case oNull: {
          if (pel->type == etColourConstant) {
            switch (channel) {
              default:
              case 0:
                regA = pel->val;
                break;
              case 1:
                regA = pel->val1;
                break;
              case 2:
                regA = pel->val2;
                break;
            }
          } else {
            regA = pel->val;
          }
          break;
        }
        case fAbs:
          regA = fabs ((double) regA);
          break;
#if defined(MAGICKCORE_HAVE_ACOSH)
        case fAcosh:
          regA = acosh ((double) regA);
          break;
#endif
        case fAcos:
          regA = acos ((double) regA);
          break;
#if defined(MAGICKCORE_HAVE_J1)
        case fAiry:
          if (regA==0) regA = 1.0;
          else {
            fxFltType gamma = 2.0 * j1 ((MagickPI*regA)) / (MagickPI*regA);
            regA = gamma * gamma;
          }
          break;
#endif
        case fAlt:
          regA = (fxFltType) (((ssize_t) regA) & 0x01 ? -1.0 : 1.0);
          break;
#if defined(MAGICKCORE_HAVE_ASINH)
        case fAsinh:
          regA = asinh ((double) regA);
          break;
#endif
        case fAsin:
          regA = asin ((double) regA);
          break;
#if defined(MAGICKCORE_HAVE_ATANH)
        case fAtanh:
          regA = atanh ((double) regA);
          break;
#endif
        case fAtan2:
          regA = atan2 ((double) regA, (double) regB);
          break;
        case fAtan:
          regA = atan ((double) regA);
          break;
        case fCeil:
          regA = ceil ((double) regA);
          break;
        case fChannel:
          switch (channel) {
            case 0: break;
            case 1: regA = regB; break;
            case 2: regA = regC; break;
            case 3: regA = regD; break;
            case 4: regA = regE; break;
            default: regA = 0.0;
          }
          break;
        case fClamp:
          if (regA < 0) regA = 0.0;
          else if (regA > 1.0) regA = 1.0;
          break;
        case fCosh:
          regA = cosh ((double) regA);
          break;
        case fCos:
          regA = cos ((double) regA);
          break;
        case fDebug:
          /* FIXME: debug() should give channel name. */

          (void) fprintf (stderr, "%s[%g,%g].[%i]: %s=%.*Lg\n",
                   img->filename, (double) imgx, (double) imgy,
                   channel, SetPtrShortExp (pfx, pel->pExpStart, (size_t) (pel->lenExp+1)),
                   pfx->precision, regA);
          break;
        case fDrc:
          regA = regA / (regB*(regA-1.0) + 1.0);
          break;
#if defined(MAGICKCORE_HAVE_ERF)
        case fErf:
          regA = erf ((double) regA);
          break;
#endif
        case fExp:
          regA = exp ((double) regA);
          break;
        case fFloor:
          regA = floor ((double) regA);
          break;
        case fGauss:
          regA = exp((double) (-regA*regA/2.0))/sqrt(2.0*MagickPI);
          break;
        case fGcd:
          if (!IsNaN(regA)) 
            regA = FxGcd (regA, regB, 0);
          break;
        case fHypot:
          regA = hypot ((double) regA, (double) regB);
          break;
        case fInt:
          regA = floor ((double) regA);
          break;
        case fIsnan:
          regA = (fxFltType) (!!IsNaN (regA));
          break;
#if defined(MAGICKCORE_HAVE_J0)
        case fJ0:
          regA = j0 ((double) regA);
          break;
#endif
#if defined(MAGICKCORE_HAVE_J1)
        case fJ1:
          regA = j1 ((double) regA);
          break;
#endif
#if defined(MAGICKCORE_HAVE_J1)
        case fJinc:
          if (regA==0) regA = 1.0;
          else regA = 2.0 * j1 ((MagickPI*regA))/(MagickPI*regA);
          break;
#endif
        case fLn:
          regA = log ((double) regA);
          break;
        case fLogtwo:
          regA = log10((double) regA) / log10(2.0);
          break;
        case fLog:
          regA = log10 ((double) regA);
          break;
        case fMax:
          regA = (regA > regB) ? regA : regB;
          break;
        case fMin:
          regA = (regA < regB) ? regA : regB;
          break;
        case fMod:
          regA = regA - floor((double) (regA*PerceptibleReciprocal((double) regB)))*regB;
          break;
        case fNot:
          regA = (fxFltType) (regA < MagickEpsilon);
          break;
        case fPow:
          regA = pow ((double) regA, (double) regB);
          break;
        case fRand: {
#if defined(MAGICKCORE_OPENMP_SUPPORT)
          #pragma omp critical (MagickCore_ExecuteRPN)
#endif
          regA = GetPseudoRandomValue (pfxrt->random_info);
          break;
        }
        case fRound:
          regA = floor ((double) regA + 0.5);
          break;
        case fSign:
          regA = (regA < 0) ? -1.0 : 1.0;
          break;
        case fSinc:
          regA = sin ((double) (MagickPI*regA)) / (MagickPI*regA);
          break;
        case fSinh:
          regA = sinh ((double) regA);
          break;
        case fSin:
          regA = sin ((double) regA);
          break;
        case fSqrt:
          regA = sqrt ((double) regA);
          break;
        case fSquish:
          regA = 1.0 / (1.0 + exp ((double) -regA));
          break;
        case fTanh:
          regA = tanh ((double) regA);
          break;
        case fTan:
          regA = tan ((double) regA);
          break;
        case fTrunc:
          if (regA >= 0) regA = floor ((double) regA);
          else regA = ceil ((double) regA);
          break;

        case fDo:
        case fFor:
        case fIf:
        case fWhile:
          break;
        case fU: {
          /* Note: 1 value is available, index into image list.
             May have ImgAttr qualifier or channel qualifier or both.
          */
          ssize_t ImgNum = ChkImgNum (pfx, regA);
          if (ImgNum < 0) break;
          regA = (fxFltType) 0;
          if (ImgNum == 0) {
            Image * pimg = pfx->Images[0];
            int pech = (int)pel->ChannelQual;
            if (pel->ImgAttrQual == aNull) {
              if (pech < 0) {
                if (pech == NO_CHAN_QUAL || pech == THIS_CHANNEL) {
                  if (pfx->ImgNum==0) {
                    regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                  } else {
                    const Quantum * pv = GetCacheViewVirtualPixels (
                                   pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                    if (!pv) {
                      (void) ThrowMagickException (
                        pfx->exception, GetMagickModule(), OptionError,
                        "fU can't get cache", "%lu", ImgNum);
                      break;
                    }
                    regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                  }
                } else if (pech == HUE_CHANNEL || pech == SAT_CHANNEL ||
                    pech == LIGHT_CHANNEL) {
                  regA = GetHslInt (pfx, ImgNum, imgx, imgy, pech);
                  break;
                } else if (pech == INTENSITY_CHANNEL) {
                  regA = GetIntensity (pfx, 0, (double) imgx, (double) imgy);
                  break;
                }
              } else {
                if (pfx->ImgNum==0) {
                  regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                } else {
                  const Quantum * pv = GetCacheViewVirtualPixels (
                                 pfx->Imgs[0].View, imgx, imgy, 1,1, pfx->exception);
                  if (!pv) {
                    (void) ThrowMagickException (
                      pfx->exception, GetMagickModule(), OptionError,
                      "fU can't get cache", "%lu", ImgNum);
                    break;
                  }
                  regA = QuantumScale * pv[pimg->
```

The masked region can be implemented using either of the two snippets below. Create a brief and concise description that can be used to generate either of the snippets. Do not include any securityspecific features in the description.
Snippet 1:
```
  if (fxInfo->OperatorStack[fxInfo->usedOprStack-1] == oQuery) {
    if (ptern->addrQuery != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Already have '?' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    if (ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Already have ':' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    fxInfo->usedOprStack--;
    ptern->addrQuery = fxInfo->usedElements;
    (void) AddAddressingElement (fxInfo, rIfZeroGoto, NULL_ADDRESS);
    /* address will be one after the Colon address. */
  }
  else if (fxInfo->OperatorStack[fxInfo->usedOprStack-1] == oColon) {
    if (ptern->addrQuery == NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Need '?' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    if (ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Already have ':' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    fxInfo->usedOprStack--;
    ptern->addrColon = fxInfo->usedElements;
    fxInfo->Elements[fxInfo->usedElements-1].DoPush = MagickTrue;
    (void) AddAddressingElement (fxInfo, rGoto, NULL_ADDRESS);
    /* address will be after the subexpression */
  }
  return MagickTrue;
```
Snippet 2:
```
  if (fxInfo->usedOprStack == 0)
    return MagickFalse;
  if (fxInfo->OperatorStack[fxInfo->usedOprStack-1] == oQuery) {
    if (ptern->addrQuery != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Already have '?' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    if (ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Already have ':' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    fxInfo->usedOprStack--;
    ptern->addrQuery = fxInfo->usedElements;
    (void) AddAddressingElement (fxInfo, rIfZeroGoto, NULL_ADDRESS);
    /* address will be one after the Colon address. */
  }
  else if (fxInfo->OperatorStack[fxInfo->usedOprStack-1] == oColon) {
    if (ptern->addrQuery == NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Need '?' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    if (ptern->addrColon != NULL_ADDRESS) {
      (void) ThrowMagickException (
        fxInfo->exception, GetMagickModule(), OptionError,
        "Already have ':' in sub-expression at", "'%s'",
        SetShortExp(fxInfo));
      return MagickFalse;
    }
    fxInfo->usedOprStack--;
    ptern->addrColon = fxInfo->usedElements;
    fxInfo->Elements[fxInfo->usedElements-1].DoPush = MagickTrue;
    (void) AddAddressingElement (fxInfo, rGoto, NULL_ADDRESS);
    /* address will be after the subexpression */
  }
  return MagickTrue;
```