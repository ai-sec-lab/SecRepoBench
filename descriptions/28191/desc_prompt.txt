Below is the content of a code file where a code block is masked by `// <MASK>`.
```
-= 1;
        }
    }

    target_count = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_r2_steering_target_count, tvb, offset,
                        1, ENC_NA);
    offset += 1;

    if (target_count > 0) {
        proto_tree *target_list = NULL;
        int target_num = 0;

        target_list = proto_tree_add_subtree(tree, tvb, offset,
                                             9 * target_count,
                                             ett_r2_steering_target_list,
                                             NULL, "Target BSS list");
        while (target_num < target_count) {
            proto_tree *target = NULL;

            target = proto_tree_add_subtree_format(target_list, tvb, offset, 9,
                                                   ett_r2_steering_target,
                                                   NULL, "Target BSS %u",
                                                   target_num);

            proto_tree_add_item(target, hf_ieee1905_r2_steering_target_bssid,
                                tvb, offset, 6, ENC_NA);
            offset += 6;

            proto_tree_add_item(target, hf_ieee1905_r2_steering_target_op_class,
                                tvb, offset, 1, ENC_NA);
            offset += 1;

            proto_tree_add_item(target, hf_ieee1905_r2_steering_target_channel,
                                tvb, offset, 1, ENC_NA);
            offset += 1;

            proto_tree_add_item(target, hf_ieee1905_r2_steering_reason, tvb,
                                offset, 1, ENC_NA);
            offset += 1;

            target_num += 1;
        }
    }

    return offset;
}

/*
 * Dissect an Unsuccessful Association Policy TLV:
 */
static int
dissect_unsuccessful_association_policy(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    static int * const capabilities[] = {
      &hf_ieee1905_rpt_unsuccessful_assoc_report,
      NULL,
    };

    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee1905_rpt_unsuccessful_associations,
                           ett_ieee1905_unsuccessful_associations,
                           capabilities, ENC_NA);
    offset++;

    proto_tree_add_item(tree, hf_ieee1905_max_reporting_rate,
                        tvb, offset, 4, ENC_NA);
    offset += 4;

    return offset;
}

/*
 * Dissect a Metric Collection Interval TLV:
 */
static int
dissect_metric_collection_interval(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_metric_collection_interval,
                        tvb, offset, 4, ENC_NA);
    offset += len;

    return offset;
}

/*
 * Dissect a Radio Metrics TLV:
 */
static int
dissect_radio_metrics(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_radio_metrics_radio_id,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(tree, hf_ieee1905_radio_metrics_noise, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee1905_radio_metrics_transmit, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee1905_radio_metrics_receive_self, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee1905_radio_metrics_receive_other, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    return offset;
}

/*
 * Dissect an AP Extended Metrics TLV:
 */
static int
dissect_ap_extended_metrics(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_bssid, tvb,
                        offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_unicast_sent, tvb,
                        offset, 4, ENC_NA);
    offset += 4;

    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_unicast_rcvd,
                        tvb, offset, 4, ENC_NA);
    offset += 4;

    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_multicast_sent,
                        tvb, offset, 4, ENC_NA);
    offset += 4;

    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_multicast_rcvd,
                        tvb, offset, 4, ENC_NA);
    offset += 4;

    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_bcast_sent,
                        tvb, offset, 4, ENC_NA);
    offset += 4;

    proto_tree_add_item(tree, hf_ieee1905_ap_extended_metrics_bcast_rcvd,
                        tvb, offset, 4, ENC_NA);
    offset += 4;

    return offset;
}

/*
 * Dissect an Status Code TLV:
 */
static int
dissect_status_code(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_status_code_status, tvb,
                        offset, 2, ENC_NA);
    offset += 2;

    return offset;
}

/*
 * Dissect a Disassociation Reason Code TLV:
 */
static int
dissect_disassociation_reason_code(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_disassociation_reason_code, tvb,
                        offset, 2, ENC_BIG_ENDIAN);
    offset += 2;

    return offset;
}

/*
 * Dissect a Backhaul STA Radio Capabilitoes TLV:
 */
static int * const backhaul_sta_radio_capa_flags[] = {
    &hf_ieee1905_backhaul_sta_radio_capa_mac_included,
    &hf_ieee1905_backhaul_sta_radio_capa_reserved,
    NULL
};

static int
dissect_backhaul_sta_radio_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint8 mac_addr_included = 0;

    proto_tree_add_item(tree, hf_ieee1905_backhaul_sta_radio_id, tvb, offset,
                        6, ENC_NA);
    offset += 6;

    mac_addr_included = tvb_get_guint8(tvb, offset);
    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee1905_backhaul_sta_radio_capabilities,
                           ett_backhaul_sta_radio_capa_flags,
                           backhaul_sta_radio_capa_flags, ENC_NA);
    offset += 1;

    if (mac_addr_included & 0x80) {
        proto_tree_add_item(tree, hf_ieee1905_backhaul_sta_addr, tvb, offset,
                            6, ENC_NA);
        offset += 6;
    }

    return offset;
}

/*
 * Dissect an AKM Suite Capabilities TLV:
 */
static int
dissect_akm_suite_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint8 backhaul_akm_suite_count = 0;
    guint8 fronthaul_akm_suite_count = 0;

    backhaul_akm_suite_count = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_backhaul_akm_suite_capa_count, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    if (backhaul_akm_suite_count > 0) {
        guint8 backhaul_suite_num = 0;
        proto_tree *backhaul_suite_list = NULL;

        backhaul_suite_list = proto_tree_add_subtree(tree, tvb, offset,
                                backhaul_akm_suite_count * 4,
                                ett_backhaul_akm_suite_list, NULL,
                                "Backhaul AKM Suite list");

        while (backhaul_suite_num < backhaul_akm_suite_count) {
            proto_tree *backhaul_akm_suite = NULL;

            backhaul_akm_suite = proto_tree_add_subtree_format(backhaul_suite_list,
                                tvb, offset, 4, ett_backhaul_akm_suite, NULL,
                                "Backhaul AKM Suite %u", backhaul_suite_num++);

            proto_tree_add_item(backhaul_akm_suite,
                                hf_ieee1905_akm_backhaul_suite_oui, tvb,
                                offset, 3, ENC_NA);
            offset += 3;

            proto_tree_add_item(backhaul_akm_suite,
                                hf_ieee1905_akm_backhaul_suite_type, tvb,
                                offset, 1, ENC_NA);
            offset += 1;
        }
    }

    fronthaul_akm_suite_count = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_fronthaul_akm_suite_capa_count, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    if (fronthaul_akm_suite_count > 0) {
        guint8 fronthaul_suite_num = 0;
        proto_tree *fronthaul_suite_list = NULL;

        fronthaul_suite_list = proto_tree_add_subtree(tree, tvb, offset,
                                fronthaul_akm_suite_count * 4,
                                ett_fronthaul_akm_suite_list, NULL,
                                "Fronthaul AKM Suite list");

        while (fronthaul_suite_num < fronthaul_akm_suite_count) {
            proto_tree *fronthaul_akm_suite = NULL;

            fronthaul_akm_suite = proto_tree_add_subtree_format(fronthaul_suite_list,
                                tvb, offset, 4, ett_fronthaul_akm_suite, NULL,
                                "Fronthaul AKM Suite %u", fronthaul_suite_num++);

            proto_tree_add_item(fronthaul_akm_suite,
                                hf_ieee1905_akm_fronthaul_suite_oui, tvb,
                                offset, 3, ENC_NA);
            offset += 3;

            proto_tree_add_item(fronthaul_akm_suite,
                                hf_ieee1905_akm_fronthaul_suite_type, tvb,
                                offset, 1, ENC_NA);
            offset += 1;
        }
    }

    return offset;
}

static const true_false_string tfs_dpp_frame_indicator = {
    "GAS frame",
    "DPP public action frame"
};

static int * const ieee1905_encap_dpp_flags[] = {
  &hf_ieee1905_dpp_encap_enrollee_mac_present,
  &hf_ieee1905_dpp_encap_reserved,
  &hf_ieee1905_dpp_encap_frame_type_flag,
  &hf_ieee1905_dpp_encap_reserved2,
  NULL
};

guint
add_ff_action_public_fields(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, guint8 code);

static int
dissect_1905_encap_dpp(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint8 flags = tvb_get_guint8(tvb, offset);
    guint16 frame_length;

    proto_tree_add_bitmask(tree, tvb, offset,
                           hf_ieee1905_encap_dpp_flags,
                           ett_1905_encap_dpp_flags,
                           ieee1905_encap_dpp_flags, ENC_NA);
    offset += 1;

    if (flags & 0x80) { /* Enrollee MAC present */
        proto_tree_add_item(tree, hf_ieee1905_encap_dpp_sta_mac, tvb, offset,
                            6, ENC_NA);
        offset += 6;
    }

    proto_tree_add_item(tree, hf_ieee1905_dpp_encap_frame_type, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    frame_length = tvb_get_ntohs(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_dpp_encap_frame_length, tvb, offset,
                        2, ENC_BIG_ENDIAN);
    offset += 2;

    if (flags & 0x20) {
        guint8 code;
        tvbuff_t *new_tvb;

        code = tvb_get_guint8(tvb, offset);
        proto_tree_add_item(tree, hf_ieee1905_dpp_message_public_action, tvb,
                            offset, 1, ENC_NA);
        offset += 1;

        new_tvb = tvb_new_subset_length(tvb, offset, frame_length - 1);

        add_ff_action_public_fields(tree, new_tvb, pinfo, 0, code);

        offset += frame_length - 1;
    } else {
        tvbuff_t *new_tvb;

        proto_tree_add_item(tree, hf_ieee1905_dpp_encap_public_action, tvb,
                            offset, 1, ENC_NA);
        offset += 1;

        proto_tree_add_item(tree, hf_ieee1905_dpp_encap_dpp_oui, tvb, offset,
                            3, ENC_NA);
        offset += 3;

        proto_tree_add_item(tree, hf_ieee1905_dpp_encap_dpp_subtype, tvb,
                            offset, 1, ENC_NA);
        offset += 1;

        new_tvb = tvb_new_subset_length(tvb, offset, frame_length - 5);
        dissect_wifi_dpp_public_action(new_tvb, pinfo, tree, NULL);

        offset += (frame_length - 5);
    }

    return offset;
}

/*
 * Dissect a 1905 Encap EAPOL TLV:
 */
static int
dissect_1905_encap_eapol(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    offset += call_dissector(eapol_handle,
                             tvb_new_subset_length(tvb, offset, len),
                             pinfo, tree);

    return offset;
}

/*
 * Dissect a DPP Bootstrapping URI Notification TLV:
 */
static int
dissect_dpp_bootstrapping_uri_notification(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint16 uri_len;

    proto_tree_add_item(tree, hf_ieee1905_dpp_bootstrapping_uri_radio_id,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(tree, hf_ieee1905_dpp_bootstrapping_uri_local_mac_addr,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    proto_tree_add_item(tree, hf_ieee1905_dpp_bootstrapping_uri_bsta_mac_addr,
                        tvb, offset, 6, ENC_NA);
    offset += 6;

    /* Assume we got the whole URI */
    uri_len = len - 18;
    proto_tree_add_item(tree, hf_ieee1905_dpp_bootstrapping_uri_received,
                        tvb, offset, uri_len, ENC_ASCII|ENC_NA);
    offset += uri_len;

    return offset;
}

/*
 * Dissect a DPP CCE Indication TLV:
 */
static int
dissect_dpp_cce_indication(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_dpp_advertise_cce_flag, tvb, offset,
                        1, ENC_NA);
    offset += 1;

    return offset;
}

/*
 * Dissect a DPP Chirp Value TLV:
 */
static int * const dpp_chirp_headers[] = {
    &hf_ieee1905_dpp_chirp_enrollee_mac_addr_present,
    &hf_ieee1905_dpp_chirp_hash_validity,
    &hf_ieee1905_dpp_chirp_reserved,
    NULL
};

static const true_false_string tfs_chirp_hash_validity_bit = {
    "Establish DPP authentication state pertaining to this hash value",
    "Purge any DPP authentication state pertaining to this hash value"
};

static int
dissect_dpp_chirp_value(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint8 flags = tvb_get_guint8(tvb, offset);
    guint8 hash_length = 0;

    proto_tree_add_bitmask_with_flags(tree, tvb, offset,
                        hf_ieee1905_dpp_chirp_value_flags,
                        ett_ieee1905_dpp_chirp, dpp_chirp_headers, ENC_NA,
                        BMT_NO_APPEND);
    offset += 1;

    if (flags & 0x80) {
        proto_tree_add_item(tree, hf_ieee1905_dpp_chirp_enrollee_mac_addr, tvb,
                            offset, 6, ENC_NA);
        offset += 6;
    }

    hash_length = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_dpp_chirp_value_hash_length, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    if (hash_length) {
      proto_tree_add_item(tree, hf_ieee1905_dpp_chirp_value_hash_value, tvb,
                          offset, hash_length, ENC_NA);
      offset += hash_length;
    }

    return offset;
}

static int
dissect_device_inventory(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint8 lsn = tvb_get_guint8(tvb, offset);
    guint lsv = 0, lee = 0, num_radios = 0;

    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_lsn, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_serial, tvb, offset,
                        lsn, ENC_ASCII|ENC_NA);
    offset += lsn;

    lsv = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_lsv, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_sw_vers, tvb, offset,
                        lsv, ENC_ASCII|ENC_NA);
    offset += lsv;

    lee = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_lee, tvb, offset, 1,
                        ENC_NA);
    offset += 1;

    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_exec_env, tvb, offset,
                        lee, ENC_ASCII|ENC_NA);
    offset += lee;

    num_radios = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_dev_inventory_num_radios, tvb, offset,
                        1, ENC_NA);
    offset += 1;

    if (num_radios > 0) {
        guint8 radio_id = 0;
        proto_tree *radio_list = NULL;
        proto_item *rli = NULL;
        guint start_list_offset = offset;

        radio_list = proto_tree_add_subtree(tree, tvb, offset, -1,
                                            ett_device_inventory_radio_list,
                                            &rli, "Radio List");

        while (num_radios > 0) {
            guint8 lcv = 0;
            proto_tree *radio_tree = NULL;
            proto_item *rti = NULL;
            guint start_tree_offset = offset;

            radio_tree = proto_tree_add_subtree_format(radio_list, tvb, offset,
                                            -1, ett_device_inventory_radio_tree,
                                            &rti, "Radio %u", radio_id);

            proto_tree_add_item(radio_tree, hf_ieee1905_dev_inventory_radio_id,
                                tvb, offset, 6, ENC_NA);
            offset += 6;

            lcv = tvb_get_guint8(tvb, offset);
            proto_tree_add_item(radio_tree, hf_ieee1905_dev_inventory_lcv, tvb,
                                offset, 1, ENC_NA);
            offset += 1;

            proto_tree_add_item(radio_tree, hf_ieee1905_dev_inventory_chp_ven,
                                tvb, offset, lcv, ENC_ASCII|ENC_NA);
            offset += lcv;

            proto_item_set_len(rti, offset - start_tree_offset);
            num_radios -= 1;
            radio_id += 1;
        }
        proto_item_set_len(rli, offset - start_list_offset);
    }

    return offset;
}

static int
dissect_bss_configuration_request(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_bss_configuration_request, tvb,
                        offset, len, ENC_NA);
    offset += len;

    return offset;
}

static int
dissect_bss_configuration_response(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    proto_tree_add_item(tree, hf_ieee1905_bss_configuration_response, tvb,
                        offset, len, ENC_NA);
    offset += len;

    return offset;
}

static int
dissect_dpp_message(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint16 len _U_)
{
    guint8 code;
    tvbuff_t *new_tvb;

    code = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_ieee1905_dpp_message_public_action, tvb,
                        offset, 1, ENC_NA);
    offset += 1;

    new_tvb = tvb_new_subset_length(tvb, offset, len - 1);

    add_ff_action_public_fields(tree, new_tvb, pinfo, 0, code);

    offset += len -1;

    return offset;
}

/*
 * Dissect each of the TLV types we know about
 */
static int
dissect_ieee1905_tlv_data(tvbuff_t *tvb, packet_info *pinfo _U_,
        proto_tree *tree, guint offset, guint8 tlv_type, guint16 tlv_len)
{
    guint link_metric_query;

    switch (tlv_type) {

    case AL_MAC_ADDRESS_TYPE_TLV:
        proto_tree_add_item(tree, hf_ieee1905_al_mac_address_type, tvb,
                            offset, 6, ENC_NA);
        offset += 6;
        break;

    case MAC_ADDRESS_TYPE_TLV:
        proto_tree_add_item(tree, hf_ieee1905_mac_address_type, tvb,
                            offset, 6, ENC_NA);
        offset += 6;
        break;

    case DEVICE_INFORMATION_TYPE_TLV:
        offset = dissect_device_information_type(tvb, pinfo, tree, offset,
                                tlv_len);
        break;

    case DEVICE_BRIDGING_CAPABILITY_TLV:
        offset = dissect_device_bridging_capabilities(tvb, pinfo, tree,
                                offset, tlv_len);
        break;

    case NON_1905_NEIGHBOR_DEVICE_LIST_TLV:
        offset = dissect_non_1905_neighbor_device_list(tvb, pinfo, tree,
                                offset, tlv_len);
        break;

    case NEIGHBOR_DEVICE_TLV:
        offset = dissect_1905_neighbor_device(tvb, pinfo, tree, offset,
                                tlv_len);
        break;

    case LINK_METRIC_QUERY_TLV:
        proto_tree_add_item_ret_uint(tree,
                                      hf_ieee1905_link_metric_query_type,
                                      tvb, offset, 1, ENC_NA,
                                      &link_metric_query);
        offset++;

        if (link_metric_query) {
            proto_tree_add_item(tree, hf_ieee1905_al_mac_address_type, tvb,
                                offset, 6, ENC_NA);
            offset += 6;
        }

        proto_tree_add_item(tree, hf_ieee1905_link_metrics_requested, tvb,
                            offset, 1, ENC_NA);
        offset++;
        break;

    case TRANSMITTER_LINK_METRIC_TLV:
        offset = dissect_transmitter_link_metric(tvb, pinfo, tree, offset,
                                        tlv_len);
        break;

    case RECEIVER_LINK_METRIC_TLV:
        offset = dissect_receiver_link_metric(tvb, pinfo, tree, offset,
                                        tlv_len);
        break;

    case VENDOR_SPECIFIC_TLV:
        offset = dissect_vendor_specific(tvb, pinfo, tree, offset, tlv_len);
        break;

    case LINK_METRIC_RESULT_CODE_TLV:
        offset = dissect_link_metric_result_code(tvb, pinfo, tree, offset);
        break;

    case SEARCHED_ROLE_TLV:
        offset = dissect_searched_role(tvb, pinfo, tree, offset);
        break;

    case AUTO_CONFIG_FREQ_BAND_TLV:
        offset = dissect_auto_config_freq_band(tvb, pinfo, tree, offset);
        break;

    case SUPPORTED_ROLE_TLV:
        offset = dissect_supported_role(tvb, pinfo, tree, offset);
        break;

    case SUPPORTED_FREQ_BAND_TLV:
        offset = dissect_supported_freq_band(tvb, pinfo, tree, offset);
        break;

    case WSC_TLV:
        offset = dissect_wsc(tvb, pinfo, tree, offset, tlv_len);
        break;

    case PUSH_BUTTON_EVENT_NOTIFICATION_TLV:
        offset = dissect_push_button_event_notification(tvb, pinfo,
                                tree, offset);
        break;

    case PUSH_BUTTON_JOIN_NOTIFICATION_TLV:
        offset = dissect_push_button_join_notification(tvb, pinfo,
                                tree, offset);
        break;

    case GENERIC_PHY_DEVICE_INFORMATION_TLV:
        offset = dissect_generic_phy_device_info(tvb, pinfo, tree,
                                offset);
        break;

    case DEVICE_IDENTIFICATION_TYPE_TLV:
        offset = dissect_device_identification(tvb, pinfo, tree,
                                offset);
        break;

    case CONTROL_URL_TYPE_TLV:
        offset = dissect_control_url_type(tvb, pinfo, tree, offset, tlv_len);
        break;

    case IPV4_TYPE_TLV:
        offset = dissect_ipv4_type(tvb, pinfo, tree, offset);
        break;

    case IPV6_TYPE_TLV:
        offset = dissect_ipv6_type(tvb, pinfo, tree, offset);
        break;

    case PUSH_BUTTON_EVENT_TYPE_NOTIFICATION_TLV:
        offset = dissect_push_button_event_type_notification(tvb, pinfo, tree,
                                offset);
        break;

    case IEEE1905_PROFILE_VERSION_TLV:
        offset = dissect_profile_version(tvb, pinfo, tree, offset);
        break;

    case POWER_OFF_INTERFACE_TLV:
        offset = dissect_power_off_interface(tvb, pinfo, tree, offset);
        break;

    case INTERFACE_POWER_CHANGE_INFORMATION_TLV:
        offset = dissect_interface_power_change_info(tvb, pinfo, tree, offset);
        break;

    case INTERFACE_POWER_CHANGE_STATUS_TLV:
        offset = dissect_interface_power_change_status(tvb, pinfo, tree, offset);
        break;

    case L2_NEIGHBOR_DEVICE_TLV:
        offset = dissect_l2_neighbor_device(tvb, pinfo, tree, offset);
        break;

    case SUPPORTED_SERVICE_TLV:
        offset = dissect_supported_service(tvb, pinfo, tree, offset);
        break;

    case SEARCHED_SERVICE_TLV:
        offset = dissect_searched_service(tvb, pinfo, tree, offset);
        break;

    case AP_RADIO_IDENTIFIER_TLV:
        offset = dissect_ap_radio_identifier(tvb, pinfo, tree, offset);
        break;

    case AP_OPERATIONAL_BSS_TLV:
        offset = dissect_ap_operational_bss(tvb, pinfo, tree, offset);
        break;

    case ASSOCIATED_CLIENTS_TLV:
        offset = dissect_associated_clients(tvb, pinfo, tree, offset);
        break;

    case AP_RADIO_BASIC_CAPABILITIES_TLV:
        offset = dissect_ap_radio_basic_capabilities(tvb, pinfo, tree, offset);
        break;

    case AP_HT_CAPABILITIES_TLV:
        offset = dissect_ap_ht_capabilities(tvb, pinfo, tree, offset);
        break;

    case AP_VHT_CAPABILITIES_TLV:
        offset = dissect_ap_vht_capabilities(tvb, pinfo, tree, offset);
        break;

    case AP_HE_CAPABILITIES_TLV:
        offset = dissect_ap_he_capabilities(tvb, pinfo, tree, offset);
        break;

    case STEERING_POLICY_TLV:
        offset = dissect_steering_policy(tvb, pinfo, tree, offset, tlv_len);
        break;

    case METRIC_REPORTING_POLICY_TLV:
        offset = dissect_metric_reporting_policy(tvb, pinfo, tree, offset);
        break;

    case CHANNEL_PREFERENCE_TLV:
        offset = dissect_channel_preference(tvb, pinfo, tree, offset, tlv_len);
        break;

    case RADIO_OPERATION_RESTRICTION_TLV:
        offset = dissect_radio_operation_restriction(tvb, pinfo, tree, offset,
                                tlv_len);
        break;

    case TRANSMIT_POWER_LIMIT_TLV:
        offset = dissect_transmit_power_limit(tvb, pinfo, tree, offset);
        break;

    case CHANNEL_SELECTION_RESPONSE_TLV:
        offset = dissect_channel_selection_response(tvb, pinfo, tree, offset);
        break;

    case OPERATING_CHANNEL_REPORT_TLV:
        offset = dissect_operating_channel_report(tvb, pinfo, tree, offset);
        break;

    case CLIENT_INFO_TLV:
        offset = dissect_client_info(tvb, pinfo, tree, offset);
        break;

    case CLIENT_CAPABILITY_REPORT_TLV:
        offset = dissect_client_capability_report(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CLIENT_ASSOCIATION_EVENT_TLV:
        offset = dissect_client_association_event(tvb, pinfo, tree, offset);
        break;

    case AP_METRIC_QUERY_TLV:
        offset = dissect_ap_metric_query(tvb, pinfo, tree, offset, tlv_len);
        break;

    case AP_METRICS_TLV:
        offset = dissect_ap_metrics(tvb, pinfo, tree, offset, tlv_len);
        break;

    case STA_MAC_ADDRESS_TYPE_TLV:
        offset = dissect_sta_mac_address_type(tvb, pinfo, tree, offset, tlv_len);
        break;

    case ASSOCIATED_STA_LINK_METRICS_TLV:
        offset = dissect_associated_sta_link_metrics(tvb, pinfo, tree, offset,
                                                     tlv_len);
        break;

    case UNASSOCIATED_STA_LINK_METRICS_QUERY_TLV:
        offset = dissect_unassociated_sta_link_metrics_query(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case UNASSOCIATED_STA_LINK_METRICS_RESPONSE_TLV:
        offset = dissect_unassociated_sta_link_metric_response(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case BEACON_METRICS_QUERY_TLV:
        offset = dissect_beacon_metrics_query(tvb, pinfo, tree, offset, tlv_len);
        break;

    case BEACON_METRICS_RESPONSE_TLV:
        offset = dissect_beacon_metrics_response(tvb, pinfo, tree, offset, tlv_len);
        break;

    case STEERING_REQUEST_TLV:
        offset = dissect_steering_request(tvb, pinfo, tree, offset, tlv_len);
        break;

    case STEERING_BTM_REPORT_TLV:
        offset = dissect_steering_btm_report(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CLIENT_ASSOCIATION_CONTROL_REQUEST_TLV:
        offset = dissect_client_association_control_request(tvb, pinfo, tree, offset);
        break;

    case BACKHAUL_STEERING_REQUEST_TLV:
        offset = dissect_backhaul_steering_request(tvb, pinfo, tree, offset);
        break;

    case BACKHAUL_STEERING_RESPONSE_TLV:
        offset = dissect_backhaul_steering_response(tvb, pinfo, tree, offset);
        break;

    case HIGHER_LAYER_DATA_TLV:
        offset = dissect_higher_layer_data(tvb, pinfo, tree, offset, tlv_len);
        break;

    case AP_CAPABILITY_TLV:
        offset = dissect_ap_capability(tvb, pinfo, tree, offset);
        break;

    case ASSOCIATED_STA_TRAFFIC_STATS_TLV:
        offset = dissect_associated_sta_traffic_stats(tvb, pinfo, tree, offset, tlv_len);
        break;

    case ERROR_CODE_TLV:
        offset = dissect_error_code(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CHANNEL_SCAN_REPORTING_POLICY_TLV:
        offset = dissect_channel_scan_reporting_policy(tvb, pinfo, tree,
                                                       offset, tlv_len);
        break;

    case CHANNEL_SCAN_CAPABILITIES_TLV:
        offset = dissect_channel_scan_capabilities(tvb, pinfo, tree, offset,
                                                   tlv_len);
        break;

    case CHANNEL_SCAN_REQUEST_TLV:
        offset = dissect_channel_scan_request(tvb, pinfo, tree, offset,
                                              tlv_len);
        break;

    case CHANNEL_SCAN_RESULT_TLV:
        offset = dissect_channel_scan_result(tvb, pinfo, tree, offset, tlv_len);
        break;

    case TIMESTAMP_TLV:
        offset = dissect_timestamp(tvb, pinfo, tree, offset, tlv_len);
        break;

    case IEEE1905_LAYER_SECURITY_CAPABILITY_TLV:
        offset = dissect_1905_layer_security_capability(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case AP_WF6_CAPABILITIES_TLV:
        offset = dissect_ap_wf6_capabilities(tvb, pinfo, tree, offset, tlv_len);
        break;

    case MIC_TLV:
        offset = dissect_mic(tvb, pinfo, tree, offset, tlv_len);
        break;

    case ENCRYPTED_TLV:
        offset = dissect_encrypted(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CAC_REQUEST_TLV:
        offset = dissect_cac_request(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CAC_TERMINATION_TLV:
        offset = dissect_cac_termination(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CAC_COMPLETION_REPORT_TLV:
        offset = dissect_cac_completion_report(tvb, pinfo, tree, offset,
                                               tlv_len);
        break;

    case ASSOCIATED_WF6_STA_STATUS_REPORT_TLV:
        offset = dissect_associated_wf6_sta_status_report(tvb, pinfo, tree,
                                                          offset, tlv_len);
        break;

    case CAC_STATUS_REPORT_TLV:
        offset = dissect_cac_status_report(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CAC_CAPABILITIES_TLV:
        offset = dissect_cac_capabilities(tvb, pinfo, tree, offset, tlv_len);
        break;

    case MULTI_AP_PROFILE_TLV:
        offset = dissect_multi_ap_version(tvb, pinfo, tree, offset, tlv_len);
        break;

    case PROFILE_2_AP_CAPABILITY_TLV:
        offset = dissect_r2_ap_capability(tvb, pinfo, tree, offset, tlv_len);
        break;

    case DEFAULT_802_1Q_SETTINGS_TLV:
        offset = dissect_default_802_1q_settings(tvb, pinfo, tree, offset,
                                                 tlv_len);
        break;

    case TRAFFIC_SEPARATION_POLICY_TLV:
        offset = dissect_traffic_separation_policy(tvb, pinfo, tree, offset,
                                                   tlv_len);
        break;

    case BSS_CONFIGURATION_REPORT_TLV:
        offset = dissect_bss_configuration_report(tvb, pinfo, tree, offset,
                                                  tlv_len);
        break;

    case BSSID_TLV:
        offset = dissect_bssid(tvb, pinfo, tree, offset, tlv_len);
        break;

    case SERVICE_PRIORITIZATION_RULE_TLV:
        offset = dissect_service_prioritization_rule(tvb, pinfo, tree, offset,
                                                     tlv_len);
        break;

    case DSCP_MAPPING_TABLE_TLV:
        offset = dissect_dscp_mapping_table(tvb, pinfo, tree, offset, tlv_len);
        break;

    case PROFILE_2_ERROR_CODE_ERROR_TLV:
        offset = dissect_r2_error_code(tvb, pinfo, tree, offset, tlv_len);
        break;

    case AP_RADIO_ADVANCED_CAPABILITIES_TLV:
        offset = dissect_ap_radio_advanced_capabilities(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case ASSOCIATION_STATUS_NOTIFICATION_TLV:
        offset = dissect_association_status_notification(tvb, pinfo, tree,
                                                         offset, tlv_len);
        break;

    case SOURCE_INFO_TLV:
        offset = dissect_source_info(tvb, pinfo, tree, offset, tlv_len);
        break;

    case TUNNELED_MESSAGE_TYPE_TLV:
        offset = dissect_tunneled_message_type(tvb, pinfo, tree, offset,
                                                tlv_len);
        break;

    case TUNNELED_TLV:
        offset = dissect_tunneled(tvb, pinfo, tree, offset, tlv_len);
        break;

    case PROFILE_2_STEERING_REQUEST_TLV:
        offset = dissect_r2_steering_request(tvb, pinfo, tree, offset, tlv_len);
        break;

    case UNSUCCESSFUL_ASSOCIATION_POLICY_TLV:
        offset = dissect_unsuccessful_association_policy(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case METRIC_COLLECTION_INTERVAL_TLV:
        offset = dissect_metric_collection_interval(tvb, pinfo, tree, offset,
                                                    tlv_len);
        break;

    case RADIO_METRICS_TLV:
        offset = dissect_radio_metrics(tvb, pinfo, tree, offset, tlv_len);
        break;

    case AP_EXTENDED_METRICS_TLV:
        offset = dissect_ap_extended_metrics(tvb, pinfo, tree, offset, tlv_len);
        break;

    case ASSOCIATED_STA_EXTENDED_LINK_METRICS_TLV:
        offset = dissect_associated_sta_extended_link_metrics(tvb, pinfo, tree,
                                                              offset, tlv_len);
        break;

    case STATUS_CODE_TLV:
        offset = dissect_status_code(tvb, pinfo, tree, offset,
                                                tlv_len);
        break;

    case REASON_CODE_TLV:
        offset = dissect_disassociation_reason_code(tvb, pinfo, tree, offset,
                                                    tlv_len);
        break;

    case BACKHAUL_STA_RADIO_CAPABILITIES_TLV:
        offset = dissect_backhaul_sta_radio_capabilities(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case AKM_SUITE_CAPABILITIES_TLV:
        offset = dissect_akm_suite_capabilities(tvb, pinfo, tree, offset,
                                                tlv_len);
        break;

    case IEEE1905_ENCAP_DPP_TLV:
        offset = dissect_1905_encap_dpp(tvb, pinfo, tree, offset, tlv_len);
        break;

    case IEEE1905_ENCAP_EAPOL_TLV:
        offset = dissect_1905_encap_eapol(tvb, pinfo, tree, offset, tlv_len);
        break;

    case DPP_BOOTSTRAPPING_URI_NOTIFICATION_TLV:
        offset = dissect_dpp_bootstrapping_uri_notification(tvb, pinfo, tree,
                                                            offset, tlv_len);
        break;

    case DPP_CCE_INDICATION_TLV:
        offset = dissect_dpp_cce_indication(tvb, pinfo, tree, offset, tlv_len);
        break;

    case DPP_CHIRP_VALUE_TLV:
        offset = dissect_dpp_chirp_value(tvb, pinfo, tree, offset, tlv_len);
        break;

    case DEVICE_INVENTORY_TLV:
        offset = dissect_device_inventory(tvb, pinfo, tree, offset, tlv_len);
        break;

    case PACKET_FILTERING_POLICY_TLV:
        offset = dissect_packet_filtering_policy(tvb, pinfo, tree, offset,
                                                 tlv_len);
        break;

    case AGENT_LIST_TLV:
        offset = dissect_agent_list(tvb, pinfo, tree, offset, tlv_len);
        break;

    case LOOP_PREVENTION_MECHANISM_SETTING_TLV:
        offset = dissect_loop_prevention_mechanism_setting(tvb, pinfo, tree,
                                                           offset, tlv_len);
        break;

    case LOOP_DETECTION_SEQUENCE_NUMBER_TLV:
        offset = dissect_loop_detection_sequence_number(tvb, pinfo, tree,
                                                        offset, tlv_len);
        break;

    case GROUP_INTEGRITY_KEY_TLV:
        offset = dissect_group_integrity_key(tvb, pinfo, tree, offset, tlv_len);
        break;

    case CAC_STATUS_REQUEST_TLV:
        offset = dissect_cac_status_request(tvb, pinfo, tree, offset, tlv_len);
        break;

    case BSS_CONFIGURATION_REQUEST_TLV:
        offset = dissect_bss_configuration_request(tvb, pinfo, tree, offset,
                                                   tlv_len);
        break;

    case BSS_CONFIGURATION_RESPONSE_TLV:
        offset = dissect_bss_configuration_response(tvb, pinfo, tree, offset,
                                                    tlv_len);
        break;

    case DPP_MESSAGE_TLV:
        offset = dissect_dpp_message(tvb, pinfo, tree, offset, tlv_len);
        break;

    default:
        proto_tree_add_item(tree, hf_ieee1905_tlv_data, tvb, offset, tlv_len, ENC_NA);
        offset += tlv_len;
    }

  return offset;
}

static int * const tlv_len_headers[] = {
    &hf_ieee1905_tlv_len_reserved,
    &hf_ieee1905_tlv_len_length,
    NULL
};

#ifndef min
#define min(a, b) ((a < b) ? a : b)
#endif

static int
dissect_ieee1905_tlvs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
    gboolean eom_seen = 0;
    guint offset = 0;

    while (!eom_seen) {
        guint8 tlv_type;
        guint16 tlv_len;
        proto_item *tlv_tree;

        tlv_type = tvb_get_guint8(tvb, offset);
        eom_seen = (tlv_type == EOM_TLV);
        /*
        * We can only deal with the reported length remaining ATM so take the
        * min of the TLV len and the reported len.
        */
        tlv_len = min(tvb_get_ntohs(tvb, offset + 1),
                    tvb_reported_length_remaining(tvb, offset));

        tlv_tree = proto_tree_add_subtree(tree, tvb, offset, tlv_len + 3,
                                          ett_tlv, NULL, val_to_str_ext(tlv_type,
                                                &ieee1905_tlv_types_vals_ext,
                                                "Unknown: %02x"));

        proto_tree_add_item(tlv_tree, hf_ieee1905_tlv_types, tvb, offset, 1, ENC_NA);
        offset++;

        proto_tree_add_bitmask(tlv_tree, tvb, offset, hf_ieee1905_tlv_len,
                             ett_ieee1905_tlv_len, tlv_len_headers, ENC_BIG_ENDIAN);
        offset += 2;

        if (tlv_len)
            offset = dissect_ieee1905_tlv_data(tvb, pinfo, tlv_tree, offset, tlv_type, tlv_len);
    }
    return offset;
}

static const fragment_items ieee1905_fragment_items = {
    /* Fragment subtrees */
    &ett_ieee1905_fragment,
    &ett_ieee1905_fragments,
    /* Fragment fields */
    &hf_ieee1905_fragments,
    &hf_ieee1905_fragment,
    &hf_ieee1905_fragment_overlap,
    &hf_ieee1905_fragment_overlap_conflicts,
    &hf_ieee1905_fragment_multiple_tails,
    &hf_ieee1905_fragment_too_long_fragment,
    &hf_ieee1905_fragment_error,
    &hf_ieee1905_fragment_count,
    &hf_ieee1905_fragment_reassembled_in,
    &hf_ieee1905_fragment_reassembled_length,
    NULL,
    "IEEE1905 Fragments"
};

typedef struct {
    address src;
    address dst;
    guint32 vlan_id; /* Take the VLAN ID into account */
    guint8 frag_id;
} ieee1905_fragment_key;

static guint
ieee1905_fragment_hash(gconstpointer key_pointer)
{
  // <MASK>
}

static gboolean
ieee1905_fragment_equal(gconstpointer k1, gconstpointer k2)
{
    const ieee1905_fragment_key *key1 =
                        (const ieee1905_fragment_key *)k1;
    const ieee1905_fragment_key *key2 =
                        (const ieee1905_fragment_key *)k2;

    if (!key1 || !key2) {
        return FALSE;
    }

    return (key1->frag_id == key2->frag_id &&
            key1->vlan_id == key2->vlan_id &&
            addresses_equal(&key1->src, &key2->src) &&
            addresses_equal(&key1->src, &key2->src));
}

static gpointer
ieee1905_fragment_temporary_key(const packet_info *pinfo, const guint32 id,
                                const void *data _U_)
{
    ieee1905_fragment_key *key;

    if (pinfo->src.data == NULL || pinfo->dst.data == NULL) {
        return NULL;
    }

    key = g_slice_new(ieee1905_fragment_key);

    key->frag_id = id & 0xFF;
    copy_address_shallow(&key->src, &pinfo->src);
    copy_address_shallow(&key->dst, &pinfo->dst);
    key->vlan_id = pinfo->vlan_id;

    return (gpointer)key;
}

static gpointer
ieee1905_fragment_persistent_key(const packet_info *pinfo, const guint id,
                                 const void *data _U_)
{
    if (pinfo->src.data == NULL || pinfo->dst.data == NULL) {
        return NULL;
    }

    ieee1905_fragment_key *key = g_slice_new(ieee1905_fragment_key);

    key->frag_id = id & 0xFF;
    copy_address(&key->src, &pinfo->src);
    copy_address(&key->dst, &pinfo->dst);
    key->vlan_id = pinfo->vlan_id;

    return (gpointer)key;
}

static void
ieee1905_fragment_free_temporary_key(gpointer ptr)
{
    ieee1905_fragment_key *key = (ieee1905_fragment_key *)ptr;

    g_slice_free(ieee1905_fragment_key, key);
}

static void
ieee1905_fragment_free_persistent_key(gpointer ptr)
{
    ieee1905_fragment_key *key = (ieee1905_fragment_key *)ptr;

    if (key) {
        free_address(&key->src);
        free_address(&key->dst);
        g_slice_free(ieee1905_fragment_key, key);
    }
}

static reassembly_table g_ieee1905_reassembly_table;

const reassembly_table_functions ieee1905_reassembly_table_functions = {
    ieee1905_fragment_hash,
    ieee1905_fragment_equal,
    ieee1905_fragment_temporary_key,
    ieee1905_fragment_persistent_key,
    ieee1905_fragment_free_temporary_key,
    ieee1905_fragment_free_persistent_key,
};

#define LAST_IEEE1905_FRAGMENT 0x80

static int
dissect_ieee1905(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
        void *data _U_)
{
    proto_item *ti;
    proto_tree *ieee1905_tree;
    guint16    message_type;
    guint      offset = 0, next_offset = 0;
    static int * const flag_headers[] = {
        &hf_ieee1905_last_fragment,
        &hf_ieee1905_relay_indicator,
        NULL
    };
    guint16 msg_id = tvb_get_ntohs(tvb, 4);
    guint8 frag_id = tvb_get_guint8(tvb, 6);
    guint8 flags = tvb_get_guint8(tvb, 7);
    tvbuff_t *next_tvb = NULL;

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "ieee1905");

    col_clear(pinfo->cinfo, COL_INFO);

    message_type = tvb_get_ntohs(tvb, 2);

    col_add_str(pinfo->cinfo, COL_INFO,
                val_to_str_ext(message_type, &ieee1905_message_type_vals_ext,
                        "Unknown: %u"));

    ti = proto_tree_add_item(tree, proto_ieee1905, tvb, 0, -1, ENC_NA);

    ieee1905_tree = proto_item_add_subtree(ti, ett_ieee1905);

    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_version, tvb, offset, 1, ENC_NA);
    offset++;

    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_reserved, tvb, offset, 1, ENC_NA);
    offset++;

    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_type, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;

    proto_tree_add_item(ieee1905_tree, hf_ieee1905_message_id, tvb, offset, 2, ENC_BIG_ENDIAN);
    offset += 2;

    proto_tree_add_item(ieee1905_tree, hf_ieee1905_fragment_id, tvb, offset, 1, ENC_NA);
    offset++;

    proto_tree_add_bitmask(ieee1905_tree, tvb, offset, hf_ieee1905_flags,
                           ett_ieee1905_flags, flag_headers, ENC_NA);
    offset++;

    /*
     * Now figure out if it is a fragment and do reassembly. If we have a
     * fragment but not the whole lot, just dissect it as data, otherwise
     * dissect it.
     */
    if ((flags & LAST_IEEE1905_FRAGMENT) && frag_id == 0) {
        next_tvb = tvb_new_subset_remaining(tvb, offset);
        next_offset = dissect_ieee1905_tlvs(next_tvb, pinfo, ieee1905_tree);
    } else {
        gboolean save_fragmented = pinfo->fragmented;
        pinfo->fragmented = TRUE;
        fragment_head *frag_head = NULL;
        guint remaining_length = tvb_reported_length_remaining(tvb, offset);

        pinfo->fragmented = save_fragmented;
        frag_head = fragment_add_seq_check(&g_ieee1905_reassembly_table, tvb,
                                           offset, pinfo,
                                           msg_id, NULL, frag_id,
                                           remaining_length,
                                           (flags & LAST_IEEE1905_FRAGMENT) == 0);

        next_tvb = process_reassembled_data(tvb, offset, pinfo,
                                            "Reassembled Message",
                                            frag_head,
                                            &ieee1905_fragment_items,
                                            NULL, ieee1905_tree);

        if (next_tvb) { /* Reassembled */
            next_offset = dissect_ieee1905_tlvs(next_tvb, pinfo, ieee1905_tree);
        } else {
            col_append_fstr(pinfo->cinfo, COL_INFO,
                            " (Message ID: %u, Fragment ID: %u, VLAN ID: %u)",
                            msg_id, frag_id, pinfo->vlan_id);
            next_tvb = NULL;
            proto_tree_add_item(ieee1905_tree, hf_ieee1905_fragment_data, tvb,
                                offset,
                                tvb_reported_length_remaining(tvb, offset) - 1,
                                ENC_NA);
        }
    }

    if (next_tvb && tvb_reported_length_remaining(next_tvb, next_offset)) {
        proto_item *pi = NULL;

        /* THis shouldn't happen ... */
        pi = proto_tree_add_item(ieee1905_tree, hf_ieee1905_data, next_tvb,
                                 next_offset, -1, ENC_NA);
        expert_add_info(pinfo, pi, &ei_ieee1905_extraneous_data_after_eom);
    }

    return tvb_captured_length(tvb);
}

void
proto_register_ieee1905(void)
{
    static hf_register_info hf[] = {
        { &hf_ieee1905_fragment_data,
          { "Fragment Data", "ieee1905.fragment.data",
            FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},

        { &hf_ieee1905_message_version,
          { "Message version", "ieee1905.message_version",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_message_reserved,
          { "Message reserved", "ieee1905.message_reserved",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_message_type,
          { "Message type", "ieee1905.message_type",
            FT_UINT16, BASE_HEX|BASE_EXT_STRING, &ieee1905_message_type_vals_ext, 0, NULL, HFILL }},

        { &hf_ieee1905_message_id,
          { "Message id", "ieee1905.message_id",
            FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_fragment_id,
          { "Fragment id", "ieee1905.fragment_id",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_flags,
          { "Flags", "ieee1905.flags",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_last_fragment,
          { "Last fragment", "ieee1905.last_fragment",
            FT_BOOLEAN, 8, TFS(&tfs_last_fragment), 0x80, NULL, HFILL }},

        { &hf_ieee1905_relay_indicator,
          { "Relay indicator", "ieee1905.relay_indicator",
            FT_BOOLEAN, 8, TFS(&tfs_relay_indicator), 0x40, NULL, HFILL }},

        { &hf_ieee1905_tlv_types,
          { "TLV type", "ieee1905.tlv_type",
            FT_UINT8, BASE_HEX|BASE_EXT_STRING, &ieee1905_tlv_types_vals_ext, 0, NULL, HFILL }},

        { &hf_ieee1905_tlv_len,
          { "TLV length", "ieee1905.tlv_length",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_tlv_len_reserved,
          { "TLV length reserved", "ieee1905.tlv_length.reserved",
            FT_UINT16, BASE_HEX, NULL, 0xC000, NULL, HFILL }},

        { &hf_ieee1905_tlv_len_length,
          { "TLV length length", "ieee1905.tlv_length.length",
            FT_UINT16, BASE_DEC, NULL, 0x3FFF, NULL, HFILL }},

        { &hf_ieee1905_tlv_data,
          { "TLV data", "ieee1905.tlv_data",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_al_mac_address_type,
          { "1905 AL MAC address type", "ieee1905.1905_al_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_mac_address_type,
          { "MAC address type", "ieee1905.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_link_metric_query_type,
          { "Link metric query type", "ieee1905.link_metric_query_type",
            FT_UINT8, BASE_DEC, VALS(ieee1905_link_metric_query_type_vals),
            0, NULL, HFILL }},

        { &hf_ieee1905_link_metrics_requested,
          { "Link metrics requested", "ieee1905.link_metrics_requested",
            FT_UINT8, BASE_DEC, VALS(ieee1905_link_metrics_requested_vals),
            0, NULL, HFILL }},

        { &hf_ieee1905_responder_al_mac_addr,
          { "Responder MAC address", "ieee1905.responder_al_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_neighbor_al_mac_addr,
          { "Neighbor MAC address", "ieee1905.neighbor_al_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_receiving_al_mac_addr,
          { "Receiving AL MAC address", "ieee1905.receiving_al_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_bridge_flag,
          { "IEEE 802.1 bridge flag", "ieee1905.bridgeFlag",
            FT_UINT8, BASE_DEC, VALS(ieee1905_bridge_flag_vals), 0, NULL, HFILL }},

        { &hf_ieee1905_packet_errors,
          { "Packet errors", "ieee1905.packetErrors",
            FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_transmitted_packets,
          { "Transmitted packets", "ieee1905.transmittedPackets",
            FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_mac_throughput_capacity,
          { "MAC throughput capacity", "ieee1905.macThroughputCapacity",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_link_availability,
          { "Link availability", "ieee1905.linkAvailability",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_phy_rate,
          { "Phy rate", "ieee1905.phyRate",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_packets_received,
          { "Packets received", "ieee1905.packets_received",
            FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_rssi,
          { "RSSI", "ieee1905.rssi",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_interface_count,
          { "Local interface count", "ieee1905.dev_info.local_int_cnt",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_media_type,
          { "Media type", "ieee1905.dev_info.media_type",
            FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_media_type_high,
          { "Media type bits 15 to 8", "ieee1905.media_type.bits_15_to_8",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_media_type_low,
          { "Media type bits 7 to 0", "ieee1905.media_type.bits_7_to_0",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_media_spec_info_len,
          { "Special info length", "ieee1905.dev_info.spec_info_len",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_media_spec_info,
          { "Special info", "ieee1905.dev_info.spec_info",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_bridging_tuples_cnt,
          { "Bridging tuples count", "ieee1905.bridging_info.tuples_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_bridging_mac_address_cnt,
          { "Bridging MAC address count", "ieee1905.bridging_info.mac_addr_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_bridging_mac_address,
          { "Bridging MAC address", "ieee1905.bridging_info.mac_address",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_interface_mac,
          { "Local interface MAC address", "ieee1905.local_intf.mac_address",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_non_1905_neighbor_mac,
          { "Non 1905 neighbor MAC address", "ieee1905.non_1905_neighbor.mac_address",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_neighbor_flags,
          { "IEEE1905 neighbor flags", "ieee1905.neighbor_flags",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_bridges_flag,
          { "IEEE1905 bridges", "ieee1905.bridges",
            FT_BOOLEAN, 8, TFS(&tfs_bridges_flag), 0x80, NULL, HFILL }},

        { &hf_ieee1905_link_metric_result_code,
          { "IEEE1905 link metric result code", "ieee1905.link_metric.result_code",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_vendor_specific_oui,
          { "Vendor specific OUI", "ieee1905.vendor_specific.oui",
            FT_UINT24, BASE_OUI, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_vendor_specific_info,
          { "Vendor specific information", "ieee1905.vendor_specific.info",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_searched_role,
          { "Searched role", "ieee1905.searched_role",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_supported_role,
          { "Supported role", "ieee1905.supported_role",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_auto_config_freq_band,
          { "Auto config frequency band", "ieee1905.auto_config.freq_band",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_supported_freq_band,
          { "Supported frequency band", "ieee1905.supported.freq_band",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_event_notification_media_types,
          { "Media types", "ieee1905.event_notif.media_types",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_sender_al_id,
          { "Sender AL ID", "ieee1905.sender.al_id",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_push_button_event_msg_id,
          { "Push button event message ID", "ieee1905.sender.msg_id",
            FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_sender_joining_interface,
          { "Joining MAC address of sender", "ieee1905.sender.joining_intf",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_new_device_interface,
          { "New device MAC address", "ieee1905.new_device.intf",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_device_al_mac,
          { "1905 device AL MAC address", "ieee1905.device_al_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_oui,
          { "Local interface OUI", "ieee1905.local_intf.oui",
            FT_UINT24, BASE_OUI, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_variant,
          { "Local interface variant index", "ieee1905.local_intf.variant",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_variant_name,
          { "Local interface variant name", "ieee1905.local_intf.variant_name",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_url_count,
          { "Local interface URL octet count", "ieee1905.local_intf.url_byte_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_spec_count,
          { "Local interface media specific count", "ieee1905.local_intf.media_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_url,
          { "Local interface XML description URL", "ieee1905.local_intf.url",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_local_intf_spec,
          { "Local interface media specific info", "ieee1905.local_intf.spec_info",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_dev_id_friendly_name,
          { "Device Id Friendly name", "ieee1905.device_id.friendly_name",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_dev_id_manuf_name,
          { "Device Id Manufacturer name", "ieee1905.device_id.manuf_name",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_dev_id_manuf_model,
          { "Device Id Manufacturer model", "ieee1905.device_id.manuf_model",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_control_url,
          { "Device control URL", "ieee1905.device.control_url",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv4_type_count,
          { "Count of IPv4 entries", "ieee1905.ipv4_type.count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_mac_address,
          { "MAC address", "ieee1905.ipv4_type.mac_address",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv4_addr_count,
          { "IPv4 address count", "ieee1905.ipv4_type.addr_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_addr_type,
          { "IPv4 address type", "ieee1905.ipv4_type.addr_type",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv4_addr,
          { "IPv4 address", "ieee1905.ipv4_type.ipv4_addr",
            FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_dhcp_server,
          { "DHCP server", "ieee1905.ipv4_type.dhcp_server",
            FT_IPv4, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv6_type_count,
          { "Count of IPv6 entries", "ieee1905.ipv6_type.count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv6_addr_count,
          { "IPv4 address count", "ieee1905.ipv6_type.addr_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv6_addr_type,
          { "IPv6 address type", "ieee1905.ipv6_type.addr_type",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv6_addr,
          { "IPv6 address", "ieee1905.ipv6_type.ipv6_addr",
            FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ipv6_dhcp_server,
          { "DHCP server", "ieee1905.ipv6_type.dhcp_server",
            FT_IPv6, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_generic_phy_media_types,
          { "Generic Phy media type count", "ieee1905.button_push.phy_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_profile_version,
          { "1905 profile version type", "ieee1905.profile.version",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_off_intf_count,
          { "Powered off interface count", "ieee1905.power_off.intf_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_change_intf_count,
          { "Power change local interface count", "ieee1905.power_chg.intf_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_change_mac_addr,
          { "Power change interface MAc addr", "ieee1905.power_chg.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_change_state,
          { "Power change requested state", "ieee1905.power_chg.state",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_status_intf_count,
          { "Power status local interface count", "ieee1905.power_sts.intf_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_status_mac_addr,
          { "Power status interface MAc addr", "ieee1905.power_sts.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_power_status_state,
          { "Power change status", "ieee1905.power_sts.state",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_l2_neighbor_intf_count,
          { "L2 neighbor interface count", "ieee1905.l2_neighbor.intf_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_l2_local_intf_mac_addr,
          { "L2 neighbor local interface MAC addr", "ieee1905.l2_neighbor.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_l2_neighbor_dev_count,
          { "L2 neighbor device count", "ieee1905.l2_neighbor.dev_count",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_l2_neighbor_mac_addr,
          { "L2 neighbor interface MAC address", "ieee1905.l2_neighbor.neighbor_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_l2_behind_mac_addr_count,
          { "L2 neighbor behind MAC addr count", "ieee1905.l2_neighbor.neighbor_behind_count",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_l2_behind_mac_addr,
          { "L2 neighbor behind MAC addr", "ieee1905.l2_neighbor.neighbor_behind_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_supported_service_count,
          { "Supported service count", "ieee1905.supported_service.service_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_supported_service,
          { "Supported service", "ieee1905.supported_service.service",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_searched_service_count,
          { "Searched service count", "ieee1905.searched_service.service_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_searched_service,
          { "Searched service", "ieee1905.searched_service.service",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_radio_identifier,
          { "AP radio identifier", "ieee1905.ap_radio_identifier",
           FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_operatonal_bss_radio_count,
          { "AP operational BSS radio count", "ieee1905.ap_bss_radio_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_operational_intf_count,
          { "AP operational interface count", "ieee1905.ap_bss_intf_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_local_intf_mac_addr,
          { "AP operational local interface MAC addr", "ieee1905.ap_bss_local_intf_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_local_intf_ssid_len,
          { "AP operational BSS local interface SSID len", "ieee1905.ap_bss_local_intf_ssid_len",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_local_intf_ssid,
          { "AP operational BSS local interface SSID", "ieee1905.ap_bss_local_intf_ssid",
            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_capabilities_flags,
          { "AP capabilities flags", "ieee1905.ap_capability_flags",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_rpt_unsuccessful_associations,
          { "Report Unsuccessful Associations", "ieee1905.rpt_unsuccessful_assoc",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_unassoc_sta_metrics_oper_flag,
          { "STA link metric reporting operational channels", "ieee1905.link_metric_oper",
            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x80, NULL, HFILL }},

        { &hf_ieee1905_unassoc_sta_metrics_non_oper_flag,
          { "STA link metric reporting non-operational channels", "ieee1905.link_metric_non_oper",
            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x40, NULL, HFILL }},

        { &hf_ieee1905_agent_init_steering,
          { "Agent-initiated RSSI-based Steering", "ieee1905.agent_init_steering",
            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL }},

        { &hf_ieee1905_rpt_unsuccessful_assoc_report,
          { "Unsuccessful Association Attempts", "ieee1905.report_unsuccessful_associations",
            FT_BOOLEAN, 8, TFS(&tfs_ieee1905_report_unsuccessful_association_attempt_flag), 0x80, NULL, HFILL }},

        { &hf_ieee1905_higher_layer_protocol,
          { "Higher layer protocol", "ieee1905.higher_layer_proto",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_higher_layer_data,
          { "Higher layer data", "ieee1905.higher_layer_data",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_assoc_backhaul_station_mac,
          { "Associated backhaul station MAC address", "ieee1905.assoc.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_backhaul_target_bssid,
          { "Target BSS BSSID", "ieee1905.assoc.target_bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_backhaul_steering_status,
          { "Status code", "ieee1905.assoc.status",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_backhaul_operating_class,
          { "Backhaul operating class", "ieee1905.assoc.operating_class",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_backhaul_channel_number,
          { "Backhaul beacon channel number", "ieee1905.assoc.channel_num",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_assoc_bssid,
          { "Target BSSID", "ieee1905.assoc_ctrl.bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_association_control,
          { "Association control", "ieee1905.assoc_ctrl.control",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_association_control_validity,
          { "Request validity period", "ieee1905.assoc_ctrl.validity",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_assoc_sta_count,
          { "STA control list count", "ieee1905.assoc_ctrl.sta_list_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_assoc_mac_addr,
          { "Target STA MAC address", "ieee1905.assoc_ctrl.target_mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_btm_reporter_bssid,
          { "BTM report source BSSID", "ieee1905.btm_report.source_bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_btm_sta_mac_addr,
          { "BTM report target MAC address", "ieee1905.btm_report.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_btm_report_status,
          { "BTM status code", "ieee1905.btm_report.status",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_btm_report_bssid,
          { "BTM target BSSID", "ieee1905.btm_report.target_bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_source_bss_bssid,
          { "Source BSS BSSID", "ieee1905.steering_req.source_bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_request_flags,
          { "Steering request flags", "ieee1905.steering_req.flags",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_op_window,
          { "Steering opportunity window", "ieee1905.steering_req.window",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_request_mode_flag,
          { "Mode", "ieee1905.steering_req.mode",
            FT_BOOLEAN, 8, TFS(&tfs_ieee1905_steering_request_mode_flag), 0x80, NULL, HFILL }},

        { &hf_ieee1905_btm_disassoc_imminent_flag,
          { "BTM disassociation imminent", "ieee1905.steering_req.disassoc_imminent",
            FT_BOOLEAN, 8, TFS(&tfs_ieee1905_btm_disassoc_imminent_flag), 0x40, NULL, HFILL }},

        { &hf_ieee1905_btm_abridged_flag,
          { "BTM abridged", "ieee1905.steering_req.btm_abridged",
            FT_BOOLEAN, 8, TFS(&tfs_ieee1905_btm_abridged_flag), 0x20, NULL, HFILL }},

        { &hf_ieee1905_steering_req_reserved,
          { "Reserved", "ieee1905.steering_req.reserved",
            FT_UINT8, BASE_HEX, NULL, 0x1F, NULL, HFILL }},

        { &hf_ieee1905_steering_btm_disass_timer,
          { "BTM disassociation timer", "ieee1905.steering_req.disass_timer",
            FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_sta_count,
          { "STA list count", "ieee1905.steering_req.sta_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_target_bssid_count,
          { "Target BSSID list count", "ieee1905.steering_req.bssid_count",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_sta_mac,
          { "Target MAC address", "ieee1905.steering_req.target_mac",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_target_bssid,
          { "Target BSSID", "ieee1905.steering_req.target_bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_oper_class,
          { "Target BSS operating class", "ieee1905.steering_req.oper_class",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_steering_req_target_channel,
          { "Target BSS channel number", "ieee1905.steering_req.target_channel",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_bssid,
          { "Client BSSID", "ieee1905.client_info.bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_mac_addr,
          { "Client MAC address", "ieee1905.client_info.mac_addr",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_capability_result,
          { "Result code", "ieee1905.client_capability.result",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_client_capability_frame,
          { "(Re)Association frame body", "ieee1905.client_capability.frame",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_association_flag,
          { "Association event", "ieee1905.assoc_event.assoc_event",
            FT_BOOLEAN, 8, TFS(&tfs_ieee1905_association_event_flag), 0x20, NULL, HFILL }},

        { &hf_ieee1905_association_client_mac_addr,
          { "Client mac address", "ieee1905.assoc_event.client_mac",
            FT_ETHER, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_association_agent_bssid,
          { "Multi-AP agent BSSID", "ieee1905.assoc_event.agent_bssid",
            FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_association_event_flags,
          { "Association event flags", "ieee1905.assoc_event.flags",
            FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_radio_max_bss,
          { "Maximum BSS support", "ieee1905.radio_basic_cap.max_bss",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_radio_classes,
          { "Operating class count", "ieee1905.radio_basic.op_classes",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_radio_class,
          { "Operating class", "ieee1905.radio_basic.op_class",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_radio_eirp,
          { "Maximum transmit power EIRP", "ieee1905.radio_basic.max_power",
            FT_INT8, BASE_DEC|BASE_UNIT_STRING, &units_dbm, 0, NULL, HFILL }},

        { &hf_ieee1905_ap_radio_non_op_count,
          { "Number of non-operable channels", "ieee1905.radio_basic.non_op_channels",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_radio_basic_non_op_channel,
          { "Statically non-operable channel", "ieee1905.radio_basic.non_op_channel",
            FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL }},

        { &hf_ieee1905_max_supported_tx_streams,
          { "Maximum supported Tx spatial streams", "ieee1905.ap_ht.max_tx_streams",
            FT_UINT8, BASE_HEX, VALS(max_supported_tx_streams_vals), 0xC0, NULL, HFILL}},

        { &hf_ieee1905_max_supported_rx_streams,
          { "Maximum supported Rx spatial streams", "ieee1905.ap_ht.max_rx_streams",
            FT_UINT8, BASE_HEX, VALS(max_supported_rx_streams_vals), 0x30, NULL, HFILL}},

        { &hf_ieee1905_short_gi_20mhz_flag,
          { "Short GI support for 20 MHz", "ieee1905.ap_ht.short_gi_20mhz",
            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x08, NULL, HFILL}},

        { &hf_ieee1905_short_gi_40mhz_flag,
          { "Short GI support for 40 MHz", "ieee1905.ap_ht.short_gi_40mhz",
            FT_BOOLEAN, 8, TFS(&tfs_supported_not_supported), 0x04, NULL, HFILL}},

        { &hf_ieee1905_ht_support_40mhz_flag,
          { "HT support for 40MHz", "ieee1905
```

The masked region can be implemented using either of the two snippets below. Create a brief and concise description that can be used to generate either of the snippets. Do not include any securityspecific features in the description.
Snippet 1:
```
    guint hash_val;
    guint8 hash_buf[17];
    const ieee1905_fragment_key *key = (const ieee1905_fragment_key *)key_pointer;

    if (!key || !key->src.data || !key->dst.data) {
        return 0;
    }

    memcpy(hash_buf, key->src.data, 6);
    memcpy(&hash_buf[6], key->dst.data, 6);
    hash_buf[12] = key->frag_id;
    memcpy(&hash_buf[13], &key->vlan_id, 4);
    hash_val = wmem_strong_hash((const guint8 *)hash_buf, 17);
    return hash_val;
```
Snippet 2:
```
    guint hash_val;
    const ieee1905_fragment_key *key = (const ieee1905_fragment_key *)key_pointer;

    if (!key || !key->src.data || !key->dst.data) {
        return 0;
    }

    const guint8 src_len = key->src.len;
    const guint8 dst_len = key->dst.len;
    const guint8 hash_buf_len = src_len + dst_len + sizeof(guint8) + sizeof(guint32);
    guint8* hash_buf = (guint8*)wmem_alloc(wmem_packet_scope(), hash_buf_len);

    memcpy(hash_buf, key->src.data, src_len);
    memcpy(&hash_buf[src_len], key->dst.data, dst_len);
    hash_buf[src_len + dst_len] = key->frag_id;
    memcpy(&hash_buf[src_len + dst_len + sizeof(guint8)], &key->vlan_id, sizeof(guint32));
    hash_val = wmem_strong_hash((const guint8 *)hash_buf, hash_buf_len);
    return hash_val;
```