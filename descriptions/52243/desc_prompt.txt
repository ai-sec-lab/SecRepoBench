Below is the content of a code file where a code block is masked by `// <MASK>`.
```
, ss & 0xffffffff, scnhdr_ext->s_vaddr);
#else
  PUT_SCNHDR_VADDR (abfd, ss, scnhdr_ext->s_vaddr);
#endif

  /* NT wants the size data to be rounded up to the next
     NT_FILE_ALIGNMENT, but zero if it has no content (as in .bss,
     sometimes).  */
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
    {
      if (bfd_pei_p (abfd))
	{
	  ps = scnhdr_int->s_size;
	  ss = 0;
	}
      else
       {
	 ps = 0;
	 ss = scnhdr_int->s_size;
       }
    }
  else
    {
      if (bfd_pei_p (abfd))
	ps = scnhdr_int->s_paddr;
      else
	ps = 0;

      ss = scnhdr_int->s_size;
    }

  PUT_SCNHDR_SIZE (abfd, ss,
		   scnhdr_ext->s_size);

  /* s_paddr in PE is really the virtual size.  */
  PUT_SCNHDR_PADDR (abfd, ps, scnhdr_ext->s_paddr);

  PUT_SCNHDR_SCNPTR (abfd, scnhdr_int->s_scnptr,
		     scnhdr_ext->s_scnptr);
  PUT_SCNHDR_RELPTR (abfd, scnhdr_int->s_relptr,
		     scnhdr_ext->s_relptr);
  PUT_SCNHDR_LNNOPTR (abfd, scnhdr_int->s_lnnoptr,
		      scnhdr_ext->s_lnnoptr);

  {
    /* Extra flags must be set when dealing with PE.  All sections should also
       have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
       .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
       sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
       (this is especially important when dealing with the .idata section since
       the addresses for routines from .dlls must be overwritten).  If .reloc
       section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
       (0x02000000).  Also, the resource data should also be read and
       writable.  */

    /* FIXME: Alignment is also encoded in this field, at least on
       ARM-WINCE.  Although - how do we get the original alignment field
       back ?  */

    typedef struct
    {
      char section_name[SCNNMLEN];
      unsigned long	must_have;
    }
    pe_required_section_flags;

    pe_required_section_flags known_sections [] =
      {
	{ ".arch",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_ALIGN_8BYTES },
	{ ".bss",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".data",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".edata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".idata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".pdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".rdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".reloc", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE },
	{ ".rsrc",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".text" , IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE },
	{ ".tls",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".xdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
      };

    pe_required_section_flags * p;

    /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
       we know exactly what this specific section wants so we remove it
       and then allow the must_have field to add it back in if necessary.
       However, we don't remove IMAGE_SCN_MEM_WRITE flag from .text if the
       default WP_TEXT file flag has been cleared.  WP_TEXT may be cleared
       by ld --enable-auto-import (if auto-import is actually needed),
       by ld --omagic, or by obcopy --writable-text.  */

    for (p = known_sections;
	 p < known_sections + ARRAY_SIZE (known_sections);
	 p++)
      if (memcmp (scnhdr_int->s_name, p->section_name, SCNNMLEN) == 0)
	{
	  if (memcmp (scnhdr_int->s_name, ".text", sizeof ".text")
	      || (bfd_get_file_flags (abfd) & WP_TEXT))
	    scnhdr_int->s_flags &= ~IMAGE_SCN_MEM_WRITE;
	  scnhdr_int->s_flags |= p->must_have;
	  break;
	}

    H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
  }

  if (coff_data (abfd)->link_info
      && ! bfd_link_relocatable (coff_data (abfd)->link_info)
      && ! bfd_link_pic (coff_data (abfd)->link_info)
      && memcmp (scnhdr_int->s_name, ".text", sizeof ".text") == 0)
    {
      /* By inference from looking at MS output, the 32 bit field
	 which is the combination of the number_of_relocs and
	 number_of_linenos is used for the line number count in
	 executables.  A 16-bit field won't do for cc1.  The MS
	 document says that the number of relocs is zero for
	 executables, but the 17-th bit has been observed to be there.
	 Overflow is not an issue: a 4G-line program will overflow a
	 bunch of other fields long before this!  */
      H_PUT_16 (abfd, (scnhdr_int->s_nlnno & 0xffff), scnhdr_ext->s_nlnno);
      H_PUT_16 (abfd, (scnhdr_int->s_nlnno >> 16), scnhdr_ext->s_nreloc);
    }
  else
    {
      if (scnhdr_int->s_nlnno <= 0xffff)
	H_PUT_16 (abfd, scnhdr_int->s_nlnno, scnhdr_ext->s_nlnno);
      else
	{
	  /* xgettext:c-format */
	  _bfd_error_handler (_("%pB: line number overflow: 0x%lx > 0xffff"),
			      abfd, scnhdr_int->s_nlnno);
	  bfd_set_error (bfd_error_file_truncated);
	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nlnno);
	  ret = 0;
	}

      /* Although we could encode 0xffff relocs here, we do not, to be
	 consistent with other parts of bfd. Also it lets us warn, as
	 we should never see 0xffff here w/o having the overflow flag
	 set.  */
      if (scnhdr_int->s_nreloc < 0xffff)
	H_PUT_16 (abfd, scnhdr_int->s_nreloc, scnhdr_ext->s_nreloc);
      else
	{
	  /* PE can deal with large #s of relocs, but not here.  */
	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nreloc);
	  scnhdr_int->s_flags |= IMAGE_SCN_LNK_NRELOC_OVFL;
	  H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
	}
    }
  return ret;
}

void
_bfd_XXi_swap_debugdir_in (bfd * abfd, void * ext1, void * in1)
{
  struct external_IMAGE_DEBUG_DIRECTORY *ext = (struct external_IMAGE_DEBUG_DIRECTORY *) ext1;
  struct internal_IMAGE_DEBUG_DIRECTORY *in = (struct internal_IMAGE_DEBUG_DIRECTORY *) in1;

  in->Characteristics = H_GET_32(abfd, ext->Characteristics);
  in->TimeDateStamp = H_GET_32(abfd, ext->TimeDateStamp);
  in->MajorVersion = H_GET_16(abfd, ext->MajorVersion);
  in->MinorVersion = H_GET_16(abfd, ext->MinorVersion);
  in->Type = H_GET_32(abfd, ext->Type);
  in->SizeOfData = H_GET_32(abfd, ext->SizeOfData);
  in->AddressOfRawData = H_GET_32(abfd, ext->AddressOfRawData);
  in->PointerToRawData = H_GET_32(abfd, ext->PointerToRawData);
}

unsigned int
_bfd_XXi_swap_debugdir_out (bfd * abfd, void * inp, void * extp)
{
  struct external_IMAGE_DEBUG_DIRECTORY *ext = (struct external_IMAGE_DEBUG_DIRECTORY *) extp;
  struct internal_IMAGE_DEBUG_DIRECTORY *in = (struct internal_IMAGE_DEBUG_DIRECTORY *) inp;

  H_PUT_32(abfd, in->Characteristics, ext->Characteristics);
  H_PUT_32(abfd, in->TimeDateStamp, ext->TimeDateStamp);
  H_PUT_16(abfd, in->MajorVersion, ext->MajorVersion);
  H_PUT_16(abfd, in->MinorVersion, ext->MinorVersion);
  H_PUT_32(abfd, in->Type, ext->Type);
  H_PUT_32(abfd, in->SizeOfData, ext->SizeOfData);
  H_PUT_32(abfd, in->AddressOfRawData, ext->AddressOfRawData);
  H_PUT_32(abfd, in->PointerToRawData, ext->PointerToRawData);

  return sizeof (struct external_IMAGE_DEBUG_DIRECTORY);
}

CODEVIEW_INFO *
_bfd_XXi_slurp_codeview_record (bfd * abfd, file_ptr where, unsigned long length, CODEVIEW_INFO *cvinfo,
				char **pdb)
{
  char buffer[256+1];
  bfd_size_type nread;

  if (bfd_seek (abfd, where, SEEK_SET) != 0)
    return NULL;

  if (length <= sizeof (CV_INFO_PDB70) && length <= sizeof (CV_INFO_PDB20))
    return NULL;
  if (length > 256)
    length = 256;
  nread = bfd_bread (buffer, length, abfd);
  if (length != nread)
    return NULL;

  /* Ensure null termination of filename.  */
  memset (buffer + nread, 0, sizeof (buffer) - nread);

  cvinfo->CVSignature = H_GET_32 (abfd, buffer);
  cvinfo->Age = 0;

  if ((cvinfo->CVSignature == CVINFO_PDB70_CVSIGNATURE)
      && (length > sizeof (CV_INFO_PDB70)))
    {
      CV_INFO_PDB70 *cvinfo70 = (CV_INFO_PDB70 *)(buffer);

      cvinfo->Age = H_GET_32(abfd, cvinfo70->Age);

      /* A GUID consists of 4,2,2 byte values in little-endian order, followed
	 by 8 single bytes.  Byte swap them so we can conveniently treat the GUID
	 as 16 bytes in big-endian order.  */
      bfd_putb32 (bfd_getl32 (cvinfo70->Signature), cvinfo->Signature);
      bfd_putb16 (bfd_getl16 (&(cvinfo70->Signature[4])), &(cvinfo->Signature[4]));
      bfd_putb16 (bfd_getl16 (&(cvinfo70->Signature[6])), &(cvinfo->Signature[6]));
      memcpy (&(cvinfo->Signature[8]), &(cvinfo70->Signature[8]), 8);

      cvinfo->SignatureLength = CV_INFO_SIGNATURE_LENGTH;
      /* cvinfo->PdbFileName = cvinfo70->PdbFileName;  */

      if (pdb)
	*pdb = xstrdup (cvinfo70->PdbFileName);

      return cvinfo;
    }
  else if ((cvinfo->CVSignature == CVINFO_PDB20_CVSIGNATURE)
	   && (length > sizeof (CV_INFO_PDB20)))
    {
      CV_INFO_PDB20 *cvinfo20 = (CV_INFO_PDB20 *)(buffer);
      cvinfo->Age = H_GET_32(abfd, cvinfo20->Age);
      memcpy (cvinfo->Signature, cvinfo20->Signature, 4);
      cvinfo->SignatureLength = 4;
      /* cvinfo->PdbFileName = cvinfo20->PdbFileName;  */

      if (pdb)
	*pdb = xstrdup (cvinfo20->PdbFileName);

      return cvinfo;
    }

  return NULL;
}

unsigned int
_bfd_XXi_write_codeview_record (bfd * abfd, file_ptr where, CODEVIEW_INFO *cvinfo,
				const char *pdb)
{
  size_t pdb_len = pdb ? strlen (pdb) : 0;
  const bfd_size_type size = sizeof (CV_INFO_PDB70) + pdb_len + 1;
  bfd_size_type written;
  CV_INFO_PDB70 *cvinfo70;
  char * buffer;

  if (bfd_seek (abfd, where, SEEK_SET) != 0)
    return 0;

  buffer = bfd_malloc (size);
  if (buffer == NULL)
    return 0;

  cvinfo70 = (CV_INFO_PDB70 *) buffer;
  H_PUT_32 (abfd, CVINFO_PDB70_CVSIGNATURE, cvinfo70->CvSignature);

  /* Byte swap the GUID from 16 bytes in big-endian order to 4,2,2 byte values
     in little-endian order, followed by 8 single bytes.  */
  bfd_putl32 (bfd_getb32 (cvinfo->Signature), cvinfo70->Signature);
  bfd_putl16 (bfd_getb16 (&(cvinfo->Signature[4])), &(cvinfo70->Signature[4]));
  bfd_putl16 (bfd_getb16 (&(cvinfo->Signature[6])), &(cvinfo70->Signature[6]));
  memcpy (&(cvinfo70->Signature[8]), &(cvinfo->Signature[8]), 8);

  H_PUT_32 (abfd, cvinfo->Age, cvinfo70->Age);

  if (pdb == NULL)
    cvinfo70->PdbFileName[0] = '\0';
  else
    memcpy (cvinfo70->PdbFileName, pdb, pdb_len + 1);

  written = bfd_bwrite (buffer, size, abfd);

  free (buffer);

  return written == size ? size : 0;
}

static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =
{
  N_("Export Directory [.edata (or where ever we found it)]"),
  N_("Import Directory [parts of .idata]"),
  N_("Resource Directory [.rsrc]"),
  N_("Exception Directory [.pdata]"),
  N_("Security Directory"),
  N_("Base Relocation Directory [.reloc]"),
  N_("Debug Directory"),
  N_("Description Directory"),
  N_("Special Directory"),
  N_("Thread Storage Directory [.tls]"),
  N_("Load Configuration Directory"),
  N_("Bound Import Directory"),
  N_("Import Address Table Directory"),
  N_("Delay Import Directory"),
  N_("CLR Runtime Header"),
  N_("Reserved")
};

static bool
pe_print_idata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data;
  asection *section;
  bfd_signed_vma adj;
  bfd_size_type datasize = 0;
  bfd_size_type dataoff;
  bfd_size_type i;
  int onaline = 20;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  bfd_vma addr;

  addr = extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress;

  if (addr == 0 && extra->DataDirectory[PE_IMPORT_TABLE].Size == 0)
    {
      /* Maybe the extra header isn't there.  Look for the section.  */
      section = bfd_get_section_by_name (abfd, ".idata");
      if (section == NULL)
	return true;

      addr = section->vma;
      datasize = section->size;
      if (datasize == 0)
	return true;
    }
  else
    {
      addr += extra->ImageBase;
      for (section = abfd->sections; section != NULL; section = section->next)
	{
	  datasize = section->size;
	  if (addr >= section->vma && addr < section->vma + datasize)
	    break;
	}

      if (section == NULL)
	{
	  fprintf (file,
		   _("\nThere is an import table, but the section containing it could not be found\n"));
	  return true;
	}
      else if (!(section->flags & SEC_HAS_CONTENTS))
	{
	  fprintf (file,
		   _("\nThere is an import table in %s, but that section has no contents\n"),
		   section->name);
	  return true;
	}
    }

  /* xgettext:c-format */
  fprintf (file, _("\nThere is an import table in %s at 0x%lx\n"),
	   section->name, (unsigned long) addr);

  dataoff = addr - section->vma;

  fprintf (file,
	   _("\nThe Import Tables (interpreted %s section contents)\n"),
	   section->name);
  fprintf (file,
	   _("\
 vma:            Hint    Time      Forward  DLL       First\n\
                 Table   Stamp     Chain    Name      Thunk\n"));

  /* Read the whole section.  Some of the fields might be before dataoff.  */
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  adj = section->vma - extra->ImageBase;

  /* Print all image import descriptors.  */
  for (i = dataoff; i + onaline <= datasize; i += onaline)
    {
      bfd_vma hint_addr;
      bfd_vma time_stamp;
      bfd_vma forward_chain;
      bfd_vma dll_name;
      bfd_vma first_thunk;
      int idx = 0;
      bfd_size_type j;
      char *dll;

      /* Print (i + extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress).  */
      fprintf (file, " %08lx\t", (unsigned long) (i + adj));
      hint_addr = bfd_get_32 (abfd, data + i);
      time_stamp = bfd_get_32 (abfd, data + i + 4);
      forward_chain = bfd_get_32 (abfd, data + i + 8);
      dll_name = bfd_get_32 (abfd, data + i + 12);
      first_thunk = bfd_get_32 (abfd, data + i + 16);

      fprintf (file, "%08lx %08lx %08lx %08lx %08lx\n",
	       (unsigned long) hint_addr,
	       (unsigned long) time_stamp,
	       (unsigned long) forward_chain,
	       (unsigned long) dll_name,
	       (unsigned long) first_thunk);

      if (hint_addr == 0 && first_thunk == 0)
	break;

      if (dll_name - adj >= section->size)
	break;

      dll = (char *) data + dll_name - adj;
      /* PR 17512 file: 078-12277-0.004.  */
      bfd_size_type maxlen = (char *)(data + datasize) - dll - 1;
      fprintf (file, _("\n\tDLL Name: %.*s\n"), (int) maxlen, dll);

      /* PR 21546: When the Hint Address is zero,
	 we try the First Thunk instead.  */
      if (hint_addr == 0)
	hint_addr = first_thunk;

      if (hint_addr != 0 && hint_addr - adj < datasize)
	{
	  bfd_byte *ft_data;
	  asection *ft_section;
	  bfd_vma ft_addr;
	  bfd_size_type ft_datasize;
	  int ft_idx;
	  int ft_allocated;

	  fprintf (file, _("\tvma:  Hint/Ord Member-Name Bound-To\n"));

	  idx = hint_addr - adj;

	  ft_addr = first_thunk + extra->ImageBase;
	  ft_idx = first_thunk - adj;
	  ft_data = data + ft_idx;
	  ft_datasize = datasize - ft_idx;
	  ft_allocated = 0;

	  if (first_thunk != hint_addr)
	    {
	      /* Find the section which contains the first thunk.  */
	      for (ft_section = abfd->sections;
		   ft_section != NULL;
		   ft_section = ft_section->next)
		{
		  if (ft_addr >= ft_section->vma
		      && ft_addr < ft_section->vma + ft_section->size)
		    break;
		}

	      if (ft_section == NULL)
		{
		  fprintf (file,
		       _("\nThere is a first thunk, but the section containing it could not be found\n"));
		  continue;
		}

	      /* Now check to see if this section is the same as our current
		 section.  If it is not then we will have to load its data in.  */
	      if (ft_section != section)
		{
		  ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
		  ft_datasize = ft_section->size - ft_idx;
		  ft_data = (bfd_byte *) bfd_malloc (ft_datasize);
		  if (ft_data == NULL)
		    continue;

		  /* Read ft_datasize bytes starting at offset ft_idx.  */
		  if (!bfd_get_section_contents (abfd, ft_section, ft_data,
						 (bfd_vma) ft_idx, ft_datasize))
		    {
		      free (ft_data);
		      continue;
		    }
		  ft_allocated = 1;
		}
	    }

	  /* Print HintName vector entries.  */
#ifdef COFF_WITH_pex64
	  for (j = 0; idx + j + 8 <= datasize; j += 8)
	    {
	      bfd_size_type amt;
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
	      unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4);

	      if (!member && !member_high)
		break;

	      amt = member - adj;

	      if (HighBitSet (member_high))
		fprintf (file, "\t%lx%08lx\t %4lx%08lx  <none>",
			 member_high, member,
			 WithoutHighBit (member_high), member);
	      /* PR binutils/17512: Handle corrupt PE data.  */
	      else if (amt >= datasize || amt + 2 >= datasize)
		fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + amt);
		  member_name = (char *) data + amt + 2;
		  fprintf (file, "\t%04lx\t %4d  %.*s",member, ordinal,
			   (int) (datasize - (amt + 2)), member_name);
		}

	      /* If the time stamp is not zero, the import address
		 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr
		  && j + 4 <= ft_datasize)
		fprintf (file, "\t%04lx",
			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
	      fprintf (file, "\n");
	    }
#else
	  for (j = 0; idx + j + 4 <= datasize; j += 4)
	    {
	      bfd_size_type amt;
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);

	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */
	      if (member == 0)
		break;

	      amt = member - adj;

	      if (HighBitSet (member))
		fprintf (file, "\t%04lx\t %4lu  <none>",
			 member, WithoutHighBit (member));
	      /* PR binutils/17512: Handle corrupt PE data.  */
	      else if (amt >= datasize || amt + 2 >= datasize)
		fprintf (file, _("\t<corrupt: 0x%04lx>"), member);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + amt);
		  member_name = (char *) data + amt + 2;
		  fprintf (file, "\t%04lx\t %4d  %.*s",
			   member, ordinal,
			   (int) (datasize - (amt + 2)), member_name);
		}

	      /* If the time stamp is not zero, the import address
		 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr
		  && j + 4 <= ft_datasize)
		fprintf (file, "\t%04lx",
			 (unsigned long) bfd_get_32 (abfd, ft_data + j));

	      fprintf (file, "\n");
	    }
#endif
	  if (ft_allocated)
	    free (ft_data);
	}

      fprintf (file, "\n");
    }

  free (data);

  return true;
}

static bool
pe_print_edata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data;
  asection *section;
  bfd_size_type datasize = 0;
  bfd_size_type dataoff;
  bfd_size_type i;
  bfd_vma       adj;
  struct EDT_type
  {
    long export_flags;		/* Reserved - should be zero.  */
    long time_stamp;
    short major_ver;
    short minor_ver;
    bfd_vma name;		/* RVA - relative to image base.  */
    long base;			/* Ordinal base.  */
    unsigned long num_functions;/* Number in the export address table.  */
    unsigned long num_names;	/* Number in the name pointer table.  */
    bfd_vma eat_addr;		/* RVA to the export address table.  */
    bfd_vma npt_addr;		/* RVA to the Export Name Pointer Table.  */
    bfd_vma ot_addr;		/* RVA to the Ordinal Table.  */
  } edt;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  bfd_vma addr;

  addr = extra->DataDirectory[PE_EXPORT_TABLE].VirtualAddress;

  if (addr == 0 && extra->DataDirectory[PE_EXPORT_TABLE].Size == 0)
    {
      /* Maybe the extra header isn't there.  Look for the section.  */
      section = bfd_get_section_by_name (abfd, ".edata");
      if (section == NULL)
	return true;

      addr = section->vma;
      dataoff = 0;
      datasize = section->size;
      if (datasize == 0)
	return true;
    }
  else
    {
      addr += extra->ImageBase;

      for (section = abfd->sections; section != NULL; section = section->next)
	if (addr >= section->vma && addr < section->vma + section->size)
	  break;

      if (section == NULL)
	{
	  fprintf (file,
		   _("\nThere is an export table, but the section containing it could not be found\n"));
	  return true;
	}
      else if (!(section->flags & SEC_HAS_CONTENTS))
	{
	  fprintf (file,
		   _("\nThere is an export table in %s, but that section has no contents\n"),
		   section->name);
	  return true;
	}

      dataoff = addr - section->vma;
      datasize = extra->DataDirectory[PE_EXPORT_TABLE].Size;
      if (dataoff > section->size
	  || datasize > section->size - dataoff)
	{
	  fprintf (file,
		   _("\nThere is an export table in %s, but it does not fit into that section\n"),
		   section->name);
	  return true;
	}
    }

  /* PR 17512: Handle corrupt PE binaries.  */
  if (datasize < 40)
    {
      fprintf (file,
	       /* xgettext:c-format */
	       _("\nThere is an export table in %s, but it is too small (%d)\n"),
	       section->name, (int) datasize);
      return true;
    }

  /* xgettext:c-format */
  fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
	   section->name, (unsigned long) addr);

  data = (bfd_byte *) bfd_malloc (datasize);
  if (data == NULL)
    return false;

  if (! bfd_get_section_contents (abfd, section, data,
				  (file_ptr) dataoff, datasize))
    return false;

  /* Go get Export Directory Table.  */
  edt.export_flags   = bfd_get_32 (abfd, data +	 0);
  edt.time_stamp     = bfd_get_32 (abfd, data +	 4);
  edt.major_ver	     = bfd_get_16 (abfd, data +	 8);
  edt.minor_ver	     = bfd_get_16 (abfd, data + 10);
  edt.name	     = bfd_get_32 (abfd, data + 12);
  edt.base	     = bfd_get_32 (abfd, data + 16);
  edt.num_functions  = bfd_get_32 (abfd, data + 20);
  edt.num_names	     = bfd_get_32 (abfd, data + 24);
  edt.eat_addr	     = bfd_get_32 (abfd, data + 28);
  edt.npt_addr	     = bfd_get_32 (abfd, data + 32);
  edt.ot_addr	     = bfd_get_32 (abfd, data + 36);

  adj = section->vma - extra->ImageBase + dataoff;

  /* Dump the EDT first.  */
  fprintf (file,
	   _("\nThe Export Tables (interpreted %s section contents)\n\n"),
	   section->name);

  fprintf (file,
	   _("Export Flags \t\t\t%lx\n"), (unsigned long) edt.export_flags);

  fprintf (file,
	   _("Time/Date stamp \t\t%lx\n"), (unsigned long) edt.time_stamp);

  fprintf (file,
	   /* xgettext:c-format */
	   _("Major/Minor \t\t\t%d/%d\n"), edt.major_ver, edt.minor_ver);

  fprintf (file,
	   _("Name \t\t\t\t"));
  bfd_fprintf_vma (abfd, file, edt.name);

  if ((edt.name >= adj) && (edt.name < adj + datasize))
    fprintf (file, " %.*s\n",
	     (int) (datasize - (edt.name - adj)),
	     data + edt.name - adj);
  else
    fprintf (file, "(outside .edata section)\n");

  fprintf (file,
	   _("Ordinal Base \t\t\t%ld\n"), edt.base);

  fprintf (file,
	   _("Number in:\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t%08lx\n"),
	   edt.num_functions);

  fprintf (file,
	   _("\t[Name Pointer/Ordinal] Table\t%08lx\n"), edt.num_names);

  fprintf (file,
	   _("Table Addresses\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t"));
  bfd_fprintf_vma (abfd, file, edt.eat_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tName Pointer Table \t\t"));
  bfd_fprintf_vma (abfd, file, edt.npt_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tOrdinal Table \t\t\t"));
  bfd_fprintf_vma (abfd, file, edt.ot_addr);
  fprintf (file, "\n");

  /* The next table to find is the Export Address Table. It's basically
     a list of pointers that either locate a function in this dll, or
     forward the call to another dll. Something like:
      typedef union
      {
	long export_rva;
	long forwarder_rva;
      } export_address_table_entry;  */

  fprintf (file,
	  _("\nExport Address Table -- Ordinal Base %ld\n"),
	  edt.base);

  /* PR 17512: Handle corrupt PE binaries.  */
  /* PR 17512 file: 140-165018-0.004.  */
  if (edt.eat_addr - adj >= datasize
      /* PR 17512: file: 092b1829 */
      || (edt.num_functions + 1) * 4 < edt.num_functions
      || edt.eat_addr - adj + (edt.num_functions + 1) * 4 > datasize)
    fprintf (file, _("\tInvalid Export Address Table rva (0x%lx) or entry count (0x%lx)\n"),
	     (long) edt.eat_addr,
	     (long) edt.num_functions);
  else for (i = 0; i < edt.num_functions; ++i)
    {
      bfd_vma eat_member = bfd_get_32 (abfd,
				       data + edt.eat_addr + (i * 4) - adj);
      if (eat_member == 0)
	continue;

      if (eat_member - adj <= datasize)
	{
	  /* This rva is to a name (forwarding function) in our section.  */
	  /* Should locate a function descriptor.  */
	  fprintf (file,
		   "\t[%4ld] +base[%4ld] %04lx %s -- %.*s\n",
		   (long) i,
		   (long) (i + edt.base),
		   (unsigned long) eat_member,
		   _("Forwarder RVA"),
		   (int)(datasize - (eat_member - adj)),
		   data + eat_member - adj);
	}
      else
	{
	  /* Should locate a function descriptor in the reldata section.  */
	  fprintf (file,
		   "\t[%4ld] +base[%4ld] %04lx %s\n",
		   (long) i,
		   (long) (i + edt.base),
		   (unsigned long) eat_member,
		   _("Export RVA"));
	}
    }

  /* The Export Name Pointer Table is paired with the Export Ordinal Table.  */
  /* Dump them in parallel for clarity.  */
  fprintf (file,
	   _("\n[Ordinal/Name Pointer] Table\n"));

  /* PR 17512: Handle corrupt PE binaries.  */
  if (edt.npt_addr + (edt.num_names * 4) - adj >= datasize
      /* PR 17512: file: bb68816e.  */
      || edt.num_names * 4 < edt.num_names
      || (data + edt.npt_addr - adj) < data)
    /* xgettext:c-format */
    fprintf (file, _("\tInvalid Name Pointer Table rva (0x%lx) or entry count (0x%lx)\n"),
	     (long) edt.npt_addr,
	     (long) edt.num_names);
  /* PR 17512: file: 140-147171-0.004.  */
  else if (edt.ot_addr + (edt.num_names * 2) - adj >= datasize
	   || data + edt.ot_addr - adj < data)
    /* xgettext:c-format */
    fprintf (file, _("\tInvalid Ordinal Table rva (0x%lx) or entry count (0x%lx)\n"),
	     (long) edt.ot_addr,
	     (long) edt.num_names);
  else for (i = 0; i < edt.num_names; ++i)
    {
      bfd_vma  name_ptr;
      bfd_vma  ord;

      ord = bfd_get_16 (abfd, data + edt.ot_addr + (i * 2) - adj);
      name_ptr = bfd_get_32 (abfd, data + edt.npt_addr + (i * 4) - adj);

      if ((name_ptr - adj) >= datasize)
	{
	  /* xgettext:c-format */
	  fprintf (file, _("\t[%4ld] <corrupt offset: %lx>\n"),
		   (long) ord, (long) name_ptr);
	}
      else
	{
	  char * name = (char *) data + name_ptr - adj;

	  fprintf (file, "\t[%4ld] %.*s\n", (long) ord,
		   (int)((char *)(data + datasize) - name), name);
	}
    }

  free (data);

  return true;
}

/* This really is architecture dependent.  On IA-64, a .pdata entry
   consists of three dwords containing relative virtual addresses that
   specify the start and end address of the code range the entry
   covers and the address of the corresponding unwind info data.

   On ARM and SH-4, a compressed PDATA structure is used :
   _IMAGE_CE_RUNTIME_FUNCTION_ENTRY, whereas MIPS is documented to use
   _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY.
   See http://msdn2.microsoft.com/en-us/library/ms253988(VS.80).aspx .

   This is the version for uncompressed data.  */

static bool
pe_print_pdata (bfd * abfd, void * vfile)
{
#if defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64) && !defined(COFF_WITH_peAArch64) && !defined(COFF_WITH_peLoongArch64)
# define PDATA_ROW_SIZE	(3 * 8)
#else
# define PDATA_ROW_SIZE	(5 * 4)
#endif
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = PDATA_ROW_SIZE;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return true;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
	     /* xgettext:c-format */
	     _("warning, .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));
#if defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64) && !defined(COFF_WITH_peAArch64) && !defined(COFF_WITH_peLoongArch64)
  fprintf (file,
	   _(" vma:\t\t\tBegin Address    End Address      Unwind Info\n"));
#else
  fprintf (file, _("\
 vma:\t\tBegin    End      EH       EH       PrologEnd  Exception\n\
     \t\tAddress  Address  Handler  Data     Address    Mask\n"));
#endif

  datasize = section->size;
  if (datasize == 0)
    return true;

  /* PR 17512: file: 002-193900-0.004.  */
  if (datasize < stop)
    {
      /* xgettext:c-format */
      fprintf (file, _("Virtual size of .pdata section (%ld) larger than real size (%ld)\n"),
	       (long) stop, (long) datasize);
      return false;
    }

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma end_addr;
      bfd_vma eh_handler;
      bfd_vma eh_data;
      bfd_vma prolog_end_addr;
#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64) || defined(COFF_WITH_peAArch64) || defined(COFF_WITH_peLoongArch64)
      int em_data;
#endif

      if (i + PDATA_ROW_SIZE > stop)
	break;

      begin_addr      = GET_PDATA_ENTRY (abfd, data + i	    );
      end_addr	      = GET_PDATA_ENTRY (abfd, data + i +  4);
      eh_handler      = GET_PDATA_ENTRY (abfd, data + i +  8);
      eh_data	      = GET_PDATA_ENTRY (abfd, data + i + 12);
      prolog_end_addr = GET_PDATA_ENTRY (abfd, data + i + 16);

      if (begin_addr == 0 && end_addr == 0 && eh_handler == 0
	  && eh_data == 0 && prolog_end_addr == 0)
	/* We are probably into the padding of the section now.  */
	break;

#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64) || defined(COFF_WITH_peAArch64) || defined(COFF_WITH_peLoongArch64)
      em_data = ((eh_handler & 0x1) << 2) | (prolog_end_addr & 0x3);
#endif
      eh_handler &= ~(bfd_vma) 0x3;
      prolog_end_addr &= ~(bfd_vma) 0x3;

      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, end_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, eh_handler);
#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64) || defined(COFF_WITH_peAArch64) || defined(COFF_WITH_peLoongArch64)
      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, eh_data); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, prolog_end_addr);
      fprintf (file, "   %x", em_data);
#endif
      fprintf (file, "\n");
    }

  free (data);

  return true;
#undef PDATA_ROW_SIZE
}

typedef struct sym_cache
{
  int	     symcount;
  asymbol ** syms;
} sym_cache;

static asymbol **
slurp_symtab (bfd *abfd, sym_cache *psc)
{
  asymbol ** sy = NULL;
  long storage;

  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      psc->symcount = 0;
      return NULL;
    }

  storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    return NULL;
  if (storage)
    {
      sy = (asymbol **) bfd_malloc (storage);
      if (sy == NULL)
	return NULL;
    }

  psc->symcount = bfd_canonicalize_symtab (abfd, sy);
  if (psc->symcount < 0)
    return NULL;
  return sy;
}

static const char *
my_symbol_for_address (bfd *abfd, bfd_vma func, sym_cache *psc)
{
  int i;

  if (psc->syms == 0)
    psc->syms = slurp_symtab (abfd, psc);

  for (i = 0; i < psc->symcount; i++)
    {
      if (psc->syms[i]->section->vma + psc->syms[i]->value == func)
	return psc->syms[i]->name;
    }

  return NULL;
}

static void
cleanup_syms (sym_cache *psc)
{
  psc->symcount = 0;
  free (psc->syms);
  psc->syms = NULL;
}

/* This is the version for "compressed" pdata.  */

bool
_bfd_XX_print_ce_compressed_pdata (bfd * abfd, void * file_ptr)
{
  // <MASK>
}


#define IMAGE_REL_BASED_HIGHADJ 4
static const char * const tbl[] =
{
  "ABSOLUTE",
  "HIGH",
  "LOW",
  "HIGHLOW",
  "HIGHADJ",
  "MIPS_JMPADDR",
  "SECTION",
  "REL32",
  "RESERVED1",
  "MIPS_JMPADDR16",
  "DIR64",
  "HIGH3ADJ",
  "UNKNOWN",   /* MUST be last.  */
};

static bool
pe_print_reloc (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".reloc");
  bfd_byte *p, *end;

  if (section == NULL || section->size == 0 || !(section->flags & SEC_HAS_CONTENTS))
    return true;

  fprintf (file,
	   _("\n\nPE File Base Relocations (interpreted .reloc section contents)\n"));

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  p = data;
  end = data + section->size;
  while (p + 8 <= end)
    {
      int j;
      bfd_vma virtual_address;
      unsigned long number, size;
      bfd_byte *chunk_end;

      /* The .reloc section is a sequence of blocks, with a header consisting
	 of two 32 bit quantities, followed by a number of 16 bit entries.  */
      virtual_address = bfd_get_32 (abfd, p);
      size = bfd_get_32 (abfd, p + 4);
      p += 8;
      number = (size - 8) / 2;

      if (size == 0)
	break;

      fprintf (file,
	       /* xgettext:c-format */
	       _("\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"),
	       (unsigned long) virtual_address, size, size, number);

      chunk_end = p - 8 + size;
      if (chunk_end > end)
	chunk_end = end;
      j = 0;
      while (p + 2 <= chunk_end)
	{
	  unsigned short e = bfd_get_16 (abfd, p);
	  unsigned int t = (e & 0xF000) >> 12;
	  int off = e & 0x0FFF;

	  if (t >= sizeof (tbl) / sizeof (tbl[0]))
	    t = (sizeof (tbl) / sizeof (tbl[0])) - 1;

	  fprintf (file,
		   /* xgettext:c-format */
		   _("\treloc %4d offset %4x [%4lx] %s"),
		   j, off, (unsigned long) (off + virtual_address), tbl[t]);

	  p += 2;
	  j++;

	  /* HIGHADJ takes an argument, - the next record *is* the
	     low 16 bits of addend.  */
	  if (t == IMAGE_REL_BASED_HIGHADJ && p + 2 <= chunk_end)
	    {
	      fprintf (file, " (%4x)", (unsigned int) bfd_get_16 (abfd, p));
	      p += 2;
	      j++;
	    }

	  fprintf (file, "\n");
	}
    }

  free (data);

  return true;
}

/* A data structure describing the regions of a .rsrc section.
   Some fields are filled in as the section is parsed.  */

typedef struct rsrc_regions
{
  bfd_byte * section_start;
  bfd_byte * section_end;
  bfd_byte * strings_start;
  bfd_byte * resource_start;
} rsrc_regions;

static bfd_byte *
rsrc_print_resource_directory (FILE * , bfd *, unsigned int, bfd_byte *,
			       rsrc_regions *, bfd_vma);

/* Print the resource entry at DATA, with the text indented by INDENT.
   Recusively calls rsrc_print_resource_directory to print the contents
   of directory entries.
   Returns the address of the end of the data associated with the entry
   or section_end + 1 upon failure.  */

static bfd_byte *
rsrc_print_resource_entries (FILE *file,
			     bfd *abfd,
			     unsigned int indent,
			     bool is_name,
			     bfd_byte *data,
			     rsrc_regions *regions,
			     bfd_vma rva_bias)
{
  unsigned long entry, addr, size;
  bfd_byte * leaf;

  if (data + 8 >= regions->section_end)
    return regions->section_end + 1;

  /* xgettext:c-format */
  fprintf (file, _("%03x %*.s Entry: "), (int)(data - regions->section_start), indent, " ");

  entry = (unsigned long) bfd_get_32 (abfd, data);
  if (is_name)
    {
      bfd_byte * name;

      /* Note - the documentation says that this field is an RVA value
	 but windres appears to produce a section relative offset with
	 the top bit set.  Support both styles for now.  */
      if (HighBitSet (entry))
	name = regions->section_start + WithoutHighBit (entry);
      else
	name = regions->section_start + entry - rva_bias;

      if (name + 2 < regions->section_end && name > regions->section_start)
	{
	  unsigned int len;

	  if (regions->strings_start == NULL)
	    regions->strings_start = name;

	  len = bfd_get_16 (abfd, name);

	  fprintf (file, _("name: [val: %08lx len %d]: "), entry, len);

	  if (name + 2 + len * 2 < regions->section_end)
	    {
	      /* This strange loop is to cope with multibyte characters.  */
	      while (len --)
		{
		  char c;

		  name += 2;
		  c = * name;
		  /* Avoid printing control characters.  */
		  if (c > 0 && c < 32)
		    fprintf (file, "^%c", c + 64);
		  else
		    fprintf (file, "%.1s", name);
		}
	    }
	  else
	    {
	      fprintf (file, _("<corrupt string length: %#x>\n"), len);
	      /* PR binutils/17512: Do not try to continue decoding a
		 corrupted resource section.  It is likely to end up with
		 reams of extraneous output.  FIXME: We could probably
		 continue if we disable the printing of strings...  */
	      return regions->section_end + 1;
	    }
	}
      else
	{
	  fprintf (file, _("<corrupt string offset: %#lx>\n"), entry);
	  return regions->section_end + 1;
	}
    }
  else
    fprintf (file, _("ID: %#08lx"), entry);

  entry = (long) bfd_get_32 (abfd, data + 4);
  fprintf (file, _(", Value: %#08lx\n"), entry);

  if (HighBitSet  (entry))
    {
      data = regions->section_start + WithoutHighBit (entry);
      if (data <= regions->section_start || data > regions->section_end)
	return regions->section_end + 1;

      /* FIXME: PR binutils/17512: A corrupt file could contain a loop
	 in the resource table.  We need some way to detect this.  */
      return rsrc_print_resource_directory (file, abfd, indent + 1, data,
					    regions, rva_bias);
    }

  leaf = regions->section_start + entry;

  if (leaf + 16 >= regions->section_end
      /* PR 17512: file: 055dff7e.  */
      || leaf < regions->section_start)
    return regions->section_end + 1;

  /* xgettext:c-format */
  fprintf (file, _("%03x %*.s  Leaf: Addr: %#08lx, Size: %#08lx, Codepage: %d\n"),
	   (int) (entry), indent, " ",
	   addr = (long) bfd_get_32 (abfd, leaf),
	   size = (long) bfd_get_32 (abfd, leaf + 4),
	   (int) bfd_get_32 (abfd, leaf + 8));

  /* Check that the reserved entry is 0.  */
  if (bfd_get_32 (abfd, leaf + 12) != 0
      /* And that the data address/size is valid too.  */
      || (regions->section_start + (addr - rva_bias) + size > regions->section_end))
    return regions->section_end + 1;

  if (regions->resource_start == NULL)
    regions->resource_start = regions->section_start + (addr - rva_bias);

  return regions->section_start + (addr - rva_bias) + size;
}

#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))

static bfd_byte *
rsrc_print_resource_directory (FILE *	      file,
			       bfd *	      abfd,
			       unsigned int   indent,
			       bfd_byte *     data,
			       rsrc_regions * regions,
			       bfd_vma	      rva_bias)
{
  unsigned int num_names, num_ids;
  bfd_byte * highest_data = data;

  if (data + 16 >= regions->section_end)
    return regions->section_end + 1;

  fprintf (file, "%03x %*.s ", (int)(data - regions->section_start), indent, " ");
  switch (indent)
    {
    case 0: fprintf (file, "Type"); break;
    case 2: fprintf (file, "Name"); break;
    case 4: fprintf (file, "Language"); break;
    default:
      fprintf (file, _("<unknown directory type: %d>\n"), indent);
      /* FIXME: For now we end the printing here.  If in the
	 future more directory types are added to the RSRC spec
	 then we will need to change this.  */
      return regions->section_end + 1;
    }

  /* xgettext:c-format */
  fprintf (file, _(" Table: Char: %d, Time: %08lx, Ver: %d/%d, Num Names: %d, IDs: %d\n"),
	   (int) bfd_get_32 (abfd, data),
	   (long) bfd_get_32 (abfd, data + 4),
	   (int)  bfd_get_16 (abfd, data + 8),
	   (int)  bfd_get_16 (abfd, data + 10),
	   num_names = (int) bfd_get_16 (abfd, data + 12),
	   num_ids =   (int) bfd_get_16 (abfd, data + 14));
  data += 16;

  while (num_names --)
    {
      bfd_byte * entry_end;

      entry_end = rsrc_print_resource_entries (file, abfd, indent + 1, true,
					       data, regions, rva_bias);
      data += 8;
      highest_data = max (highest_data, entry_end);
      if (entry_end >= regions->section_end)
	return entry_end;
    }

  while (num_ids --)
    {
      bfd_byte * entry_end;

      entry_end = rsrc_print_resource_entries (file, abfd, indent + 1, false,
					       data, regions, rva_bias);
      data += 8;
      highest_data = max (highest_data, entry_end);
      if (entry_end >= regions->section_end)
	return entry_end;
    }

  return max (highest_data, data);
}

/* Display the contents of a .rsrc section.  We do not try to
   reproduce the resources, windres does that.  Instead we dump
   the tables in a human readable format.  */

static bool
rsrc_print_section (bfd * abfd, void * vfile)
{
  bfd_vma rva_bias;
  pe_data_type * pe;
  FILE * file = (FILE *) vfile;
  bfd_size_type datasize;
  asection * section;
  bfd_byte * data;
  rsrc_regions regions;

  pe = pe_data (abfd);
  if (pe == NULL)
    return true;

  section = bfd_get_section_by_name (abfd, ".rsrc");
  if (section == NULL)
    return true;
  if (!(section->flags & SEC_HAS_CONTENTS))
    return true;

  datasize = section->size;
  if (datasize == 0)
    return true;

  rva_bias = section->vma - pe->pe_opthdr.ImageBase;

  if (! bfd_malloc_and_get_section (abfd, section, & data))
    {
      free (data);
      return false;
    }

  regions.section_start = data;
  regions.section_end = data + datasize;
  regions.strings_start = NULL;
  regions.resource_start = NULL;

  fflush (file);
  fprintf (file, "\nThe .rsrc Resource Directory section:\n");

  while (data < regions.section_end)
    {
      bfd_byte * p = data;

      data = rsrc_print_resource_directory (file, abfd, 0, data, & regions, rva_bias);

      if (data == regions.section_end + 1)
	fprintf (file, _("Corrupt .rsrc section detected!\n"));
      else
	{
	  /* Align data before continuing.  */
	  int align = (1 << section->alignment_power) - 1;

	  data = (bfd_byte *) (((ptrdiff_t) (data + align)) & ~ align);
	  rva_bias += data - p;

	  /* For reasons that are unclear .rsrc sections are sometimes created
	     aligned to a 1^3 boundary even when their alignment is set at
	     1^2.  Catch that case here before we issue a spurious warning
	     message.  */
	  if (data == (regions.section_end - 4))
	    data = regions.section_end;
	  else if (data < regions.section_end)
	    {
	      /* If the extra data is all zeros then do not complain.
		 This is just padding so that the section meets the
		 page size requirements.  */
	      while (++ data < regions.section_end)
		if (*data != 0)
		  break;
	      if (data < regions.section_end)
		fprintf (file, _("\nWARNING: Extra data in .rsrc section - it will be ignored by Windows:\n"));
	    }
	}
    }

  if (regions.strings_start != NULL)
    fprintf (file, _(" String table starts at offset: %#03x\n"),
	     (int) (regions.strings_start - regions.section_start));
  if (regions.resource_start != NULL)
    fprintf (file, _(" Resources start at offset: %#03x\n"),
	     (int) (regions.resource_start - regions.section_start));

  free (regions.section_start);
  return true;
}

#define IMAGE_NUMBEROF_DEBUG_TYPES 17

static char * debug_type_names[IMAGE_NUMBEROF_DEBUG_TYPES] =
{
  "Unknown",
  "COFF",
  "CodeView",
  "FPO",
  "Misc",
  "Exception",
  "Fixup",
  "OMAP-to-SRC",
  "OMAP-from-SRC",
  "Borland",
  "Reserved",
  "CLSID",
  "Feature",
  "CoffGrp",
  "ILTCG",
  "MPX",
  "Repro",
};

static bool
pe_print_debugdata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
  asection *section;
  bfd_byte *data = 0;
  bfd_size_type dataoff;
  unsigned int i, j;

  bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
  bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;

  if (size == 0)
    return true;

  addr += extra->ImageBase;
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      if ((addr >= section->vma) && (addr < (section->vma + section->size)))
	break;
    }

  if (section == NULL)
    {
      fprintf (file,
	       _("\nThere is a debug directory, but the section containing it could not be found\n"));
      return true;
    }
  else if (!(section->flags & SEC_HAS_CONTENTS))
    {
      fprintf (file,
	       _("\nThere is a debug directory in %s, but that section has no contents\n"),
	       section->name);
      return true;
    }
  else if (section->size < size)
    {
      fprintf (file,
	       _("\nError: section %s contains the debug data starting address but it is too small\n"),
	       section->name);
      return false;
    }

  fprintf (file, _("\nThere is a debug directory in %s at 0x%lx\n\n"),
	   section->name, (unsigned long) addr);

  dataoff = addr - section->vma;

  if (size > (section->size - dataoff))
    {
      fprintf (file, _("The debug data size field in the data directory is too big for the section"));
      return false;
    }

  fprintf (file,
	   _("Type                Size     Rva      Offset\n"));

  /* Read the whole section.  */
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
    {
      const char *type_name;
      struct external_IMAGE_DEBUG_DIRECTORY *ext
	= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];
      struct internal_IMAGE_DEBUG_DIRECTORY idd;

      _bfd_XXi_swap_debugdir_in (abfd, ext, &idd);

      if ((idd.Type) >= IMAGE_NUMBEROF_DEBUG_TYPES)
	type_name = debug_type_names[0];
      else
	type_name = debug_type_names[idd.Type];

      fprintf (file, " %2ld  %14s %08lx %08lx %08lx\n",
	       idd.Type, type_name, idd.SizeOfData,
	       idd.AddressOfRawData, idd.PointerToRawData);

      if (idd.Type == PE_IMAGE_DEBUG_TYPE_CODEVIEW)
	{
	  char signature[CV_INFO_SIGNATURE_LENGTH * 2 + 1];
	  /* PR 17512: file: 065-29434-0.001:0.1
	     We need to use a 32-bit aligned buffer
	     to safely read in a codeview record.  */
	  char buffer[256 + 1] ATTRIBUTE_ALIGNED_ALIGNOF (CODEVIEW_INFO);
	  char *pdb;

	  CODEVIEW_INFO *cvinfo = (CODEVIEW_INFO *) buffer;

	  /* The debug entry doesn't have to have to be in a section,
	     in which case AddressOfRawData is 0, so always use PointerToRawData.  */
	  if (!_bfd_XXi_slurp_codeview_record (abfd, (file_ptr) idd.PointerToRawData,
					       idd.SizeOfData, cvinfo, &pdb))
	    continue;

	  for (j = 0; j < cvinfo->SignatureLength; j++)
	    sprintf (&signature[j*2], "%02x", cvinfo->Signature[j] & 0xff);

	  /* xgettext:c-format */
	  fprintf (file, _("(format %c%c%c%c signature %s age %ld pdb %s)\n"),
		   buffer[0], buffer[1], buffer[2], buffer[3],
		   signature, cvinfo->Age, pdb[0] ? pdb : "(none)");

	  free (pdb);
	}
    }

  free(data);

  if (size % sizeof (struct external_IMAGE_DEBUG_DIRECTORY) != 0)
    fprintf (file,
	    _("The debug directory size is not a multiple of the debug directory entry size\n"));

  return true;
}

static bool
pe_is_repro (bfd * abfd)
{
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
  asection *section;
  bfd_byte *data = 0;
  bfd_size_type dataoff;
  unsigned int i;
  bool res = false;

  bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
  bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;

  if (size == 0)
    return false;

  addr += extra->ImageBase;
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      if ((addr >= section->vma) && (addr < (section->vma + section->size)))
	break;
    }

  if ((section == NULL)
      || (!(section->flags & SEC_HAS_CONTENTS))
      || (section->size < size))
    {
      return false;
    }

  dataoff = addr - section->vma;

  if (size > (section->size - dataoff))
    {
      return false;
    }

  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
    {
      struct external_IMAGE_DEBUG_DIRECTORY *ext
	= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];
      struct internal_IMAGE_DEBUG_DIRECTORY idd;

      _bfd_XXi_swap_debugdir_in (abfd, ext, &idd);

      if (idd.Type == PE_IMAGE_DEBUG_TYPE_REPRO)
        {
          res = true;
          break;
        }
    }

  free(data);

  return res;
}

/* Print out the program headers.  */

bool
_bfd_XX_print_private_bfd_data_common (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  int j;
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *i = &pe->pe_opthdr;
  const char *subsystem_name = NULL;
  const char *name;

  /* The MS dumpbin program reportedly ands with 0xff0f before
     printing the characteristics field.  Not sure why.  No reason to
     emulate it here.  */
  fprintf (file, _("\nCharacteristics 0x%x\n"), pe->real_flags);
#undef PF
#define PF(x, y) if (pe->real_flags & x) { fprintf (file, "\t%s\n", y); }
  PF (IMAGE_FILE_RELOCS_STRIPPED, "relocations stripped");
  PF (IMAGE_FILE_EXECUTABLE_IMAGE, "executable");
  PF (IMAGE_FILE_LINE_NUMS_STRIPPED, "line numbers stripped");
  PF (IMAGE_FILE_LOCAL_SYMS_STRIPPED, "symbols stripped");
  PF (IMAGE_FILE_LARGE_ADDRESS_AWARE, "large address aware");
  PF (IMAGE_FILE_BYTES_REVERSED_LO, "little endian");
  PF (IMAGE_FILE_32BIT_MACHINE, "32 bit words");
  PF (IMAGE_FILE_DEBUG_STRIPPED, "debugging information removed");
  PF (IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP, "copy to swap file if on removable media");
  PF (IMAGE_FILE_NET_RUN_FROM_SWAP, "copy to swap file if on network media");
  PF (IMAGE_FILE_SYSTEM, "system file");
  PF (IMAGE_FILE_DLL, "DLL");
  PF (IMAGE_FILE_UP_SYSTEM_ONLY, "run only on uniprocessor machine");
  PF (IMAGE_FILE_BYTES_REVERSED_HI, "big endian");
#undef PF

  /*
    If a PE_IMAGE_DEBUG_TYPE_REPRO entry is present in the debug directory, the
    timestamp is to be interpreted as the hash of a reproducible build.
  */
  if (pe_is_repro (abfd))
    {
      fprintf (file, "\nTime/Date\t\t%08lx", pe->coff.timestamp);
      fprintf (file, "\t(This is a reproducible build file hash, not a timestamp)\n");
    }
  else
    {
      /* ctime implies '\n'.  */
      time_t t = pe->coff.timestamp;
      fprintf (file, "\nTime/Date\t\t%s", ctime (&t));
    }

#ifndef IMAGE_NT_OPTIONAL_HDR_MAGIC
# define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#endif
#ifndef IMAGE_NT_OPTIONAL_HDR64_MAGIC
# define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
#endif
#ifndef IMAGE_NT_OPTIONAL_HDRROM_MAGIC
# define IMAGE_NT_OPTIONAL_HDRROM_MAGIC 0x107
#endif

  switch (i->Magic)
    {
    case IMAGE_NT_OPTIONAL_HDR_MAGIC:
      name = "PE32";
      break;
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
      name = "PE32+";
      break;
    case IMAGE_NT_OPTIONAL_HDRROM_MAGIC:
      name = "ROM";
      break;
    default:
      name = NULL;
      break;
    }
  fprintf (file, "Magic\t\t\t%04x", i->Magic);
  if (name)
    fprintf (file, "\t(%s)",name);
  fprintf (file, "\nMajorLinkerVersion\t%d\n", i->MajorLinkerVersion);
  fprintf (file, "MinorLinkerVersion\t%d\n", i->MinorLinkerVersion);
  fprintf (file, "SizeOfCode\t\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfCode);
  fprintf (file, "\nSizeOfInitializedData\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfInitializedData);
  fprintf (file, "\nSizeOfUninitializedData\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfUninitializedData);
  fprintf (file, "\nAddressOfEntryPoint\t");
  bfd_fprintf_vma (abfd, file, i->AddressOfEntryPoint);
  fprintf (file, "\nBaseOfCode\t\t");
  bfd_fprintf_vma (abfd, file, i->BaseOfCode);
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64) && !defined(COFF_WITH_peAArch64) && !defined(COFF_WITH_peLoongArch64)
  /* PE32+ does not have BaseOfData member!  */
  fprintf (file, "\nBaseOfData\t\t");
  bfd_fprintf_vma (abfd, file, i->BaseOfData);
#endif

  fprintf (file, "\nImageBase\t\t");
  bfd_fprintf_vma (abfd, file, i->ImageBase);
  fprintf (file, "\nSectionAlignment\t%08x\n", i->SectionAlignment);
  fprintf (file, "FileAlignment\t\t%08x\n", i->FileAlignment);
  fprintf (file, "MajorOSystemVersion\t%d\n", i->MajorOperatingSystemVersion);
  fprintf (file, "MinorOSystemVersion\t%d\n", i->MinorOperatingSystemVersion);
  fprintf (file, "MajorImageVersion\t%d\n", i->MajorImageVersion);
  fprintf (file, "MinorImageVersion\t%d\n", i->MinorImageVersion);
  fprintf (file, "MajorSubsystemVersion\t%d\n", i->MajorSubsystemVersion);
  fprintf (file, "MinorSubsystemVersion\t%d\n", i->MinorSubsystemVersion);
  fprintf (file, "Win32Version\t\t%08x\n", i->Reserved1);
  fprintf (file, "SizeOfImage\t\t%08x\n", i->SizeOfImage);
  fprintf (file, "SizeOfHeaders\t\t%08x\n", i->SizeOfHeaders);
  fprintf (file, "CheckSum\t\t%08x\n", i->CheckSum);

  switch (i->Subsystem)
    {
    case IMAGE_SUBSYSTEM_UNKNOWN:
      subsystem_name = "unspecified";
      break;
    case IMAGE_SUBSYSTEM_NATIVE:
      subsystem_name = "NT native";
      break;
    case IMAGE_SUBSYSTEM_WINDOWS_GUI:
      subsystem_name = "Windows GUI";
      break;
    case IMAGE_SUBSYSTEM_WINDOWS_CUI:
      subsystem_name = "Windows CUI";
      break;
    case IMAGE_SUBSYSTEM_POSIX_CUI:
      subsystem_name = "POSIX CUI";
      break;
    case IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:
      subsystem_name = "Wince CUI";
      break;
    /* These are from UEFI Platform Initialization Specification 1.1.  */
    case IMAGE_SUBSYSTEM_EFI_APPLICATION:
      subsystem_name = "EFI application";
      break;
    case IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
      subsystem_name = "EFI boot service driver";
      break;
    case IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
      subsystem_name = "EFI runtime driver";
      break;
    case IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER:
      subsystem_name = "SAL runtime driver";
      break;
    /* This is from revision 8.0 of the MS PE/COFF spec  */
    case IMAGE_SUBSYSTEM_XBOX:
      subsystem_name = "XBOX";
      break;
    /* Added default case for clarity - subsystem_name is NULL anyway.  */
    default:
      subsystem_name = NULL;
    }

  fprintf (file, "Subsystem\t\t%08x", i->Subsystem);
  if (subsystem_name)
    fprintf (file, "\t(%s)", subsystem_name);
  fprintf (file, "\nDllCharacteristics\t%08x\n", i->DllCharacteristics);
  if (i->DllCharacteristics)
    {
      unsigned short dllch = i->DllCharacteristics;
      const char *indent = "\t\t\t\t\t";

      if (dllch & IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA)
	fprintf (file, "%sHIGH_ENTROPY_VA\n", indent);
      if (dllch & IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE)
	fprintf (file, "%sDYNAMIC_BASE\n", indent);
      if (dllch & IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY)
	fprintf (file, "%sFORCE_INTEGRITY\n", indent);
      if (dllch & IMAGE_DLL_CHARACTERISTICS_NX_COMPAT)
	fprintf (file, "%sNX_COMPAT\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_NO_ISOLATION)
	fprintf (file, "%sNO_ISOLATION\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_NO_SEH)
	fprintf (file, "%sNO_SEH\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_NO_BIND)
	fprintf (file, "%sNO_BIND\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_APPCONTAINER)
	fprintf (file, "%sAPPCONTAINER\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_WDM_DRIVER)
	fprintf (file, "%sWDM_DRIVER\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_GUARD_CF)
	fprintf (file, "%sGUARD_CF\n", indent);
      if (dllch & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)
	fprintf (file, "%sTERMINAL_SERVICE_AWARE\n", indent);
    }
  fprintf (file, "SizeOfStackReserve\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfStackReserve);
  fprintf (file, "\nSizeOfStackCommit\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfStackCommit);
  fprintf (file, "\nSizeOfHeapReserve\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfHeapReserve);
  fprintf (file, "\nSizeOfHeapCommit\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfHeapCommit);
  fprintf (file, "\nLoaderFlags\t\t%08lx\n", (unsigned long) i->LoaderFlags);
  fprintf (file, "NumberOfRvaAndSizes\t%08lx\n",
	   (unsigned long) i->NumberOfRvaAndSizes);

  fprintf (file, "\nThe Data Directory\n");
  for (j = 0; j < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; j++)
    {
      fprintf (file, "Entry %1x ", j);
      bfd_fprintf_vma (abfd, file, i->DataDirectory[j].VirtualAddress);
      fprintf (file, " %08lx ", (unsigned long) i->DataDirectory[j].Size);
      fprintf (file, "%s\n", dir_names[j]);
    }

  pe_print_idata (abfd, vfile);
  pe_print_edata (abfd, vfile);
  if (bfd_coff_have_print_pdata (abfd))
    bfd_coff_print_pdata (abfd, vfile);
  else
    pe_print_pdata (abfd, vfile);
  pe_print_reloc (abfd, vfile);
  pe_print_debugdata (abfd, file);

  rsrc_print_section (abfd, vfile);

  return true;
}

static bool
is_vma_in_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sect, void *obj)
{
  bfd_vma addr = * (bfd_vma *) obj;
  return (addr >= sect->vma) && (addr < (sect->vma + sect->size));
}

static asection *
find_section_by_vma (bfd *abfd, bfd_vma addr)
{
  return bfd_sections_find_if (abfd, is_vma_in_section, (void *) & addr);
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

bool
_bfd_XX_bfd_copy_private_bfd_data_common (bfd * ibfd, bfd * obfd)
{
  pe_data_type *ipe, *ope;
  bfd_size_type size;

  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return true;

  ipe = pe_data (ibfd);
  ope = pe_data (obfd);

  /* pe_opthdr is copied in copy_object.  */
  ope->dll = ipe->dll;

  /* Don't copy input subsystem if output is different from input.  */
  if (obfd->xvec != ibfd->xvec)
    ope->pe_opthdr.Subsystem = IMAGE_SUBSYSTEM_UNKNOWN;

  /* For strip: if we removed .reloc, we'll make a real mess of things
     if we don't remove this entry as well.  */
  if (! pe_data (obfd)->has_reloc_section)
    {
      pe_data (obfd)->pe_opthdr.DataDirectory[PE_BASE_RELOCATION_TABLE].VirtualAddress = 0;
      pe_data (obfd)->pe_opthdr.DataDirectory[PE_BASE_RELOCATION_TABLE].Size = 0;
    }

  /* For PIE, if there is .reloc, we won't add IMAGE_FILE_RELOCS_STRIPPED.
     But there is no .reloc, we make sure that IMAGE_FILE_RELOCS_STRIPPED
     won't be added.  */
  if (! pe_data (ibfd)->has_reloc_section
      && ! (pe_data (ibfd)->real_flags & IMAGE_FILE_RELOCS_STRIPPED))
    pe_data (obfd)->dont_strip_reloc = 1;

  memcpy (ope->dos_message, ipe->dos_message, sizeof (ope->dos_message));

  /* The file offsets contained in the debug directory need rewriting.  */
  size = ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size;
  if (size != 0)
    {
      bfd_vma addr = ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].VirtualAddress
	+ ope->pe_opthdr.ImageBase;
      /* In particular a .buildid section may overlap (in VA space) with
	 whatever section comes ahead of it (largely because of section->size
	 representing s_size, not virt_size).  Therefore don't look for the
	 section containing the first byte, but for that covering the last
	 one.  */
      bfd_vma last = addr + size - 1;
      asection *section = find_section_by_vma (obfd, last);

      if (section != NULL)
	{
	  bfd_byte *data;
	  bfd_vma dataoff = addr - section->vma;

	  /* PR 17512: file: 0f15796a.  */
	  if (addr < section->vma
	      || section->size < dataoff
	      || section->size - dataoff < size)
	    {
	      /* xgettext:c-format */
	      _bfd_error_handler
		(_("%pB: Data Directory (%lx bytes at %" PRIx64 ") "
		   "extends across section boundary at %" PRIx64),
		 obfd, ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size,
		 (uint64_t) addr, (uint64_t) section->vma);
	      return false;
	    }

	  if (bfd_malloc_and_get_section (obfd, section, &data))
	    {
	      unsigned int i;
	      struct external_IMAGE_DEBUG_DIRECTORY *dd =
		(struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff);

	      for (i = 0; i < ope->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size
		     / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
		{
		  asection *ddsection;
		  struct external_IMAGE_DEBUG_DIRECTORY *edd = &(dd[i]);
		  struct internal_IMAGE_DEBUG_DIRECTORY idd;
		  bfd_vma idd_vma;

		  _bfd_XXi_swap_debugdir_in (obfd, edd, &idd);

		  /* RVA 0 means only offset is valid, not handled yet.  */
		  if (idd.AddressOfRawData == 0)
		    continue;

		  idd_vma = idd.AddressOfRawData + ope->pe_opthdr.ImageBase;
		  ddsection = find_section_by_vma (obfd, idd_vma);
		  if (!ddsection)
		    continue; /* Not in a section! */

		  idd.PointerToRawData
		    = ddsection->filepos + idd_vma - ddsection->vma;
		  _bfd_XXi_swap_debugdir_out (obfd, &idd, edd);
		}

	      if (!bfd_set_section_contents (obfd, section, data, 0,
					     section->size))
		{
		  _bfd_error_handler (_("failed to update file offsets"
					" in debug directory"));
		  free (data);
		  return false;
		}
	      free (data);
	    }
	  else
	    {
	      _bfd_error_handler (_("%pB: failed to read "
				    "debug data section"), obfd);
	      return false;
	    }
	}
    }

  return true;
}

/* Copy private section data.  */

bool
_bfd_XX_bfd_copy_private_section_data (bfd *ibfd,
				       asection *isec,
				       bfd *obfd,
				       asection *osec)
{
  if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour
      || bfd_get_flavour (obfd) != bfd_target_coff_flavour)
    return true;

  if (coff_section_data (ibfd, isec) != NULL
      && pei_section_data (ibfd, isec) != NULL)
    {
      if (coff_section_data (obfd, osec) == NULL)
	{
	  size_t amt = sizeof (struct coff_section_tdata);
	  osec->used_by_bfd = bfd_zalloc (obfd, amt);
	  if (osec->used_by_bfd == NULL)
	    return false;
	}

      if (pei_section_data (obfd, osec) == NULL)
	{
	  size_t amt = sizeof (struct pei_section_tdata);
	  coff_section_data (obfd, osec)->tdata = bfd_zalloc (obfd, amt);
	  if (coff_section_data (obfd, osec)->tdata == NULL)
	    return false;
	}

      pei_section_data (obfd, osec)->virt_size =
	pei_section_data (ibfd, isec)->virt_size;
      pei_section_data (obfd, osec)->pe_flags =
	pei_section_data (ibfd, isec)->pe_flags;
    }

  return true;
}

void
_bfd_XX_get_symbol_info (bfd * abfd, asymbol *symbol, symbol_info *ret)
{
  coff_get_symbol_info (abfd, symbol, ret);
}

#if !defined(COFF_WITH_pep) && (defined(COFF_WITH_pex64) || defined(COFF_WITH_peAArch64) || defined(COFF_WITH_peLoongArch64))
static int
sort_x64_pdata (const void *l, const void *r)
{
  const char *lp = (const char *) l;
  const char *rp = (const char *) r;
  bfd_vma vl, vr;
  vl = bfd_getl32 (lp); vr = bfd_getl32 (rp);
  if (vl != vr)
    return (vl < vr ? -1 : 1);
  /* We compare just begin address.  */
  return 0;
}
#endif

/* Functions to process a .rsrc section.  */

static unsigned int sizeof_leaves;
static unsigned int sizeof_strings;
static unsigned int sizeof_tables_and_entries;

static bfd_byte *
rsrc_count_directory (bfd *, bfd_byte *, bfd_byte *, bfd_byte *, bfd_vma);

static bfd_byte *
rsrc_count_entries (bfd *abfd,
		    bool is_name,
		    bfd_byte *datastart,
		    bfd_byte *data,
		    bfd_byte *dataend,
		    bfd_vma rva_bias)
{
  unsigned long entry, addr, size;

  if (data + 8 >= dataend)
    return dataend + 1;

  if (is_name)
    {
      bfd_byte * name;

      entry = (long) bfd_get_32 (abfd, data);

      if (HighBitSet (entry))
	name = datastart + WithoutHighBit (entry);
      else
	name = datastart + entry - rva_bias;

      if (name + 2 >= dataend || name < datastart)
	return dataend + 1;

      unsigned int len = bfd_get_16 (abfd, name);
      if (len == 0 || len > 256)
	return dataend + 1;
    }

  entry = (long) bfd_get_32 (abfd, data + 4);

  if (HighBitSet (entry))
    {
      data = datastart + WithoutHighBit (entry);

      if (data <= datastart || data >= dataend)
	return dataend + 1;

      return rsrc_count_directory (abfd, datastart, data, dataend, rva_bias);
    }

  if (datastart + entry + 16 >= dataend)
    return dataend + 1;

  addr = (long) bfd_get_32 (abfd, datastart + entry);
  size = (long) bfd_get_32 (abfd, datastart + entry + 4);

  return datastart + addr - rva_bias + size;
}

static bfd_byte *
rsrc_count_directory (bfd *	     abfd,
		      bfd_byte *     datastart,
		      bfd_byte *     data,
		      bfd_byte *     dataend,
		      bfd_vma	     rva_bias)
{
  unsigned int  num_entries, num_ids;
  bfd_byte *    highest_data = data;

  if (data + 16 >= dataend)
    return dataend + 1;

  num_entries  = (int) bfd_get_16 (abfd, data + 12);
  num_ids      = (int) bfd_get_16 (abfd, data + 14);

  num_entries += num_ids;

  data += 16;

  while (num_entries --)
    {
      bfd_byte * entry_end;

      entry_end = rsrc_count_entries (abfd, num_entries >= num_ids,
				      datastart, data, dataend, rva_bias);
      data += 8;
      highest_data = max (highest_data, entry_end);
      if (entry_end >= dataend)
	break;
    }

  return max (highest_data, data);
}

typedef struct rsrc_dir_chain
{
  unsigned int	       num_entries;
  struct rsrc_entry *  first_entry;
  struct rsrc_entry *  last_entry;
} rsrc_dir_chain;

typedef struct rsrc_directory
{
  unsigned int characteristics;
  unsigned int time;
  unsigned int major;
  unsigned int minor;

  rsrc_dir_chain names;
  rsrc_dir_chain ids;

  struct rsrc_entry * entry;
} rsrc_directory;

typedef struct rsrc_string
{
  unsigned int	len;
  bfd_byte *	string;
} rsrc_string;

typedef struct rsrc_leaf
{
  unsigned int	size;
  unsigned int	codepage;
  bfd_byte *	data;
} rsrc_leaf;

typedef struct rsrc_entry
{
  bool is_name;
  union
  {
    unsigned int	  id;
    struct rsrc_string	  name;
  } name_id
```

The masked region can be implemented using either of the two snippets below. Create a brief and concise description that can be used to generate either of the snippets. Do not include any securityspecific features in the description.
Snippet 1:
```
# define PDATA_ROW_SIZE	(2 * 4)
  FILE *file = (FILE *) file_ptr;
  bfd_byte *data = NULL;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = PDATA_ROW_SIZE;
  struct sym_cache cache = {0, 0} ;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return true;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
	     /* xgettext:c-format */
	     _("warning, .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));

  fprintf (file, _("\
 vma:\t\tBegin    Prolog   Function Flags    Exception EH\n\
     \t\tAddress  Length   Length   32b exc  Handler   Data\n"));

  datasize = section->size;
  if (datasize == 0)
    return true;

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma other_data;
      bfd_vma prolog_length, function_length;
      int flag32bit, exception_flag;
      asection *tsection;

      if (i + PDATA_ROW_SIZE > stop)
	break;

      begin_addr = GET_PDATA_ENTRY (abfd, data + i     );
      other_data = GET_PDATA_ENTRY (abfd, data + i +  4);

      if (begin_addr == 0 && other_data == 0)
	/* We are probably into the padding of the section now.  */
	break;

      prolog_length = (other_data & 0x000000FF);
      function_length = (other_data & 0x3FFFFF00) >> 8;
      flag32bit = (int)((other_data & 0x40000000) >> 30);
      exception_flag = (int)((other_data & 0x80000000) >> 31);

      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, prolog_length); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, function_length); fputc (' ', file);
      fprintf (file, "%2d  %2d   ", flag32bit, exception_flag);

      /* Get the exception handler's address and the data passed from the
	 .text section. This is really the data that belongs with the .pdata
	 but got "compressed" out for the ARM and SH4 architectures.  */
      tsection = bfd_get_section_by_name (abfd, ".text");
      if (tsection && coff_section_data (abfd, tsection)
	  && pei_section_data (abfd, tsection))
	{
	  bfd_vma eh_off = (begin_addr - 8) - tsection->vma;
	  bfd_byte *tdata;

	  tdata = (bfd_byte *) bfd_malloc (8);
	  if (tdata)
	    {
	      if (bfd_get_section_contents (abfd, tsection, tdata, eh_off, 8))
		{
		  bfd_vma eh, eh_data;

		  eh = bfd_get_32 (abfd, tdata);
		  eh_data = bfd_get_32 (abfd, tdata + 4);
		  fprintf (file, "%08x  ", (unsigned int) eh);
		  fprintf (file, "%08x", (unsigned int) eh_data);
		  if (eh != 0)
		    {
		      const char *s = my_symbol_for_address (abfd, eh, &cache);

		      if (s)
			fprintf (file, " (%s) ", s);
		    }
		}
	      free (tdata);
	    }
	}

      fprintf (file, "\n");
    }

  free (data);

  cleanup_syms (& cache);

  return true;
#undef PDATA_ROW_SIZE
```
Snippet 2:
```
# define PDATA_ROW_SIZE	(2 * 4)
  FILE *file = (FILE *) file_ptr;
  bfd_byte *data = NULL;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = PDATA_ROW_SIZE;
  struct sym_cache cache = {0, 0} ;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return true;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
	     /* xgettext:c-format */
	     _("warning, .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));

  fprintf (file, _("\
 vma:\t\tBegin    Prolog   Function Flags    Exception EH\n\
     \t\tAddress  Length   Length   32b exc  Handler   Data\n"));

  datasize = section->size;
  if (datasize == 0)
    return true;

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      free (data);
      return false;
    }

  start = 0;
  if (stop > datasize)
    stop = datasize;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma other_data;
      bfd_vma prolog_length, function_length;
      int flag32bit, exception_flag;
      asection *tsection;

      if (i + PDATA_ROW_SIZE > stop)
	break;

      begin_addr = GET_PDATA_ENTRY (abfd, data + i     );
      other_data = GET_PDATA_ENTRY (abfd, data + i +  4);

      if (begin_addr == 0 && other_data == 0)
	/* We are probably into the padding of the section now.  */
	break;

      prolog_length = (other_data & 0x000000FF);
      function_length = (other_data & 0x3FFFFF00) >> 8;
      flag32bit = (int)((other_data & 0x40000000) >> 30);
      exception_flag = (int)((other_data & 0x80000000) >> 31);

      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, prolog_length); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, function_length); fputc (' ', file);
      fprintf (file, "%2d  %2d   ", flag32bit, exception_flag);

      /* Get the exception handler's address and the data passed from the
	 .text section. This is really the data that belongs with the .pdata
	 but got "compressed" out for the ARM and SH4 architectures.  */
      tsection = bfd_get_section_by_name (abfd, ".text");
      if (tsection && coff_section_data (abfd, tsection)
	  && pei_section_data (abfd, tsection))
	{
	  bfd_vma eh_off = (begin_addr - 8) - tsection->vma;
	  bfd_byte *tdata;

	  tdata = (bfd_byte *) bfd_malloc (8);
	  if (tdata)
	    {
	      if (bfd_get_section_contents (abfd, tsection, tdata, eh_off, 8))
		{
		  bfd_vma eh, eh_data;

		  eh = bfd_get_32 (abfd, tdata);
		  eh_data = bfd_get_32 (abfd, tdata + 4);
		  fprintf (file, "%08x  ", (unsigned int) eh);
		  fprintf (file, "%08x", (unsigned int) eh_data);
		  if (eh != 0)
		    {
		      const char *s = my_symbol_for_address (abfd, eh, &cache);

		      if (s)
			fprintf (file, " (%s) ", s);
		    }
		}
	      free (tdata);
	    }
	}

      fprintf (file, "\n");
    }

  free (data);

  cleanup_syms (& cache);

  return true;
#undef PDATA_ROW_SIZE
```