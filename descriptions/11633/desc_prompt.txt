Below is the content of a code file where a code block is masked by `// <MASK>`.
```
(tvb,l_offset, 1);
        l_offset+=1;
        if(pwrCntlDelayIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Rev_Pwr_Cntl_Delay, tvb, l_offset, 2, ENC_BIG_ENDIAN);
            l_offset+=2;
        }
    }
    if(encryptMode == 2 || encryptMode == 3)
    {
        if(encryptMode == 3)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_D_Sig_Encrypt_Mode, tvb, l_offset, 3, ENC_BIG_ENDIAN);
            l_offset+=3;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Enc_Key_Size, tvb, l_offset, 3, ENC_BIG_ENDIAN);
        l_offset+=3;
    }
    proto_tree_add_bits_item(subtree, hf_cdma2k_3xfl_1xrl_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
    linkIncl = tvb_get_bits8(tvb,l_offset, 1);
    l_offset+=1;
    if(linkIncl == 1)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_1xrl_Freq_Offset, tvb, l_offset, 2, ENC_BIG_ENDIAN);
        l_offset+=2;
    }
    if(scrIncl == 1 || nnscrIncl == 1 || pRev >= 11)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_Sync_Id_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        syncIdIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(syncIdIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Sync_Id_Len, tvb, l_offset, 4, ENC_BIG_ENDIAN);
            syncIdLen = tvb_get_bits8(tvb,l_offset, 4);
            l_offset+=4;
            item1 = proto_tree_add_item(subtree, hf_cdma2k_Sync_Id, tvb, l_offset/8,syncIdLen, ENC_NA);
            while(syncIdLen > 0)
            {
                proto_item_append_text(item1, " %02x",tvb_get_bits8(tvb,l_offset, 8));
                l_offset+=8;
                syncIdLen--;
            }
        }
    }
    proto_tree_add_bits_item(subtree, hf_cdma2k_Cc_Info_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
    ccInfoIncl = tvb_get_bits8(tvb,l_offset, 1);
    l_offset+=1;
    if(ccInfoIncl == 1)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_Num_Calls_Assign, tvb, l_offset, 8, ENC_BIG_ENDIAN);
        noCallAssign = tvb_get_bits8(tvb,l_offset, 8);
        l_offset+=8;
        for(loop = 1; loop <= noCallAssign; loop++)
        {
            item1 = proto_tree_add_item(subtree, hf_cdma2k_Record_Calls_Assign, tvb, l_offset/8,noCallAssign*2, ENC_NA);
            proto_item_append_text(item1, " : [%02d]",loop);
            subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Con_Ref, tvb, l_offset, 8, ENC_BIG_ENDIAN);
            l_offset+=8;
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Response_Ind, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            resInd = tvb_get_bits8(tvb,l_offset, 1);
            l_offset+=1;
            if(resInd == 1)
            {
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Tag, tvb, l_offset, 4, ENC_BIG_ENDIAN);
                l_offset+=4;
            }
            else
            {
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Bypass_Alert_Answer, tvb, l_offset, 1, ENC_BIG_ENDIAN);
                l_offset+=1;
            }
        }
    }

    proto_tree_add_bits_item(subtree, hf_cdma2k_Cs_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
    csSup = tvb_get_bits8(tvb,l_offset, 1);
    l_offset+=1;

    if(msgType == 53)
    {
        if(pRev == 6)
        {
            if(encryptMode == 2 && scrIncl ==1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 13, ENC_BIG_ENDIAN);
                l_offset+=13;
            }
            else if(encryptMode == 2 && scrIncl !=1 && nnscrIncl == 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 12, ENC_BIG_ENDIAN);
                l_offset+=12;
            }
            else if(encryptMode == 2 && scrIncl !=1 && nnscrIncl != 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 11, ENC_BIG_ENDIAN);
                l_offset+=11;
            }
            else if(encryptMode != 2 && scrIncl ==1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 10, ENC_BIG_ENDIAN);
                l_offset+=10;
            }
            else if(encryptMode != 2 && scrIncl !=1 && nnscrIncl == 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 9, ENC_BIG_ENDIAN);
                l_offset+=9;
            }
            else if(encryptMode != 2 && scrIncl !=1 && nnscrIncl != 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 8, ENC_BIG_ENDIAN);
                l_offset+=8;
            }
        }
        else if(pRev == 7 || pRev == 8)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, 6, ENC_BIG_ENDIAN);
            l_offset+=6;
        }

        proto_tree_add_bits_item(subtree, hf_cdma2k_Plcm_Type_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        plcmIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(plcmIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Plcm_Type, tvb, l_offset, 4, ENC_BIG_ENDIAN);
            plcmType = tvb_get_bits8(tvb,l_offset, 4);
            l_offset+=4;
            if(plcmType == 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Plcm_39, tvb, l_offset, 39, ENC_BIG_ENDIAN);
                l_offset+=39;
            }
        }
    }

    if(pRev > 7 && msgType == 34)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_Chm_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Cdma_Off_Time_Rep_Sup_Ind, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        cdmaRepSup = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(cdmaRepSup == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Cdma_Off_Time_Rep_Threshold_Unit, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            l_offset+=1;
            proto_tree_add_bits_item(subtree, hf_cdma2k_Cdma_Off_Time_Rep_Threshold, tvb, l_offset, 3, ENC_BIG_ENDIAN);
            l_offset+=3;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Release_To_Idle_Ind, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Msg_Integrity_Sup, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Gen_2g_Key, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Register_In_Idle, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;

        proto_tree_add_bits_item(subtree, hf_cdma2k_Plcm_Type_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        plcmIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(plcmIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Plcm_Type, tvb, l_offset, 4, ENC_BIG_ENDIAN);
            plcmType = tvb_get_bits8(tvb,l_offset, 4);
            l_offset+=4;
            proto_tree_add_bits_item(subtree, hf_cdma2k_Plcm_39, tvb, l_offset, 39, ENC_BIG_ENDIAN);
            l_offset+=39;
        }
        if(searchIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_T_Tdrop_Range_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            dropTRangeIncl = tvb_get_bits8(tvb,l_offset, 1);
            l_offset+=1;
            if(dropTRangeIncl == 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_T_Tdrop_Range, tvb, l_offset, 4, ENC_BIG_ENDIAN);
                l_offset+=4;
            }
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_For_Pdch_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        fwdPDChSup = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(fwdPDChSup == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Pdch_Chm_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            l_offset+=1;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Pilot_Info_Req_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Enc_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        encIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(encIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Sig_Encrypt_Sup, tvb, l_offset, 8, ENC_BIG_ENDIAN);
            l_offset+=8;
            proto_tree_add_bits_item(subtree, hf_cdma2k_Ui_Encrypt_Sup, tvb, l_offset, 8, ENC_BIG_ENDIAN);
            l_offset+=8;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Use_Sync_Id, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Sid_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        sidIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(sidIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Sid, tvb, l_offset, 15, ENC_BIG_ENDIAN);
            l_offset+=15;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Nid_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        nidIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(nidIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Nid, tvb, l_offset, 16, ENC_BIG_ENDIAN);
            l_offset+=16;
        }

        proto_tree_add_bits_item(subtree, hf_cdma2k_Sdb_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        if(csSup== 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Mob_Qos, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            l_offset+=1;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Ms_Init_Pos_Loc_Sup_Ind, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
    }

    if(pRev > 9 && msgType == 34)
    {
        if(fwdPDChSup == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Rev_Pdch_Supported, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            l_offset+=1;
        }
        if(pacZoneId != 0)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Pz_Hyst_Enabled, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            pzHysEnabled = tvb_get_bits8(tvb,l_offset, 1);
            l_offset+=1;
            if(pzHysEnabled == 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Pz_Hyst_Info_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
                pzHysInfoIncl = tvb_get_bits8(tvb,l_offset, 1);
                l_offset+=1;
                if(pzHysInfoIncl == 1)
                {
                    proto_tree_add_bits_item(subtree, hf_cdma2k_Pz_Hyst_List_Len, tvb, l_offset, 4, ENC_BIG_ENDIAN);
                    l_offset+=4;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_Pz_Hyst_Act_Timer, tvb, l_offset, 8, ENC_BIG_ENDIAN);
                    l_offset+=8;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_Pz_Hyst_Timer_Mul, tvb, l_offset, 3, ENC_BIG_ENDIAN);
                    l_offset+=3;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_Pz_Hyst_Timer_Exp, tvb, l_offset, 5, ENC_BIG_ENDIAN);
                    l_offset+=5;
                }
            }
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Bcmc_On_Traffic_Sup, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        bcmcTchSup = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(bcmcTchSup == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Auto_Re_Traffic_Allowed_Ind, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            l_offset+=1;
        }
        if(bcmcTchSup == 1 || numForAssign == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Sch_Bcmc_Ind, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            schBcmc = tvb_get_bits8(tvb,l_offset, 1);
            l_offset+=1;
        }
        if(schBcmc == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Add_Plcm_For_Sch_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            addPlcmSchIncl = tvb_get_bits8(tvb,l_offset, 1);
            l_offset+=1;
            if(addPlcmSchIncl == 1)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Add_Plcm_For_Sch_Type, tvb, l_offset, 1, ENC_BIG_ENDIAN);
                addPlcmSchType = tvb_get_bits8(tvb,l_offset, 1);
                l_offset+=1;
                if(addPlcmSchType == 1)
                {
                    proto_tree_add_bits_item(subtree, hf_cdma2k_Add_Plcm_For_Sch_35, tvb, l_offset, 35, ENC_BIG_ENDIAN);
                    l_offset+=35;
                }
            }
            for(loop =1; loop <= numForAssign; loop++)
            {
                item1 = proto_tree_add_item(subtree, hf_cdma2k_Record_Sch_Bcmc, tvb, l_offset/8,numForAssign*2, ENC_NA);
                proto_item_append_text(item1, " : [%02d]",loop);
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Use_Add_Plcm_For_Sch, tvb, l_offset, 1, ENC_BIG_ENDIAN);
                l_offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Fsch_Outercode_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
                fSchOuterCodeIncl = tvb_get_bits8(tvb,l_offset, 1);
                l_offset+=1;
                if(fSchOuterCodeIncl == 1)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Fsch_Outercode_Rate, tvb, l_offset, 3, ENC_BIG_ENDIAN);
                    l_offset+=3;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Fsch_Outercode_Offset, tvb, l_offset, 6, ENC_BIG_ENDIAN);
                    l_offset+=6;
                }
            }
        }
        if(csSup== 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Max_Add_Serv_Instance, tvb, l_offset, 3, ENC_BIG_ENDIAN);
            l_offset+=3;
        }
        proto_tree_add_bits_item(subtree, hf_cdma2k_Use_Ch_Cfg_Rrm, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        l_offset+=1;
        proto_tree_add_bits_item(subtree, hf_cdma2k_Tx_Pwr_Limit_Incl, tvb, l_offset, 1, ENC_BIG_ENDIAN);
        txPwrIncl = tvb_get_bits8(tvb,l_offset, 1);
        l_offset+=1;
        if(txPwrIncl == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_Tx_Pwr_Limit_Default, tvb, l_offset, 1, ENC_BIG_ENDIAN);
            txPwrDflt = tvb_get_bits8(tvb,l_offset, 1);
            l_offset+=1;
            if(txPwrDflt == 0)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_Tx_Pwr_Limit, tvb, l_offset, 6, ENC_BIG_ENDIAN);
                l_offset+=6;
            }
        }
    }

    if(l_offset%8 == 0)
    {
        *offset = (l_offset/8);
    }
    else
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_Reserved, tvb, l_offset, (8-(l_offset%8)), ENC_BIG_ENDIAN);
        *offset = (l_offset/8) + 1;
    }
}


/* Helper function to decode Alert With Info Message Parameters */
static void cdma2k_message_ALERT_WITH_INFO(proto_item *item,tvbuff_t *tvb,proto_tree *tree,guint *offset)
{
    guint16 recType = -1, recLen = -1, extBit = -1, numGrps = -1;
    guint16 polIncl = -1, inc = -1;
    proto_tree *subtree = NULL, *subtree1 = NULL;
    proto_item *item1 = NULL, *item2 = NULL;

    item = proto_tree_add_item(tree,hf_cdma2k_AlertWithInfoMsg, tvb, *offset,-1, ENC_NA);
    subtree = proto_item_add_subtree(item, ett_cdma2k_subtree1);

    inc = 1;
    while(tvb_captured_length_remaining(tvb,*offset) != 0 )
    {
        item1 = proto_tree_add_item(subtree, hf_cdma2k_Info_Rec, tvb, *offset,1, ENC_NA);
        proto_item_append_text(item1," : [%02d]", inc);
        inc++;
        subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
        proto_tree_add_item(subtree1, hf_cdma2k_Record_Type, tvb, *offset,1, ENC_BIG_ENDIAN);
        recType = tvb_get_bits8(tvb,*offset*8,8);
        *offset+=1;
        proto_tree_add_item(subtree1, hf_cdma2k_Record_Len, tvb, *offset,1, ENC_BIG_ENDIAN);
        recLen = tvb_get_bits8(tvb,*offset*8,8);
        *offset+=1;
        item1 = proto_tree_add_item(subtree1, hf_cdma2k_Type_Specific_Fields, tvb, *offset,recLen, ENC_NA);

        switch(recType)
        {
            case 1:
            {
                proto_item_append_text(item1," DISPLAY");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Characters : ");
                while(recLen > 0)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8,8));
                    *offset+=1;
                    recLen-=1;
                }
                break;
            }

            case 2:
            {
                proto_item_append_text(item1," CALLED PARTY NUMBER");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Number_Type, tvb, *offset*8,3, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Number_Plan, tvb, *offset*8+3,4, ENC_BIG_ENDIAN);
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Called Party Number : ");
                while(recLen > 1)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8+7,8));
                    *offset+=1;
                    recLen-=1;
                }
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+7,1, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            case 3:
            {
                proto_item_append_text(item1," CALLING PARTY NUMBER");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Number_Type, tvb, *offset*8,3, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Number_Plan, tvb, *offset*8+3,4, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Pres_Indicator, tvb, *offset*8+7,2, ENC_BIG_ENDIAN);
                *offset+=1;
                recLen-=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Scr_Indicator, tvb, *offset*8+1,2, ENC_BIG_ENDIAN);
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Calling Party Number : ");
                while(recLen > 1)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8+3,8));
                    *offset+=1;
                    recLen-=1;
                }
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+3,5, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            case 5:
            {
                proto_item_append_text(item1," SIGNAL");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Signal_Type, tvb, *offset*8,2, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Alert_Pitch, tvb, *offset*8+2,2, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Signal, tvb, *offset*8+4,6, ENC_BIG_ENDIAN);
                *offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+2,6, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            case 6:
            {
                proto_item_append_text(item1," MESSAGE WAITING");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_item(subtree1, hf_cdma2k_Msg_Count, tvb, *offset,1, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            case 8:
            {
                proto_item_append_text(item1," CALLED PARTY SUBADDRESS");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Extension_Bit, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Subaddress_Type, tvb, *offset*8+1,3, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Odd_Even_Ind, tvb, *offset*8+4,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+5,3, ENC_BIG_ENDIAN);
                *offset+=1;
                recLen-=1;
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen-1, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Called Party Subaddress : ");
                while(recLen > 1)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8,8));
                    *offset+=1;
                    recLen-=1;
                }
                break;
            }

            case 9:
            {
                proto_item_append_text(item1," CALLING PARTY SUBADDRESS");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Extension_Bit, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Subaddress_Type, tvb, *offset*8+1,3, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Odd_Even_Ind, tvb, *offset*8+4,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+5,3, ENC_BIG_ENDIAN);
                *offset+=1;
                recLen-=1;
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen-1, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Calling Party Subaddress : ");
                while(recLen > 1)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8,8));
                    *offset+=1;
                    recLen-=1;
                }
                break;
            }

            case 11:
            {
                proto_item_append_text(item1," REDIRECTING NUMBER");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Extension_Bit, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                extBit = tvb_get_bits8(tvb,*offset*8,1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Number_Type, tvb, *offset*8+1,3, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Number_Plan, tvb, *offset*8+4,4, ENC_BIG_ENDIAN);
                *offset+=1;
                recLen-=1;
                if(extBit == 0)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Extension_Bit, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                    extBit = tvb_get_bits8(tvb,*offset*8,1);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Pres_Indicator, tvb, *offset*8+1,2, ENC_BIG_ENDIAN);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+3,3, ENC_BIG_ENDIAN);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Scr_Indicator, tvb, *offset*8+6,2, ENC_BIG_ENDIAN);
                    *offset+=1;
                    recLen-=1;
                }
                if(extBit == 0)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Extension_Bit, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                    extBit = tvb_get_bits8(tvb,*offset*8,1);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+1,3, ENC_BIG_ENDIAN);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Redirection_Reason, tvb, *offset*8+4,4, ENC_BIG_ENDIAN);
                    *offset+=1;
                    recLen-=1;
                }
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen-1, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Redirecting Number : ");
                while(recLen > 1)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8,8));
                    *offset+=1;
                    recLen-=1;
                }
                break;
            }

            case 12:
            {
                proto_item_append_text(item1," REDIRECTING SUBADDRESS");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Extension_Bit, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Subaddress_Type, tvb, *offset*8+1,3, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Odd_Even_Ind, tvb, *offset*8+4,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+5,3, ENC_BIG_ENDIAN);
                *offset+=1;
                recLen-=1;
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Chari, tvb, *offset,recLen-1, ENC_NA);
                proto_item_append_text(item2, " - ASCII Values Of Redirecting Subaddress : ");
                while(recLen > 1)
                {
                    proto_item_append_text(item2, "%02x ",tvb_get_bits8(tvb,*offset*8,8));
                    *offset+=1;
                    recLen-=1;
                }
                break;
            }

            case 13:
            {
                proto_item_append_text(item1," METER PULSES");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Pulse_Freq, tvb, *offset*8,11, ENC_BIG_ENDIAN);
                *offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Pulse_On_Time, tvb, *offset*8+3,8, ENC_BIG_ENDIAN);
                *offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Pulse_Off_Time, tvb, *offset*8+3,8, ENC_BIG_ENDIAN);
                *offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Pulse_Count, tvb, *offset*8+3,4, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+7,1, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            case 14:
            {
                proto_item_append_text(item1," PARAMETRIC ALERTING");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_item(subtree1, hf_cdma2k_Cadence_Count, tvb, *offset,1, ENC_BIG_ENDIAN);
                *offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Num_Grps, tvb, *offset*8,4, ENC_BIG_ENDIAN);
                numGrps = tvb_get_bits8(tvb,*offset*8,4);
                while(numGrps > 0)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Amplitude, tvb, *offset*8+4,8, ENC_BIG_ENDIAN);
                    *offset+=1;
                    item2 = proto_tree_add_item(subtree1, hf_cdma2k_Freq, tvb, *offset,2, ENC_NA);
                    proto_item_append_text(item2, " [01] : %02d", tvb_get_bits8(tvb,*offset*8+4,10));
                    *offset+=1;
                    item2 = proto_tree_add_item(subtree1, hf_cdma2k_Freq, tvb, *offset,2, ENC_NA);
                    proto_item_append_text(item2, " [02] : %02d", tvb_get_bits8(tvb,*offset*8+6,10));
                    *offset+=2;
                    proto_tree_add_item(subtree1, hf_cdma2k_On_Time, tvb, *offset,1, ENC_BIG_ENDIAN);
                    *offset+=1;
                    proto_tree_add_item(subtree1, hf_cdma2k_Off_Time, tvb, *offset,1, ENC_BIG_ENDIAN);
                    *offset+=1;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Repeat, tvb, *offset*8,4, ENC_BIG_ENDIAN);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Delay, tvb, *offset*8+4,8, ENC_BIG_ENDIAN);
                    *offset+=1;
                    numGrps-=1;
                }
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Cadence_Type, tvb, *offset*8+4,2, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+6,2, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            case 15:
            {
                proto_item_append_text(item1," LINE CONTROL");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Polarity_Incl, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                polIncl = tvb_get_bits8(tvb,*offset*8,1);
                if(polIncl == 1)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Toggle_Mode, tvb, *offset*8+1,1, ENC_BIG_ENDIAN);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Reverse_Polarity, tvb, *offset*8+2,1, ENC_BIG_ENDIAN);
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Pwr_Denial_Time, tvb, *offset*8+3,8, ENC_BIG_ENDIAN);
                    *offset+=1;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+3,5, ENC_BIG_ENDIAN);
                    *offset+=1;
                }
                else
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Pwr_Denial_Time, tvb, *offset*8+1,8, ENC_BIG_ENDIAN);
                    *offset+=1;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+1,7, ENC_BIG_ENDIAN);
                    *offset+=1;
                }
                break;
            }

            case 21:
            {
                proto_item_append_text(item1," CALL WAITING INDICATOR");
                subtree1 = proto_item_add_subtree(item1, ett_cdma2k_subtree1);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Call_Waiting_Ind, tvb, *offset*8,1, ENC_BIG_ENDIAN);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Reserved, tvb, *offset*8+1,7, ENC_BIG_ENDIAN);
                *offset+=1;
                break;
            }

            default:
            {
                proto_item_append_text(item1," Invalid / Unsupported Record Type in Alert With Info Message");
                break;
            }
        } /* Switch */
    } /* while */
}


/* Helper function to decode Active Set Record Field Parameters */
static void cdma2k_message_ACTIVE_SET_RECORD_FIELDS(proto_item *item _U_, tvbuff_t *tvb, proto_tree *active_set_tree, guint16 *l_offset, guint16 chInd, guint16 schIncl)
{
    guint16 loop = -1, numForSch = -1, numRevSch = -1, pilotCnt = -1, srchOffsetIncl = -1;
    guint16 pilotInfoIncl = -1, recLen = -1, schCnt = -1, fchInfoIncl = -1, fchLowIncl = -1;
    guint16 fchHighIncl = -1, schInfoIncl = -1, schLowIncl = -1, ccshIncl = -1, ccshEncIncl = -1;
    guint16 pilotIncl = -1, schHighIncl = -1, dcchInfoIncl = -1, dcchLowIncl = -1, dcchHighIncl = -1;
    guint16 bcmcFunIncl = -1, addPlcmFchIncl = -1, cpcchInfoIncl = -1, addPlcmFchType = -1;
    proto_tree *subtree1 = NULL, *subtree2 = NULL;
    proto_item *item1 = NULL, *item2 = NULL;

    if(schIncl != 0)
    {
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Num_For_Sch, tvb, *l_offset, 5, ENC_BIG_ENDIAN);
        numForSch = tvb_get_bits8(tvb,*l_offset, 5);
        *l_offset+=5;
        if(numForSch != 0)
        {
            for(loop = 1; loop <= numForSch; loop++)
            {
                item1 = proto_tree_add_item(active_set_tree, hf_cdma2k_Record_For_Sch, tvb, *l_offset/8,numForSch*2, ENC_NA);
                proto_item_append_text(item1," : [%d]", loop);
                subtree1 = proto_item_add_subtree(item1,ett_cdma2k_subtree2);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Sch_Id, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                *l_offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Sccl_Index, tvb, *l_offset, 4, ENC_BIG_ENDIAN);
                *l_offset+=4;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Sch_Num_Bits_Idx, tvb, *l_offset, 4, ENC_BIG_ENDIAN);
                *l_offset+=4;
            }
        }
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Num_Rev_Sch, tvb, *l_offset, 5, ENC_BIG_ENDIAN);
        numRevSch = tvb_get_bits8(tvb,*l_offset, 5);
        *l_offset+=5;
        if(numRevSch != 0)
        {
            for(loop = 1; loop <= numRevSch; loop++)
            {
                item1 = proto_tree_add_item(active_set_tree, hf_cdma2k_Record_Rev_Sch, tvb, *l_offset/8,numRevSch*1, ENC_NA);
                proto_item_append_text(item1," : [%d]", loop);
                subtree1 = proto_item_add_subtree(item1,ett_cdma2k_subtree2);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Sch_Id, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                *l_offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Walsh_Id, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                *l_offset+=1;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_Sch_Num_Bits_Idx, tvb, *l_offset, 4, ENC_BIG_ENDIAN);
                *l_offset+=4;
            }
        }
    } /* schIncl */

    proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Num_Pilots, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
    pilotCnt = tvb_get_bits8(tvb,*l_offset, 3);
    *l_offset+=3;
    proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Srch_Offset_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
    srchOffsetIncl = tvb_get_bits8(tvb,*l_offset, 1);
    *l_offset+=1;
    for(loop = 1; loop <= pilotCnt; loop++)
    {
        item1 = proto_tree_add_item(active_set_tree, hf_cdma2k_Record_Pilots, tvb, *l_offset/8,1, ENC_NA);
        proto_item_append_text(item1," : [%d]", loop);
        subtree1 = proto_item_add_subtree(item1,ett_cdma2k_subtree2);
        proto_tree_add_bits_item(subtree1, hf_cdma2k_Pilot_Pn, tvb, *l_offset, 9, ENC_BIG_ENDIAN);
        *l_offset+=9;
        if(srchOffsetIncl == 1)
        {
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Srch_Offset, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            *l_offset+=3;
        }
        proto_tree_add_bits_item(subtree1, hf_cdma2k_Add_Pilot_Rec_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        pilotInfoIncl = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;
        if(pilotInfoIncl == 1)
        {
            // <MASK>
        }
        proto_tree_add_bits_item(subtree1, hf_cdma2k_Pwr_Comb_Ind, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        *l_offset+=1;
        if(chInd == 5 || chInd == 7)
        {
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Code_Chan_Fch, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
            *l_offset+=11;
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Qof_Mask_Id_Fch, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
            *l_offset+=2;
        }
        if(chInd == 2 || chInd == 6 || chInd == 7)
        {
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Code_Chan_Dcch, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
            *l_offset+=11;
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Qof_Mask_Id_Dcch, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
            *l_offset+=2;
        }

        if(schIncl != 0)
        {
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Num_Sch, tvb, *l_offset, 5, ENC_BIG_ENDIAN);
            schCnt = tvb_get_bits8(tvb,*l_offset, 5);
            *l_offset+=5;
            for(loop = 1; loop <= schCnt; loop++)
            {
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Record_Sch, tvb, *l_offset/8,-1, ENC_NA);
                proto_item_append_text(item2," : [%d]", loop);
                subtree2 = proto_item_add_subtree(item2,ett_cdma2k_subtree2);
                proto_tree_add_bits_item(subtree2,hf_cdma2k_Sch_Id, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                *l_offset+=1;
                proto_tree_add_bits_item(subtree2,hf_cdma2k_Sccl_Index, tvb, *l_offset, 4, ENC_BIG_ENDIAN);
                *l_offset+=4;
                proto_tree_add_bits_item(subtree2,hf_cdma2k_Pilot_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                pilotIncl = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(pilotIncl == 1)
                {
                    proto_tree_add_bits_item(subtree2,hf_cdma2k_Code_Chan_Sch, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                    *l_offset+=11;
                    proto_tree_add_bits_item(subtree2,hf_cdma2k_Qof_Mask_Id_Sch, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                    *l_offset+=2;
                }
            }
        } /* schIncl  */
    } /* loop  */

    if(chInd == 5 || chInd == 7)
    {
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_3xFch_Info_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        fchInfoIncl = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;
    }
    if(chInd == 2 || chInd == 6 || chInd == 7)
    {
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_3xDcch_Info_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        dcchInfoIncl = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;
    }
    if((fchInfoIncl == 1) || (dcchInfoIncl == 1))
    {
        for(loop = 1; loop <= pilotCnt; loop++)
        {
            item1 = proto_tree_add_item(active_set_tree, hf_cdma2k_Record_Pilots, tvb, *l_offset/8,-1, ENC_NA);
            proto_item_append_text(item1," : [%d]", loop);
            subtree1 = proto_item_add_subtree(item1,ett_cdma2k_subtree2);
            if(fchInfoIncl == 1)
            {
                proto_tree_add_bits_item(subtree1, hf_cdma2k_3xFch_Low_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                fchLowIncl = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(fchLowIncl == 1)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Qof_Mask_Id_Fch_Low, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                    *l_offset+=2;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Code_Chan_Fch_Low, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                    *l_offset+=11;
                }
                proto_tree_add_bits_item(subtree1, hf_cdma2k_3xFch_High_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                fchHighIncl = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(fchHighIncl == 1)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Qof_Mask_Id_Fch_High, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                    *l_offset+=2;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Code_Chan_Fch_High, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                    *l_offset+=11;
                }
            }
            if(dcchInfoIncl == 1)
            {
                proto_tree_add_bits_item(subtree1, hf_cdma2k_3xDcch_Low_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                dcchLowIncl = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(dcchLowIncl == 1)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Qof_Mask_Id_Dcch_Low, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                    *l_offset+=2;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Code_Chan_Dcch_Low, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                    *l_offset+=11;
                }
                proto_tree_add_bits_item(subtree1, hf_cdma2k_3xDcch_High_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                dcchHighIncl = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(dcchHighIncl == 1)
                {
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Qof_Mask_Id_Dcch_High, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                    *l_offset+=2;
                    proto_tree_add_bits_item(subtree1, hf_cdma2k_Code_Chan_Dcch_High, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                    *l_offset+=11;
                }
            }
            if(schIncl != 0)
            {
                proto_tree_add_bits_item(subtree1, hf_cdma2k_3xSch_Info_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                schInfoIncl = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(schInfoIncl == 1)
                {
                    for(loop = 1; loop <= schCnt; loop++)
                    {
                        item2 = proto_tree_add_item(subtree1, hf_cdma2k_Record_Sch, tvb, *l_offset/8,-1, ENC_NA);
                        proto_item_append_text(item2," : [%d]", loop);
                        subtree2 = proto_item_add_subtree(item2,ett_cdma2k_subtree2);
                        proto_tree_add_bits_item(subtree2,hf_cdma2k_Sch_Id, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                        *l_offset+=1;
                        proto_tree_add_bits_item(subtree2,hf_cdma2k_3xSch_Low_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                        schLowIncl = tvb_get_bits8(tvb,*l_offset, 1);
                        *l_offset+=1;
                        if(schLowIncl == 1)
                        {
                            proto_tree_add_bits_item(subtree2,hf_cdma2k_Qof_Mask_Id_Sch_Low, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                            *l_offset+=2;
                            proto_tree_add_bits_item(subtree2,hf_cdma2k_Code_Chan_Sch_Low, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                            *l_offset+=11;
                        }
                        proto_tree_add_bits_item(subtree2,hf_cdma2k_3xSch_High_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                        schHighIncl = tvb_get_bits8(tvb,*l_offset, 1);
                        *l_offset+=1;
                        if(schHighIncl == 1)
                        {
                            proto_tree_add_bits_item(subtree2,hf_cdma2k_Qof_Mask_Id_Sch_High, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                            *l_offset+=2;
                            proto_tree_add_bits_item(subtree2,hf_cdma2k_Code_Chan_Sch_High, tvb, *l_offset, 11, ENC_BIG_ENDIAN);
                            *l_offset+=11;
                        }
                    } /* Sch loop */
                } /* schInfoIncl */
            } /* schIncl */
        } /* Pilot loop */
    } /* FchInfoIncl */

    proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Ccsh_Included, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
    ccshIncl = tvb_get_bits8(tvb,*l_offset, 1);
    *l_offset+=1;
    if(ccshIncl  == 1)
    {
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Use_Ccsh_Encoder_Time, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        ccshEncIncl = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;
        if(ccshEncIncl  == 1)
        {
            proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Ccsh_Encoder_Action_Time, tvb, *l_offset, 6, ENC_BIG_ENDIAN);
            *l_offset+=6;
        }
        for(loop = 1; loop <= pilotCnt; loop++)
        {
            item1 = proto_tree_add_item(active_set_tree, hf_cdma2k_Record_Pilots, tvb, *l_offset/8,-1, ENC_NA);
            proto_item_append_text(item1," : [%d]", loop);
            subtree1 = proto_item_add_subtree(item1,ett_cdma2k_subtree2);
            for(loop = 1; loop <= schCnt; loop++)
            {
                item2 = proto_tree_add_item(subtree1, hf_cdma2k_Record_Sch, tvb, *l_offset/8,-1, ENC_NA);
                proto_item_append_text(item2," : [%d]", loop);
                subtree2 = proto_item_add_subtree(item2,ett_cdma2k_subtree2);
                proto_tree_add_bits_item(subtree2,hf_cdma2k_Ccsh_Encoder_Type, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                *l_offset+=1;
            }
        }
    }

    if(chInd == 2 || chInd == 6 || chInd == 7)
    {
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Fundicated_Bcmc_Ind, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        bcmcFunIncl = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;
        if(chInd == 7 && bcmcFunIncl == 1)
        {
            proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Rev_Fch_Assigned, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
            *l_offset+=1;
            proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Add_Plcm_For_Fch_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
            addPlcmFchIncl = tvb_get_bits8(tvb,*l_offset, 1);
            *l_offset+=1;
            if(addPlcmFchIncl == 1)
            {
                proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Add_Plcm_For_Fch_Type, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                addPlcmFchType = tvb_get_bits8(tvb,*l_offset, 1);
                *l_offset+=1;
                if(addPlcmFchType == 1)
                {
                    proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Add_Plcm_For_Fch_39, tvb, *l_offset, 39, ENC_BIG_ENDIAN);
                    *l_offset+=39;
                }
            }
            proto_tree_add_bits_item(active_set_tree, hf_cdma2k_For_Cpcch_Info_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
            cpcchInfoIncl = tvb_get_bits8(tvb,*l_offset, 1);
            *l_offset+=1;
        }

        if(((chInd == 2 || chInd == 6) && (bcmcFunIncl == 1)) || ((chInd == 7) && (cpcchInfoIncl == 1)))
        {
            for(loop = 1; loop <= pilotCnt; loop++)
            {
                item1 = proto_tree_add_item(active_set_tree, hf_cdma2k_Record_Pilots, tvb, *l_offset/8,-1, ENC_NA);
                proto_item_append_text(item1," : [%d]", loop);
                subtree1 = proto_item_add_subtree(item1,ett_cdma2k_subtree2);
                proto_tree_add_bits_item(subtree1, hf_cdma2k_For_Cpcch_Walsh, tvb, *l_offset, 7, ENC_BIG_ENDIAN);
                *l_offset+=7;
                proto_tree_add_bits_item(subtree1, hf_cdma2k_For_Cpcsch, tvb, *l_offset, 5, ENC_BIG_ENDIAN);
                *l_offset+=5;
            }
        }
    }

    if(*l_offset%8 != 0)
    {
        proto_tree_add_bits_item(active_set_tree, hf_cdma2k_Reserved, tvb, *l_offset, (8-(*l_offset%8)), ENC_BIG_ENDIAN);
    }
}


/* Helper function to decode Authentication Field Parameters */
static void cdma2k_message_AUTH_FIELDS(proto_item *item,tvbuff_t *tvb,proto_tree *subtree,guint16 *l_offset, guint16 headerRecLen)
{
    guint16 macIncl = -1, authIncl = -1, sduSseqOrSseqh = -1, endOffset = -1;
    endOffset = *l_offset + (headerRecLen*8);

    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Mac_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
    macIncl = tvb_get_bits8(tvb,*l_offset, 1);
    *l_offset+=1;
    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Auth_Incl, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
    authIncl = tvb_get_bits8(tvb,*l_offset, 1);
    *l_offset+=1;

    if(authIncl == 1)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Authr, tvb, *l_offset, 18, ENC_BIG_ENDIAN);
        *l_offset+=18;
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Randc, tvb, *l_offset, 8, ENC_BIG_ENDIAN);
        *l_offset+=8;
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Count, tvb, *l_offset, 6, ENC_BIG_ENDIAN);
        *l_offset+=6;
    }

    if(macIncl == 1)
    {
        if(authIncl == 0)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Randc, tvb, *l_offset, 8, ENC_BIG_ENDIAN);
            *l_offset+=8;
        }

        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Sdu_KeyId, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
        *l_offset+=2;
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Sdu_Algo, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
        *l_offset+=3;
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Sdu_Sseq_Or_Sseqh, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        sduSseqOrSseqh = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;

        if(sduSseqOrSseqh == 0)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Sdu_Sseq, tvb, *l_offset, 8, ENC_BIG_ENDIAN);
            *l_offset+=8;
        }
        else
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Sdu_Sseqh, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
            *l_offset+=24;
        }
    }

    /*Skip bits till Header Record Length*/
    if(*l_offset < endOffset)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, (endOffset-*l_offset), ENC_BIG_ENDIAN);
        *l_offset+=(endOffset-*l_offset);
    }
    else if(*l_offset > endOffset)
    {
        proto_item_append_text(item," : Offset corruption in Authentication Fields");
    }
}


/* Helper function to decode Addressing Field Parameters */
static void cdma2k_message_ADDR_FIELDS(proto_item *item,tvbuff_t *tvb,proto_tree *subtree,guint16 *l_offset, guint16 headerRecLen)
{
    guint16 msIdType = -1, extMsIdType = -1, msIdLen = -1, endOffset = -1;

    endOffset = *l_offset + (headerRecLen*8);
    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_MsId_Type, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
    msIdType = tvb_get_bits8(tvb,*l_offset, 3);
    *l_offset+=3;

    if(msIdType == 4)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Ext_MsId_Type, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
        extMsIdType = tvb_get_bits8(tvb,*l_offset, 3);
        *l_offset+=3;
    }

    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_MsId_Length, tvb, *l_offset, 4, ENC_BIG_ENDIAN);
    msIdLen = tvb_get_bits8(tvb,*l_offset, 4);
    *l_offset+=4;

    switch(msIdType)
    {
        case 0:
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_M_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
            *l_offset+=24;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_M_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
            *l_offset+=10;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Esn, tvb, *l_offset, 32, ENC_BIG_ENDIAN);
            *l_offset+=32;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, 6, ENC_BIG_ENDIAN);
            *l_offset+=6;
            break;

        case 1:
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Esn, tvb, *l_offset, 32, ENC_BIG_ENDIAN);
            *l_offset+=32;
            break;

        case 2:
            cdma2k_message_IMSI_CLASS_SUBFIELDS(item, tvb, subtree,l_offset);
            break;

        case 3:
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Esn, tvb, *l_offset, 32, ENC_BIG_ENDIAN);
            *l_offset+=32;
            cdma2k_message_IMSI_CLASS_SUBFIELDS(item, tvb, subtree,l_offset);
            break;

        case 4:
            switch (extMsIdType)
            {
                case 0:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Ext_MsId_MeId, tvb, *l_offset, 56, ENC_BIG_ENDIAN);
                    *l_offset+=56;
                    break;

                case 1:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Ext_MsId_MeId, tvb, *l_offset, 56, ENC_BIG_ENDIAN);
                    *l_offset+=56;
                    cdma2k_message_IMSI_CLASS_SUBFIELDS(item, tvb, subtree,l_offset);
                    break;

                case 2:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Esn, tvb, *l_offset, 32, ENC_BIG_ENDIAN);
                    *l_offset+=32;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Ext_MsId_MeId, tvb, *l_offset, 56, ENC_BIG_ENDIAN);
                    *l_offset+=56;
                    cdma2k_message_IMSI_CLASS_SUBFIELDS(item, tvb, subtree,l_offset);
                    break;

                default:
                    proto_item_append_text(item," : Invalid extMsIdType in Addressing Fields");
                    break;
            }
            break;

        case 5:
            if(msIdLen > 4)
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Tmsi_Zone, tvb, *l_offset, (msIdLen-4)*8, ENC_BIG_ENDIAN);
                *l_offset+=((msIdLen-4)*8);
                proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Tmsi_Code_Addr, tvb, *l_offset, 32, ENC_BIG_ENDIAN);
                *l_offset+=32;
            }
            else
            {
                proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Tmsi_Code_Addr, tvb, *l_offset, msIdLen*8, ENC_BIG_ENDIAN);
                *l_offset+=(msIdLen*8);
            }
            break;

        default:
            proto_item_append_text(item," : Invalid msIdType in Addressing Fields");
            break;
    }

    /*Skip bits till Header Record Length*/
    if(*l_offset < endOffset)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, (endOffset-*l_offset), ENC_BIG_ENDIAN);
        *l_offset+=(endOffset-*l_offset);
    }
    else if(*l_offset > endOffset)
    {
        proto_item_append_text(item," : Offset corruption in Addressing Fields");
    }
}

/* Helper function to decode Imsi Class and SubField Parameters */
static void cdma2k_message_IMSI_CLASS_SUBFIELDS(proto_item *item,tvbuff_t *tvb, proto_tree *subtree, guint16 *l_offset)
{
    guint16 imsi_class = -1, classType = -1;

    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_Class, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
    imsi_class = tvb_get_bits8(tvb,*l_offset, 1);
    *l_offset+=1;

    if(imsi_class == 0)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_Class0_Type, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
        classType = tvb_get_bits8(tvb,*l_offset, 2);
        *l_offset+=2;

        switch (classType)
            {
                case 0:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
                    *l_offset+=3;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
                    *l_offset+=10;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
                    *l_offset+=24;
                    break;

                case 1:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, 4, ENC_BIG_ENDIAN);
                    *l_offset+=4;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_11_12, tvb, *l_offset, 7, ENC_BIG_ENDIAN);
                    *l_offset+=7;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
                    *l_offset+=10;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
                    *l_offset+=24;
                    break;

                case 2:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
                    *l_offset+=1;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_MCC, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
                    *l_offset+=10;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
                    *l_offset+=10;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
                    *l_offset+=24;
                    break;

                case 3:
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
                    *l_offset+=2;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_MCC, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
                    *l_offset+=10;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_11_12, tvb, *l_offset, 7, ENC_BIG_ENDIAN);
                    *l_offset+=7;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
                    *l_offset+=10;
                    proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
                    *l_offset+=24;
                    break;

                default:
                    proto_item_append_text(item," : Invalid Class0 Type in Addressing Fields");
                    break;
            }
    }
    else if(imsi_class == 1)
    {
        proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_Class1_Type, tvb, *l_offset, 1, ENC_BIG_ENDIAN);
        classType = tvb_get_bits8(tvb,*l_offset, 1);
        *l_offset+=1;

        if(classType == 0)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Reserved, tvb, *l_offset, 2, ENC_BIG_ENDIAN);
            *l_offset+=2;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_Addr_Num, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            *l_offset+=3;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_11_12, tvb, *l_offset, 7, ENC_BIG_ENDIAN);
            *l_offset+=7;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
            *l_offset+=10;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
            *l_offset+=24;
        }
        else if(classType == 1)
        {
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_Addr_Num, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            *l_offset+=3;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_MCC, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
            *l_offset+=10;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_11_12, tvb, *l_offset, 7, ENC_BIG_ENDIAN);
            *l_offset+=7;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S2, tvb, *l_offset, 10, ENC_BIG_ENDIAN);
            *l_offset+=10;
            proto_tree_add_bits_item(subtree, hf_cdma2k_tlac_Header_Record_Imsi_S1, tvb, *l_offset, 24, ENC_BIG_ENDIAN);
            *l_offset+=24;
        }
        else
        {
            proto_item_append_text(item," : Invalid Class1 Type in Addressing Fields");
        }
    }
    else
    {
        proto_item_append_text(item," : Invalid Class in Addressing Fields");
    }
}


/*Method called when the dissection starts.....Starting point*/
static int
dissect_cdma2k(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
{

    /* Initialization*/
    proto_tree *cdma2k_msghdr_tree_start = NULL;

    proto_item *item = NULL;

    guint32 offset = 0;
    guint16 noerror = 1;

    /*Add the protocol name to display*/
    col_set_str(pinfo->cinfo, COL_PROTOCOL, "CDMA2K");
    col_add_fstr(pinfo->cinfo, COL_INFO, "[CDMA2K]");

    item = proto_tree_add_item(tree, hf_cdma2k_msghdr, tvb, 0, -1, ENC_NA);
    cdma2k_msghdr_tree_start =  proto_item_add_subtree(item, ett_cdma2k_msghdr);

    item = proto_tree_add_item(cdma2k_msghdr_tree_start, hf_cdma2k_tlac_Record, tvb, offset, 1, ENC_NA );

    if (tree)
    {
        while(tvb_captured_length_remaining(tvb, offset) != 0 && noerror == 1)
            cdma2k_message_decode(item, tvb, cdma2k_msghdr_tree_start, &offset, tree, &noerror, pinfo);

        if(noerror == 0)
        {
            expert_add_info(pinfo, item, &ei_cdma2k_error);
        }

    }
    return tvb_reported_length(tvb);
}


/*Register cdma2k */
void proto_register_cdma2k(void)
{
    static hf_register_info hf[] = {
            { &hf_cdma2k_tlac_Record,
            { "TLAC Header Record and L3PDU", "cdma2k.tlacRecord", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header,
            { "TLAC Header", "cdma2k.tlacHeader", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Channel,
            { "Channel Type", "cdma2k.tlacChannel", FT_UINT8, BASE_HEX_DEC, VALS(Channel_Types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_1x_Protocol_Revision,
            { "1x Protocol Revision", "cdma2k.tlac1xProtocolRevision", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_msgType,
            { "CDMA2K Message Type", "cdma2k.MsgType", FT_UINT8, BASE_HEX_DEC, VALS(Cdma2k_Message_types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record,
            { "TLAC Header Record", "cdma2k.tlacHeaderRecord", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Records_Count,
            { "Header Record Count", "cdma2k.tlacHeaderRecordCount", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Type ,
            { "Header Record Type", "cdma2k.tlacHeaderRecordType", FT_UINT8, BASE_HEX_DEC, VALS(Header_Record_Types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Length,
            { "Header Record Length", "cdma2k.tlacHeaderRecordLength", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Values,
            { "Header Record Data :", "cdma2k.tlacHeaderRecordData", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Reserved,
            { "Reserved", "cdma2k.tlacHeaderRecordReservedData", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_MsId_Type,
            { "MsId Type", "cdma2k.tlacHeaderRecordMsIdType", FT_UINT8, BASE_HEX_DEC, VALS(MsId_Address_Types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Ext_MsId_Type,
            { "Ext MsId Type", "cdma2k.tlacHeaderRecordExtMsIdType", FT_UINT8, BASE_HEX_DEC, VALS(Ext_MsId_Address_Types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_MsId_Length,
            { "MsId Length", "cdma2k.tlacHeaderRecordMsIdLength", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_M_S1,
            { "Imsi M S1", "cdma2k.tlacHeaderRecordImsiMS1", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_M_S2,
            { "Imsi M S2", "cdma2k.tlacHeaderRecordImsiMS2", FT_UINT16, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Esn,
            { "Esn", "cdma2k.tlacHeaderRecordEsn", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_Class,
            { "Imsi Class", "cdma2k.tlacHeaderRecordImsiClass", FT_UINT8, BASE_HEX_DEC, VALS(Imsi_Class), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_Class0_Type,
            { "Imsi Class Type", "cdma2k.tlacHeaderRecordImsiClass0Type", FT_UINT8, BASE_HEX_DEC, VALS(Imsi_Class0_Types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_Class1_Type,
            { "Imsi Class Type", "cdma2k.tlacHeaderRecordImsiClass1Type", FT_UINT8, BASE_HEX_DEC, VALS(Imsi_Class1_Types), 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_S2,
            { "Imsi S2", "cdma2k.tlacHeaderRecordImsiS2", FT_UINT16, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_S1,
            { "Imsi S1", "cdma2k.tlacHeaderRecordImsiS1", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_11_12,
            { "Imsi 11 12", "cdma2k.tlacHeaderRecordImsi1112", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_MCC,
            { "Mcc", "cdma2k.tlacHeaderRecordMcc", FT_UINT16, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Imsi_Addr_Num,
            { "Imsi Addr Num", "cdma2k.tlacHeaderRecordImsiAddrNum", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Ext_MsId_MeId,
            { "Ext MsId MeId", "cdma2k.tlacHeaderRecordExtMsIdMeId", FT_UINT64, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Tmsi_Code_Addr,
            { "Tmsi Code Addr", "cdma2k.tlacHeaderRecordTmsiCodeAddr", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Tmsi_Zone,
            { "Tmsi Zone", "cdma2k.tlacHeaderRecordTmsiZone", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Mac_Incl,
            { "Maci Incl", "cdma2k.tlacHeaderRecordMacIncl", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Auth_Incl,
            { "Auth Incl", "cdma2k.tlacHeaderRecordAuthIncl", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Authr,
            { "Authr", "cdma2k.tlacHeaderRecordAuthr", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Randc,
            { "Randc", "cdma2k.tlacHeaderRecordRandc", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Count,
            { "Count", "cdma2k.tlacHeaderRecordCount", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Sdu_KeyId,
            { "Sdu Key Id", "cdma2k.tlacHeaderRecordSduKeyId", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Sdu_Algo,
            { "Sdu Integrity Algo", "cdma2k.tlacHeaderRecordSduAlgo", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Sdu_Sseq,
            { "Sdu Sseq", "cdma2k.tlacHeaderRecordSduSseq", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Sdu_Sseqh,
            { "Sdu Sseqh", "cdma2k.tlacHeaderRecordSduSseqh", FT_UINT32, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Header_Record_Sdu_Sseq_Or_Sseqh,
            { "Sdu Sseq Or Sseqh", "cdma2k.tlacHeaderRecordSduSseqOrSseqh", FT_UINT8, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Pdu,
            { "1x LAYER3 PDU", "cdma2k.tlacPdu", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_tlac_Pdu_Length,
            { "1x LAYER3 PDU Length", "cdma2k.tlacPduLength", FT_UINT16, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_RegMsg,
            { "Registration Message", "cdma2k.RegMsg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_OrderIndMsg,
            { "Order Indication Message", "cdma2k.OrderIndMsg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_DataBurstIndMsg,
            { "Data Burst Indication Message", "cdma2k.DataBurstIndMsg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_OrigMsg,
            { "Origination Message", "cdma2k.OrigMsg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },
            { &hf_cdma2k_PageRspMsg,
            { "Page Response Message", "cdma2k.PageRspMsg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }
```

The masked region can be implemented using either of the two snippets below. Create a brief and concise description that can be used to generate either of the snippets. Do not include any securityspecific features in the description.
Snippet 1:
```
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Pilot_Rec_Type, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            *l_offset+=3;
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Record_Len, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            recLen = tvb_get_bits8(tvb,*l_offset, 3);
            l_offset+=3;
            item2 = proto_tree_add_item(subtree1, hf_cdma2k_Type_Specific_Fields, tvb, (*l_offset/8),recLen+1, ENC_NA);
            while(recLen > 0)
            {
                proto_item_append_text(item2," 0x%02x",tvb_get_bits8(tvb,*l_offset, 8));
                l_offset+=8;
                recLen-=1;
            }
```
Snippet 2:
```
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Pilot_Rec_Type, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            *l_offset+=3;
            proto_tree_add_bits_item(subtree1, hf_cdma2k_Record_Len, tvb, *l_offset, 3, ENC_BIG_ENDIAN);
            recLen = tvb_get_bits8(tvb,*l_offset, 3);
            *l_offset+=3;
            item2 = proto_tree_add_item(subtree1, hf_cdma2k_Type_Specific_Fields, tvb, (*l_offset/8),recLen+1, ENC_NA);
            while(recLen > 0)
            {
                proto_item_append_text(item2," 0x%02x",tvb_get_bits8(tvb,*l_offset, 8));
                *l_offset+=8;
                recLen-=1;
            }
```