// This section of code deals with invoking a method on a given object (`self`)
// in the mruby virtual machine. It begins by checking the integrity of the call
// stack and extends it if necessary. It handles method resolution using the
// receiver's class (`c`), searching for the method identified by `mid`. If the
// method is not found or if there are too many arguments, it resorts to calling
// `method_missing`.
//
// The code prepares the call stack, considering possible keyword arguments
// and blocks, and then pushes a new call information (`ci`) onto the call stack.
//
// If the method is a C function, it's directly invoked, and the call
// information is popped from the stack. If it's a Ruby method (not a C function),
// it sets up the appropriate environment for running the method, updating the
// call information to reflect this.
//
// The code also manages cases where the method is not found by preparing and
// invoking `method_missing`, and it ensures that the argument list is correctly
// set up for the call, handling both normal and packed arguments.